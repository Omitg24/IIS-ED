!SESSION 2021-09-19 17:02:54.368 -----------------------------------------------
eclipse.buildId=4.19.0.I20210303-1800
java.version=15.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_ES
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

This is a continuation of log file D:\Clase\3. Ingeniería Informática de Software\Segundo curso\Estructuras de Datos\Proyecto 1\ws1\.metadata\.bak_0.log
Created Time: 2021-09-19 20:21:06.205

!ENTRY org.eclipse.jdt.core 4 4 2021-09-19 20:21:06.205
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package p1Algoritmia;

import java.security.InvalidParameterException;
/**
 * Titulo: Clase Algorithms
 * 
 * @author Omar Teixeira
 * @version 10/09/2021
 */
public class Algorithms {
	/**
	 * Constante Sleep Time
	 */
	private static final long SLEEP_TIME = 1;
	
	/**
	 * Método doNothing
	 */
	public static void doNothing() {
		try {
			Thread.sleep(SLEEP_TIME);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}

	/**
	 * Método que calcula el factorial de un numero mayor o igual a cero de forma recursiva
	 * 
	 * @param n, numero a calcular el factorial
	 * @return factorial
	 */
	public long factorial (int n) { // Calcula el factorial de n>=0 de forma recursiva
		doNothing();
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);		
		
		if (n==0)
			return 1;
		else
			return n*factorial(n-1);		
	} 
	
	/**
	 * Método que calcula el numero que ocupa el n introducido en la sucesión de fibonacci
	 * 
	 * @param n, numero a calcular el fibonacci
	 * @return valor fibonacci
	 */
	public int fibonacci (int n) { // Calcula el termino n-esimo teniendo en cuenta que el primer término se considera fib(0)=0; y fib(1)=1		
		if (n<0)
		throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		
		if (n==0)
			return 0;
		else if (n==1)
			return 1;
		else
			return fibonacci(n-1)+fibonacci(n-2);		
	} 
	
	/**
	 * Método que calcula la potencia recursiva 1 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec1(int n) {  // calcula 2 elevado a n de forma recursiva 2^n = 2*2^(n-1)
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		
		if (n==0)
			return 1;
		else 
			return 2*pow2Rec1(n-1);				
	} 
	
	/**
	 * Método que calcula la potencia iterativa de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Iter (int n) {  // calcula 2 elevado a n de forma iterativa 
	    if (n<0)
	    	throw new InvalidParameterException("No permitidos exponentes negativos como "+ n); 
	    
	    long pow=2;
	    for (int i=0; i<=n;i++) {
	    	doNothing();
	    	pow=2*pow;
	    }	    
	    return pow; 
	} 

	/**
	 * Método que calcula la potencia recursiva 2 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec2 (int n) { // calcula 2 elevado a n de forma recursiva 2^n = 2^(n-1)+2^(n-1) 
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		if (n==0)
			return 1;
		else 
			return pow2Rec2(n-1) + pow2Rec2(n-1);
	} 
	
	/**
	 * Método que calcula la potencia recursiva 3 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec3 (int n) { // calcula 2 elevado a n de forma recursiva 2^n = 2^(n/2)*2^(n/2) si n par y *2 si es impar 
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		if (n==0)
			return 1;
		else if (n%2==0)
			return pow2Rec3(n/2)*pow2Rec3(n/2);
		else 
			return pow2Rec3(n/2)*pow2Rec3(n/2)*2; 
	} 
	
	/**
	 * Método que calcula la potencia recursiva 4 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec4 (int n) {  // calcula 2 elevado a n de forma recursiva 2^n = como pow2Rec3 pero sin repetir llamada 
		doNothing();
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		if (n==0) {
			return 1;
		} else { 
			if (n%2==0) {
				long res = pow2Rec4(n/2);
				return res*res;
			}
			else { 
				long res = pow2Rec4(n/2);
				return 2*res*res;
			}
		}	
		} 
	  
	/**
	 * Método que calcula la potencia de un numero a elevado al numero introducido b
	 * 
	 * @param a, base
	 * @param b, exponente
	 * @return potencia de la base elevada al exponente
	 */
	public long potenciaRec(int a, int b) { // Calcula a elevado a b de forma recursiva por potencias sucesivas 
		if (a<0 || b<0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido"); 
		
		if(a==1 || b==0)
			return 1;
		else			
			return a*potenciaRec(a,b-1);
		 
	}
	
	/**
	 * Método que calcula el resto de la división de dos numeros
	 * 
	 * @param a, dividendo
	 * @param b, divisor
	 * @return resto
	 */
	public int restoDivRec (int a, int b) {  // calcula el resto de la división a/b de forma recursiva 
		if (a<0 || b<=0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido");
		
		if (a<b)
			return a;
		else
			return restoDivRec(a-b,b);		
	} 
	
	/**
	 * Método que calcula la división entera de dos numeros
	 * 
	 * @param a, dividendo
	 * @param b, divisor
	 * @return division entera
	 */
	public int divEntRec (int a, int b) {  // calcula la división entera a/b de forma recursiva 
		if (a<0 || b<=0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido");		
		
		if (a<b)
			return 0;
		else
			return 1+divEntRec(a-b,b);		
	} 
	
	/**
	 * Método que invierte un numero entero de forma recursiva
	 * 
	 * @param n, numero a invertir
	 * @return numero invertido
	 */
	public int invertirEnteroRec(int n) {  // Invierte un entero invertirEnteroRec(1234)=4321 de forma recursiva
		if (n<10)
			return n;
		else			
			return (n%10) * (int)Math.pow(10, Integer.toString(n/10).length())+ invertirEnteroRec(n/10);
	} 

	/**
	 * Método que invierte un string de forma recursiva
	 * 
	 * @param l, string a invertir
	 * @return string invertido
	 */
	public String invertirStringRec(String l) { // Invierte un string de forma recursiva invertirStringRec("abc")="cba" 
		if (l.length()==1)
			return l;
		else
			return invertirStringRec(l.substring(1)) + l.charAt(0);
	}
	  
	/**
	 * Método que tiene una complejidad temporal lineal
	 * 
	 * @param n, parametro
	 */
	public void linear (int n) { // Algoritmo con una complejidad temporal lineal 
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		for (int i=0; i<=n; i++) {
			doNothing();
			System.out.println("El algoritmo se ha ejecutado: " + i + " vez/veces");
		}
	} 

	/**
	 * Método que tiene una complejidad temporal lineal
	 * 
	 * @param n, parametro
	 */
	public void quadratic(int n) { // Algoritmo con una complejidad temporal cuadrática 
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		for (int i=0; i<=n; i++) {
			for (int j=0; j<=n;j++) {
				doNothing();
				System.out.println("El algoritmo se ha ejecutado: " + j + " vez/veces");
			}
			System.out.println("--------"+i+"---------");
		}
	} 

	  

	public void cubic(int n) { // Algoritmo con una complejidad temporal cúbica 
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		for (int i=0; i<=n; i++) {
			for (int j=0; j<=n;j++) {
				for (int k=0; k<=n;k++) {
					doNothing();
					("El algoritmo se ha ejecutado: " + k + " vez/veces");
				}
				System.out.println("--------"+j+"---------");
			}
			System.out.println("--------"+j+"---------");
		}

	} 

	  

	public void logarithmic(int n) { // Algoritmo con una complejidad temporal logarítmica en cualquier base 

	if (n<0) 

	throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 

	} 	

	/**
	 * Método que comprueba si una matriz cuadrada es simetrica 
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	public boolean esSimetrica(int[][] m) { // Indica si es simétrica una matriz cuadrada de forma recursiva
		if (m.length == 1 && m[0].length == 1) {
			return true;
		} else if (!esCuadrada(m)) {
			return false;
		} else if (esIgualFilaColumna(m)){
			if (esSimetrica(eliminaFila(m))){
				return true;
			}			
		}
		return false;
	}
	
	/**
	 * Método que comprueba que la ultima fila es igual a la ultima columna
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	private boolean esIgualFilaColumna(int[][] m) {
		for (int i=0; i<m.length; i++) {
			if (m[m.length-1][i]!= m[i][m.length-1]) {
				return false;
			}
		}
		return true;
	}

	/**
	 * Método que elimina las filas de la matriz
	 * 
	 * @param m, matriz a la que eliminar las filas
	 * @return nueva matriz con las filas eliminadas
	 */
	private int[][] eliminaFila(int[][] m) {
		int [][] m2 = new int[m.length-1][m.length-1];		
		for (int i=0; i<m.length-1; i++) {
			for (int j=0; j<m.length-1; j++) {
				m2[i][j]=m[i][j];
			}
		}
		return m2;
	}
	
	/**
	 * Método que comprueba que una matriz es cuadrada
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	private boolean esCuadrada(int[][] m) {
		for (int i=0; i<m.length;i++) {
			if (m.length != m[i].length) {
				return false;
			}
		}
		return true;
	}
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-09-19 20:21:06.207
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-09-19 20:21:06.207
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-09-19 20:21:08.532
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package p1Algoritmia;

import java.security.InvalidParameterException;
/**
 * Titulo: Clase Algorithms
 * 
 * @author Omar Teixeira
 * @version 10/09/2021
 */
public class Algorithms {
	/**
	 * Constante Sleep Time
	 */
	private static final long SLEEP_TIME = 1;
	
	/**
	 * Método doNothing
	 */
	public static void doNothing() {
		try {
			Thread.sleep(SLEEP_TIME);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}

	/**
	 * Método que calcula el factorial de un numero mayor o igual a cero de forma recursiva
	 * 
	 * @param n, numero a calcular el factorial
	 * @return factorial
	 */
	public long factorial (int n) { // Calcula el factorial de n>=0 de forma recursiva
		doNothing();
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);		
		
		if (n==0)
			return 1;
		else
			return n*factorial(n-1);		
	} 
	
	/**
	 * Método que calcula el numero que ocupa el n introducido en la sucesión de fibonacci
	 * 
	 * @param n, numero a calcular el fibonacci
	 * @return valor fibonacci
	 */
	public int fibonacci (int n) { // Calcula el termino n-esimo teniendo en cuenta que el primer término se considera fib(0)=0; y fib(1)=1		
		if (n<0)
		throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		
		if (n==0)
			return 0;
		else if (n==1)
			return 1;
		else
			return fibonacci(n-1)+fibonacci(n-2);		
	} 
	
	/**
	 * Método que calcula la potencia recursiva 1 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec1(int n) {  // calcula 2 elevado a n de forma recursiva 2^n = 2*2^(n-1)
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		
		if (n==0)
			return 1;
		else 
			return 2*pow2Rec1(n-1);				
	} 
	
	/**
	 * Método que calcula la potencia iterativa de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Iter (int n) {  // calcula 2 elevado a n de forma iterativa 
	    if (n<0)
	    	throw new InvalidParameterException("No permitidos exponentes negativos como "+ n); 
	    
	    long pow=2;
	    for (int i=0; i<=n;i++) {
	    	doNothing();
	    	pow=2*pow;
	    }	    
	    return pow; 
	} 

	/**
	 * Método que calcula la potencia recursiva 2 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec2 (int n) { // calcula 2 elevado a n de forma recursiva 2^n = 2^(n-1)+2^(n-1) 
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		if (n==0)
			return 1;
		else 
			return pow2Rec2(n-1) + pow2Rec2(n-1);
	} 
	
	/**
	 * Método que calcula la potencia recursiva 3 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec3 (int n) { // calcula 2 elevado a n de forma recursiva 2^n = 2^(n/2)*2^(n/2) si n par y *2 si es impar 
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		if (n==0)
			return 1;
		else if (n%2==0)
			return pow2Rec3(n/2)*pow2Rec3(n/2);
		else 
			return pow2Rec3(n/2)*pow2Rec3(n/2)*2; 
	} 
	
	/**
	 * Método que calcula la potencia recursiva 4 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec4 (int n) {  // calcula 2 elevado a n de forma recursiva 2^n = como pow2Rec3 pero sin repetir llamada 
		doNothing();
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		if (n==0) {
			return 1;
		} else { 
			if (n%2==0) {
				long res = pow2Rec4(n/2);
				return res*res;
			}
			else { 
				long res = pow2Rec4(n/2);
				return 2*res*res;
			}
		}	
		} 
	  
	/**
	 * Método que calcula la potencia de un numero a elevado al numero introducido b
	 * 
	 * @param a, base
	 * @param b, exponente
	 * @return potencia de la base elevada al exponente
	 */
	public long potenciaRec(int a, int b) { // Calcula a elevado a b de forma recursiva por potencias sucesivas 
		if (a<0 || b<0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido"); 
		
		if(a==1 || b==0)
			return 1;
		else			
			return a*potenciaRec(a,b-1);
		 
	}
	
	/**
	 * Método que calcula el resto de la división de dos numeros
	 * 
	 * @param a, dividendo
	 * @param b, divisor
	 * @return resto
	 */
	public int restoDivRec (int a, int b) {  // calcula el resto de la división a/b de forma recursiva 
		if (a<0 || b<=0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido");
		
		if (a<b)
			return a;
		else
			return restoDivRec(a-b,b);		
	} 
	
	/**
	 * Método que calcula la división entera de dos numeros
	 * 
	 * @param a, dividendo
	 * @param b, divisor
	 * @return division entera
	 */
	public int divEntRec (int a, int b) {  // calcula la división entera a/b de forma recursiva 
		if (a<0 || b<=0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido");		
		
		if (a<b)
			return 0;
		else
			return 1+divEntRec(a-b,b);		
	} 
	
	/**
	 * Método que invierte un numero entero de forma recursiva
	 * 
	 * @param n, numero a invertir
	 * @return numero invertido
	 */
	public int invertirEnteroRec(int n) {  // Invierte un entero invertirEnteroRec(1234)=4321 de forma recursiva
		if (n<10)
			return n;
		else			
			return (n%10) * (int)Math.pow(10, Integer.toString(n/10).length())+ invertirEnteroRec(n/10);
	} 

	/**
	 * Método que invierte un string de forma recursiva
	 * 
	 * @param l, string a invertir
	 * @return string invertido
	 */
	public String invertirStringRec(String l) { // Invierte un string de forma recursiva invertirStringRec("abc")="cba" 
		if (l.length()==1)
			return l;
		else
			return invertirStringRec(l.substring(1)) + l.charAt(0);
	}
	  
	/**
	 * Método que tiene una complejidad temporal lineal
	 * 
	 * @param n, parametro
	 */
	public void linear (int n) { // Algoritmo con una complejidad temporal lineal 
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		for (int i=0; i<=n; i++) {
			doNothing();
			System.out.println("El algoritmo se ha ejecutado: " + i + " vez/veces");
		}
	} 

	/**
	 * Método que tiene una complejidad temporal lineal
	 * 
	 * @param n, parametro
	 */
	public void quadratic(int n) { // Algoritmo con una complejidad temporal cuadrática 
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		for (int i=0; i<=n; i++) {
			for (int j=0; j<=n;j++) {
				doNothing();
				System.out.println("El algoritmo se ha ejecutado: " + j + " vez/veces");
			}
			System.out.println("--------"+i+"---------");
		}
	} 

	  

	public void cubic(int n) { // Algoritmo con una complejidad temporal cúbica 
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		for (int i=0; i<=n; i++) {
			for (int j=0; j<=n;j++) {
				for (int k=0; k<=n;k++) {
					doNothing();
					("El algoritmo se ha ejecutado: " + k + " vez/veces");
				}
				System.out.println("--------"+j+"---------");
			}
			System.out.println("--------"+j+"---------");
		}

	} 

	  

	public void logarithmic(int n) { // Algoritmo con una complejidad temporal logarítmica en cualquier base 

	if (n<0) 

	throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 

	} 	

	/**
	 * Método que comprueba si una matriz cuadrada es simetrica 
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	public boolean esSimetrica(int[][] m) { // Indica si es simétrica una matriz cuadrada de forma recursiva
		if (m.length == 1 && m[0].length == 1) {
			return true;
		} else if (!esCuadrada(m)) {
			return false;
		} else if (esIgualFilaColumna(m)){
			if (esSimetrica(eliminaFila(m))){
				return true;
			}			
		}
		return false;
	}
	
	/**
	 * Método que comprueba que la ultima fila es igual a la ultima columna
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	private boolean esIgualFilaColumna(int[][] m) {
		for (int i=0; i<m.length; i++) {
			if (m[m.length-1][i]!= m[i][m.length-1]) {
				return false;
			}
		}
		return true;
	}

	/**
	 * Método que elimina las filas de la matriz
	 * 
	 * @param m, matriz a la que eliminar las filas
	 * @return nueva matriz con las filas eliminadas
	 */
	private int[][] eliminaFila(int[][] m) {
		int [][] m2 = new int[m.length-1][m.length-1];		
		for (int i=0; i<m.length-1; i++) {
			for (int j=0; j<m.length-1; j++) {
				m2[i][j]=m[i][j];
			}
		}
		return m2;
	}
	
	/**
	 * Método que comprueba que una matriz es cuadrada
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	private boolean esCuadrada(int[][] m) {
		for (int i=0; i<m.length;i++) {
			if (m.length != m[i].length) {
				return false;
			}
		}
		return true;
	}
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-09-19 20:21:08.534
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-09-19 20:21:08.535
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-09-19 20:21:10.041
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package p1Algoritmia;

import java.security.InvalidParameterException;
/**
 * Titulo: Clase Algorithms
 * 
 * @author Omar Teixeira
 * @version 10/09/2021
 */
public class Algorithms {
	/**
	 * Constante Sleep Time
	 */
	private static final long SLEEP_TIME = 1;
	
	/**
	 * Método doNothing
	 */
	public static void doNothing() {
		try {
			Thread.sleep(SLEEP_TIME);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}

	/**
	 * Método que calcula el factorial de un numero mayor o igual a cero de forma recursiva
	 * 
	 * @param n, numero a calcular el factorial
	 * @return factorial
	 */
	public long factorial (int n) { // Calcula el factorial de n>=0 de forma recursiva
		doNothing();
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);		
		
		if (n==0)
			return 1;
		else
			return n*factorial(n-1);		
	} 
	
	/**
	 * Método que calcula el numero que ocupa el n introducido en la sucesión de fibonacci
	 * 
	 * @param n, numero a calcular el fibonacci
	 * @return valor fibonacci
	 */
	public int fibonacci (int n) { // Calcula el termino n-esimo teniendo en cuenta que el primer término se considera fib(0)=0; y fib(1)=1		
		if (n<0)
		throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		
		if (n==0)
			return 0;
		else if (n==1)
			return 1;
		else
			return fibonacci(n-1)+fibonacci(n-2);		
	} 
	
	/**
	 * Método que calcula la potencia recursiva 1 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec1(int n) {  // calcula 2 elevado a n de forma recursiva 2^n = 2*2^(n-1)
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		
		if (n==0)
			return 1;
		else 
			return 2*pow2Rec1(n-1);				
	} 
	
	/**
	 * Método que calcula la potencia iterativa de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Iter (int n) {  // calcula 2 elevado a n de forma iterativa 
	    if (n<0)
	    	throw new InvalidParameterException("No permitidos exponentes negativos como "+ n); 
	    
	    long pow=2;
	    for (int i=0; i<=n;i++) {
	    	doNothing();
	    	pow=2*pow;
	    }	    
	    return pow; 
	} 

	/**
	 * Método que calcula la potencia recursiva 2 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec2 (int n) { // calcula 2 elevado a n de forma recursiva 2^n = 2^(n-1)+2^(n-1) 
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		if (n==0)
			return 1;
		else 
			return pow2Rec2(n-1) + pow2Rec2(n-1);
	} 
	
	/**
	 * Método que calcula la potencia recursiva 3 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec3 (int n) { // calcula 2 elevado a n de forma recursiva 2^n = 2^(n/2)*2^(n/2) si n par y *2 si es impar 
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		if (n==0)
			return 1;
		else if (n%2==0)
			return pow2Rec3(n/2)*pow2Rec3(n/2);
		else 
			return pow2Rec3(n/2)*pow2Rec3(n/2)*2; 
	} 
	
	/**
	 * Método que calcula la potencia recursiva 4 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec4 (int n) {  // calcula 2 elevado a n de forma recursiva 2^n = como pow2Rec3 pero sin repetir llamada 
		doNothing();
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		if (n==0) {
			return 1;
		} else { 
			if (n%2==0) {
				long res = pow2Rec4(n/2);
				return res*res;
			}
			else { 
				long res = pow2Rec4(n/2);
				return 2*res*res;
			}
		}	
		} 
	  
	/**
	 * Método que calcula la potencia de un numero a elevado al numero introducido b
	 * 
	 * @param a, base
	 * @param b, exponente
	 * @return potencia de la base elevada al exponente
	 */
	public long potenciaRec(int a, int b) { // Calcula a elevado a b de forma recursiva por potencias sucesivas 
		if (a<0 || b<0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido"); 
		
		if(a==1 || b==0)
			return 1;
		else			
			return a*potenciaRec(a,b-1);
		 
	}
	
	/**
	 * Método que calcula el resto de la división de dos numeros
	 * 
	 * @param a, dividendo
	 * @param b, divisor
	 * @return resto
	 */
	public int restoDivRec (int a, int b) {  // calcula el resto de la división a/b de forma recursiva 
		if (a<0 || b<=0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido");
		
		if (a<b)
			return a;
		else
			return restoDivRec(a-b,b);		
	} 
	
	/**
	 * Método que calcula la división entera de dos numeros
	 * 
	 * @param a, dividendo
	 * @param b, divisor
	 * @return division entera
	 */
	public int divEntRec (int a, int b) {  // calcula la división entera a/b de forma recursiva 
		if (a<0 || b<=0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido");		
		
		if (a<b)
			return 0;
		else
			return 1+divEntRec(a-b,b);		
	} 
	
	/**
	 * Método que invierte un numero entero de forma recursiva
	 * 
	 * @param n, numero a invertir
	 * @return numero invertido
	 */
	public int invertirEnteroRec(int n) {  // Invierte un entero invertirEnteroRec(1234)=4321 de forma recursiva
		if (n<10)
			return n;
		else			
			return (n%10) * (int)Math.pow(10, Integer.toString(n/10).length())+ invertirEnteroRec(n/10);
	} 

	/**
	 * Método que invierte un string de forma recursiva
	 * 
	 * @param l, string a invertir
	 * @return string invertido
	 */
	public String invertirStringRec(String l) { // Invierte un string de forma recursiva invertirStringRec("abc")="cba" 
		if (l.length()==1)
			return l;
		else
			return invertirStringRec(l.substring(1)) + l.charAt(0);
	}
	  
	/**
	 * Método que tiene una complejidad temporal lineal
	 * 
	 * @param n, parametro
	 */
	public void linear (int n) { // Algoritmo con una complejidad temporal lineal 
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		for (int i=0; i<=n; i++) {
			doNothing();
			System.out.println("El algoritmo se ha ejecutado: " + i + " vez/veces");
		}
	} 

	/**
	 * Método que tiene una complejidad temporal lineal
	 * 
	 * @param n, parametro
	 */
	public void quadratic(int n) { // Algoritmo con una complejidad temporal cuadrática 
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		for (int i=0; i<=n; i++) {
			for (int j=0; j<=n;j++) {
				doNothing();
				System.out.println("El algoritmo se ha ejecutado: " + j + " vez/veces");
			}
			System.out.println("--------"+i+"---------");
		}
	} 

	  

	public void cubic(int n) { // Algoritmo con una complejidad temporal cúbica 
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		for (int i=0; i<=n; i++) {
			for (int j=0; j<=n;j++) {
				for (int k=0; k<=n;k++) {
					doNothing();
					("El algoritmo se ha ejecutado: " + k + " vez/veces");
				}
				System.out.println("--------"+j+"---------");
			}
			System.out.println("~--------"+j+"---------");
		}

	} 

	  

	public void logarithmic(int n) { // Algoritmo con una complejidad temporal logarítmica en cualquier base 

	if (n<0) 

	throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 

	} 	

	/**
	 * Método que comprueba si una matriz cuadrada es simetrica 
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	public boolean esSimetrica(int[][] m) { // Indica si es simétrica una matriz cuadrada de forma recursiva
		if (m.length == 1 && m[0].length == 1) {
			return true;
		} else if (!esCuadrada(m)) {
			return false;
		} else if (esIgualFilaColumna(m)){
			if (esSimetrica(eliminaFila(m))){
				return true;
			}			
		}
		return false;
	}
	
	/**
	 * Método que comprueba que la ultima fila es igual a la ultima columna
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	private boolean esIgualFilaColumna(int[][] m) {
		for (int i=0; i<m.length; i++) {
			if (m[m.length-1][i]!= m[i][m.length-1]) {
				return false;
			}
		}
		return true;
	}

	/**
	 * Método que elimina las filas de la matriz
	 * 
	 * @param m, matriz a la que eliminar las filas
	 * @return nueva matriz con las filas eliminadas
	 */
	private int[][] eliminaFila(int[][] m) {
		int [][] m2 = new int[m.length-1][m.length-1];		
		for (int i=0; i<m.length-1; i++) {
			for (int j=0; j<m.length-1; j++) {
				m2[i][j]=m[i][j];
			}
		}
		return m2;
	}
	
	/**
	 * Método que comprueba que una matriz es cuadrada
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	private boolean esCuadrada(int[][] m) {
		for (int i=0; i<m.length;i++) {
			if (m.length != m[i].length) {
				return false;
			}
		}
		return true;
	}
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-09-19 20:21:10.043
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-09-19 20:21:10.044
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-09-19 20:21:10.355
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package p1Algoritmia;

import java.security.InvalidParameterException;
/**
 * Titulo: Clase Algorithms
 * 
 * @author Omar Teixeira
 * @version 10/09/2021
 */
public class Algorithms {
	/**
	 * Constante Sleep Time
	 */
	private static final long SLEEP_TIME = 1;
	
	/**
	 * Método doNothing
	 */
	public static void doNothing() {
		try {
			Thread.sleep(SLEEP_TIME);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}

	/**
	 * Método que calcula el factorial de un numero mayor o igual a cero de forma recursiva
	 * 
	 * @param n, numero a calcular el factorial
	 * @return factorial
	 */
	public long factorial (int n) { // Calcula el factorial de n>=0 de forma recursiva
		doNothing();
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);		
		
		if (n==0)
			return 1;
		else
			return n*factorial(n-1);		
	} 
	
	/**
	 * Método que calcula el numero que ocupa el n introducido en la sucesión de fibonacci
	 * 
	 * @param n, numero a calcular el fibonacci
	 * @return valor fibonacci
	 */
	public int fibonacci (int n) { // Calcula el termino n-esimo teniendo en cuenta que el primer término se considera fib(0)=0; y fib(1)=1		
		if (n<0)
		throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		
		if (n==0)
			return 0;
		else if (n==1)
			return 1;
		else
			return fibonacci(n-1)+fibonacci(n-2);		
	} 
	
	/**
	 * Método que calcula la potencia recursiva 1 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec1(int n) {  // calcula 2 elevado a n de forma recursiva 2^n = 2*2^(n-1)
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		
		if (n==0)
			return 1;
		else 
			return 2*pow2Rec1(n-1);				
	} 
	
	/**
	 * Método que calcula la potencia iterativa de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Iter (int n) {  // calcula 2 elevado a n de forma iterativa 
	    if (n<0)
	    	throw new InvalidParameterException("No permitidos exponentes negativos como "+ n); 
	    
	    long pow=2;
	    for (int i=0; i<=n;i++) {
	    	doNothing();
	    	pow=2*pow;
	    }	    
	    return pow; 
	} 

	/**
	 * Método que calcula la potencia recursiva 2 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec2 (int n) { // calcula 2 elevado a n de forma recursiva 2^n = 2^(n-1)+2^(n-1) 
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		if (n==0)
			return 1;
		else 
			return pow2Rec2(n-1) + pow2Rec2(n-1);
	} 
	
	/**
	 * Método que calcula la potencia recursiva 3 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec3 (int n) { // calcula 2 elevado a n de forma recursiva 2^n = 2^(n/2)*2^(n/2) si n par y *2 si es impar 
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		if (n==0)
			return 1;
		else if (n%2==0)
			return pow2Rec3(n/2)*pow2Rec3(n/2);
		else 
			return pow2Rec3(n/2)*pow2Rec3(n/2)*2; 
	} 
	
	/**
	 * Método que calcula la potencia recursiva 4 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec4 (int n) {  // calcula 2 elevado a n de forma recursiva 2^n = como pow2Rec3 pero sin repetir llamada 
		doNothing();
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		if (n==0) {
			return 1;
		} else { 
			if (n%2==0) {
				long res = pow2Rec4(n/2);
				return res*res;
			}
			else { 
				long res = pow2Rec4(n/2);
				return 2*res*res;
			}
		}	
		} 
	  
	/**
	 * Método que calcula la potencia de un numero a elevado al numero introducido b
	 * 
	 * @param a, base
	 * @param b, exponente
	 * @return potencia de la base elevada al exponente
	 */
	public long potenciaRec(int a, int b) { // Calcula a elevado a b de forma recursiva por potencias sucesivas 
		if (a<0 || b<0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido"); 
		
		if(a==1 || b==0)
			return 1;
		else			
			return a*potenciaRec(a,b-1);
		 
	}
	
	/**
	 * Método que calcula el resto de la división de dos numeros
	 * 
	 * @param a, dividendo
	 * @param b, divisor
	 * @return resto
	 */
	public int restoDivRec (int a, int b) {  // calcula el resto de la división a/b de forma recursiva 
		if (a<0 || b<=0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido");
		
		if (a<b)
			return a;
		else
			return restoDivRec(a-b,b);		
	} 
	
	/**
	 * Método que calcula la división entera de dos numeros
	 * 
	 * @param a, dividendo
	 * @param b, divisor
	 * @return division entera
	 */
	public int divEntRec (int a, int b) {  // calcula la división entera a/b de forma recursiva 
		if (a<0 || b<=0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido");		
		
		if (a<b)
			return 0;
		else
			return 1+divEntRec(a-b,b);		
	} 
	
	/**
	 * Método que invierte un numero entero de forma recursiva
	 * 
	 * @param n, numero a invertir
	 * @return numero invertido
	 */
	public int invertirEnteroRec(int n) {  // Invierte un entero invertirEnteroRec(1234)=4321 de forma recursiva
		if (n<10)
			return n;
		else			
			return (n%10) * (int)Math.pow(10, Integer.toString(n/10).length())+ invertirEnteroRec(n/10);
	} 

	/**
	 * Método que invierte un string de forma recursiva
	 * 
	 * @param l, string a invertir
	 * @return string invertido
	 */
	public String invertirStringRec(String l) { // Invierte un string de forma recursiva invertirStringRec("abc")="cba" 
		if (l.length()==1)
			return l;
		else
			return invertirStringRec(l.substring(1)) + l.charAt(0);
	}
	  
	/**
	 * Método que tiene una complejidad temporal lineal
	 * 
	 * @param n, parametro
	 */
	public void linear (int n) { // Algoritmo con una complejidad temporal lineal 
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		for (int i=0; i<=n; i++) {
			doNothing();
			System.out.println("El algoritmo se ha ejecutado: " + i + " vez/veces");
		}
	} 

	/**
	 * Método que tiene una complejidad temporal lineal
	 * 
	 * @param n, parametro
	 */
	public void quadratic(int n) { // Algoritmo con una complejidad temporal cuadrática 
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		for (int i=0; i<=n; i++) {
			for (int j=0; j<=n;j++) {
				doNothing();
				System.out.println("El algoritmo se ha ejecutado: " + j + " vez/veces");
			}
			System.out.println("--------"+i+"---------");
		}
	} 

	  

	public void cubic(int n) { // Algoritmo con una complejidad temporal cúbica 
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		for (int i=0; i<=n; i++) {
			for (int j=0; j<=n;j++) {
				for (int k=0; k<=n;k++) {
					doNothing();
					("El algoritmo se ha ejecutado: " + k + " vez/veces");
				}
				System.out.println("--------"+j+"---------");
			}
			System.out.println("~--------"+j+"---------");
		}

	} 

	  

	public void logarithmic(int n) { // Algoritmo con una complejidad temporal logarítmica en cualquier base 

	if (n<0) 

	throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 

	} 	

	/**
	 * Método que comprueba si una matriz cuadrada es simetrica 
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	public boolean esSimetrica(int[][] m) { // Indica si es simétrica una matriz cuadrada de forma recursiva
		if (m.length == 1 && m[0].length == 1) {
			return true;
		} else if (!esCuadrada(m)) {
			return false;
		} else if (esIgualFilaColumna(m)){
			if (esSimetrica(eliminaFila(m))){
				return true;
			}			
		}
		return false;
	}
	
	/**
	 * Método que comprueba que la ultima fila es igual a la ultima columna
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	private boolean esIgualFilaColumna(int[][] m) {
		for (int i=0; i<m.length; i++) {
			if (m[m.length-1][i]!= m[i][m.length-1]) {
				return false;
			}
		}
		return true;
	}

	/**
	 * Método que elimina las filas de la matriz
	 * 
	 * @param m, matriz a la que eliminar las filas
	 * @return nueva matriz con las filas eliminadas
	 */
	private int[][] eliminaFila(int[][] m) {
		int [][] m2 = new int[m.length-1][m.length-1];		
		for (int i=0; i<m.length-1; i++) {
			for (int j=0; j<m.length-1; j++) {
				m2[i][j]=m[i][j];
			}
		}
		return m2;
	}
	
	/**
	 * Método que comprueba que una matriz es cuadrada
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	private boolean esCuadrada(int[][] m) {
		for (int i=0; i<m.length;i++) {
			if (m.length != m[i].length) {
				return false;
			}
		}
		return true;
	}
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-09-19 20:21:10.357
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-09-19 20:21:10.358
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-09-19 20:21:12.550
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package p1Algoritmia;

import java.security.InvalidParameterException;
/**
 * Titulo: Clase Algorithms
 * 
 * @author Omar Teixeira
 * @version 10/09/2021
 */
public class Algorithms {
	/**
	 * Constante Sleep Time
	 */
	private static final long SLEEP_TIME = 1;
	
	/**
	 * Método doNothing
	 */
	public static void doNothing() {
		try {
			Thread.sleep(SLEEP_TIME);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}

	/**
	 * Método que calcula el factorial de un numero mayor o igual a cero de forma recursiva
	 * 
	 * @param n, numero a calcular el factorial
	 * @return factorial
	 */
	public long factorial (int n) { // Calcula el factorial de n>=0 de forma recursiva
		doNothing();
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);		
		
		if (n==0)
			return 1;
		else
			return n*factorial(n-1);		
	} 
	
	/**
	 * Método que calcula el numero que ocupa el n introducido en la sucesión de fibonacci
	 * 
	 * @param n, numero a calcular el fibonacci
	 * @return valor fibonacci
	 */
	public int fibonacci (int n) { // Calcula el termino n-esimo teniendo en cuenta que el primer término se considera fib(0)=0; y fib(1)=1		
		if (n<0)
		throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		
		if (n==0)
			return 0;
		else if (n==1)
			return 1;
		else
			return fibonacci(n-1)+fibonacci(n-2);		
	} 
	
	/**
	 * Método que calcula la potencia recursiva 1 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec1(int n) {  // calcula 2 elevado a n de forma recursiva 2^n = 2*2^(n-1)
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		
		if (n==0)
			return 1;
		else 
			return 2*pow2Rec1(n-1);				
	} 
	
	/**
	 * Método que calcula la potencia iterativa de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Iter (int n) {  // calcula 2 elevado a n de forma iterativa 
	    if (n<0)
	    	throw new InvalidParameterException("No permitidos exponentes negativos como "+ n); 
	    
	    long pow=2;
	    for (int i=0; i<=n;i++) {
	    	doNothing();
	    	pow=2*pow;
	    }	    
	    return pow; 
	} 

	/**
	 * Método que calcula la potencia recursiva 2 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec2 (int n) { // calcula 2 elevado a n de forma recursiva 2^n = 2^(n-1)+2^(n-1) 
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		if (n==0)
			return 1;
		else 
			return pow2Rec2(n-1) + pow2Rec2(n-1);
	} 
	
	/**
	 * Método que calcula la potencia recursiva 3 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec3 (int n) { // calcula 2 elevado a n de forma recursiva 2^n = 2^(n/2)*2^(n/2) si n par y *2 si es impar 
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		if (n==0)
			return 1;
		else if (n%2==0)
			return pow2Rec3(n/2)*pow2Rec3(n/2);
		else 
			return pow2Rec3(n/2)*pow2Rec3(n/2)*2; 
	} 
	
	/**
	 * Método que calcula la potencia recursiva 4 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec4 (int n) {  // calcula 2 elevado a n de forma recursiva 2^n = como pow2Rec3 pero sin repetir llamada 
		doNothing();
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		if (n==0) {
			return 1;
		} else { 
			if (n%2==0) {
				long res = pow2Rec4(n/2);
				return res*res;
			}
			else { 
				long res = pow2Rec4(n/2);
				return 2*res*res;
			}
		}	
		} 
	  
	/**
	 * Método que calcula la potencia de un numero a elevado al numero introducido b
	 * 
	 * @param a, base
	 * @param b, exponente
	 * @return potencia de la base elevada al exponente
	 */
	public long potenciaRec(int a, int b) { // Calcula a elevado a b de forma recursiva por potencias sucesivas 
		if (a<0 || b<0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido"); 
		
		if(a==1 || b==0)
			return 1;
		else			
			return a*potenciaRec(a,b-1);
		 
	}
	
	/**
	 * Método que calcula el resto de la división de dos numeros
	 * 
	 * @param a, dividendo
	 * @param b, divisor
	 * @return resto
	 */
	public int restoDivRec (int a, int b) {  // calcula el resto de la división a/b de forma recursiva 
		if (a<0 || b<=0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido");
		
		if (a<b)
			return a;
		else
			return restoDivRec(a-b,b);		
	} 
	
	/**
	 * Método que calcula la división entera de dos numeros
	 * 
	 * @param a, dividendo
	 * @param b, divisor
	 * @return division entera
	 */
	public int divEntRec (int a, int b) {  // calcula la división entera a/b de forma recursiva 
		if (a<0 || b<=0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido");		
		
		if (a<b)
			return 0;
		else
			return 1+divEntRec(a-b,b);		
	} 
	
	/**
	 * Método que invierte un numero entero de forma recursiva
	 * 
	 * @param n, numero a invertir
	 * @return numero invertido
	 */
	public int invertirEnteroRec(int n) {  // Invierte un entero invertirEnteroRec(1234)=4321 de forma recursiva
		if (n<10)
			return n;
		else			
			return (n%10) * (int)Math.pow(10, Integer.toString(n/10).length())+ invertirEnteroRec(n/10);
	} 

	/**
	 * Método que invierte un string de forma recursiva
	 * 
	 * @param l, string a invertir
	 * @return string invertido
	 */
	public String invertirStringRec(String l) { // Invierte un string de forma recursiva invertirStringRec("abc")="cba" 
		if (l.length()==1)
			return l;
		else
			return invertirStringRec(l.substring(1)) + l.charAt(0);
	}
	  
	/**
	 * Método que tiene una complejidad temporal lineal
	 * 
	 * @param n, parametro
	 */
	public void linear (int n) { // Algoritmo con una complejidad temporal lineal 
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		for (int i=0; i<=n; i++) {
			doNothing();
			System.out.println("El algoritmo se ha ejecutado: " + i + " vez/veces");
		}
	} 

	/**
	 * Método que tiene una complejidad temporal lineal
	 * 
	 * @param n, parametro
	 */
	public void quadratic(int n) { // Algoritmo con una complejidad temporal cuadrática 
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		for (int i=0; i<=n; i++) {
			for (int j=0; j<=n;j++) {
				doNothing();
				System.out.println("El algoritmo se ha ejecutado: " + j + " vez/veces");
			}
			System.out.println("--------"+i+"---------");
		}
	} 

	  

	public void cubic(int n) { // Algoritmo con una complejidad temporal cúbica 
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		for (int i=0; i<=n; i++) {
			for (int j=0; j<=n;j++) {
				for (int k=0; k<=n;k++) {
					doNothing();
					("El algoritmo se ha ejecutado: " + k + " vez/veces");
				}
				System.out.println("--------"+j+"---------");
			}
			System.out.println("~"
					+ "--------"+j+"---------");
		}

	} 

	  

	public void logarithmic(int n) { // Algoritmo con una complejidad temporal logarítmica en cualquier base 

	if (n<0) 

	throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 

	} 	

	/**
	 * Método que comprueba si una matriz cuadrada es simetrica 
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	public boolean esSimetrica(int[][] m) { // Indica si es simétrica una matriz cuadrada de forma recursiva
		if (m.length == 1 && m[0].length == 1) {
			return true;
		} else if (!esCuadrada(m)) {
			return false;
		} else if (esIgualFilaColumna(m)){
			if (esSimetrica(eliminaFila(m))){
				return true;
			}			
		}
		return false;
	}
	
	/**
	 * Método que comprueba que la ultima fila es igual a la ultima columna
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	private boolean esIgualFilaColumna(int[][] m) {
		for (int i=0; i<m.length; i++) {
			if (m[m.length-1][i]!= m[i][m.length-1]) {
				return false;
			}
		}
		return true;
	}

	/**
	 * Método que elimina las filas de la matriz
	 * 
	 * @param m, matriz a la que eliminar las filas
	 * @return nueva matriz con las filas eliminadas
	 */
	private int[][] eliminaFila(int[][] m) {
		int [][] m2 = new int[m.length-1][m.length-1];		
		for (int i=0; i<m.length-1; i++) {
			for (int j=0; j<m.length-1; j++) {
				m2[i][j]=m[i][j];
			}
		}
		return m2;
	}
	
	/**
	 * Método que comprueba que una matriz es cuadrada
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	private boolean esCuadrada(int[][] m) {
		for (int i=0; i<m.length;i++) {
			if (m.length != m[i].length) {
				return false;
			}
		}
		return true;
	}
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-09-19 20:21:12.551
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-09-19 20:21:12.553
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-09-19 20:21:14.058
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package p1Algoritmia;

import java.security.InvalidParameterException;
/**
 * Titulo: Clase Algorithms
 * 
 * @author Omar Teixeira
 * @version 10/09/2021
 */
public class Algorithms {
	/**
	 * Constante Sleep Time
	 */
	private static final long SLEEP_TIME = 1;
	
	/**
	 * Método doNothing
	 */
	public static void doNothing() {
		try {
			Thread.sleep(SLEEP_TIME);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}

	/**
	 * Método que calcula el factorial de un numero mayor o igual a cero de forma recursiva
	 * 
	 * @param n, numero a calcular el factorial
	 * @return factorial
	 */
	public long factorial (int n) { // Calcula el factorial de n>=0 de forma recursiva
		doNothing();
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);		
		
		if (n==0)
			return 1;
		else
			return n*factorial(n-1);		
	} 
	
	/**
	 * Método que calcula el numero que ocupa el n introducido en la sucesión de fibonacci
	 * 
	 * @param n, numero a calcular el fibonacci
	 * @return valor fibonacci
	 */
	public int fibonacci (int n) { // Calcula el termino n-esimo teniendo en cuenta que el primer término se considera fib(0)=0; y fib(1)=1		
		if (n<0)
		throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		
		if (n==0)
			return 0;
		else if (n==1)
			return 1;
		else
			return fibonacci(n-1)+fibonacci(n-2);		
	} 
	
	/**
	 * Método que calcula la potencia recursiva 1 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec1(int n) {  // calcula 2 elevado a n de forma recursiva 2^n = 2*2^(n-1)
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		
		if (n==0)
			return 1;
		else 
			return 2*pow2Rec1(n-1);				
	} 
	
	/**
	 * Método que calcula la potencia iterativa de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Iter (int n) {  // calcula 2 elevado a n de forma iterativa 
	    if (n<0)
	    	throw new InvalidParameterException("No permitidos exponentes negativos como "+ n); 
	    
	    long pow=2;
	    for (int i=0; i<=n;i++) {
	    	doNothing();
	    	pow=2*pow;
	    }	    
	    return pow; 
	} 

	/**
	 * Método que calcula la potencia recursiva 2 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec2 (int n) { // calcula 2 elevado a n de forma recursiva 2^n = 2^(n-1)+2^(n-1) 
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		if (n==0)
			return 1;
		else 
			return pow2Rec2(n-1) + pow2Rec2(n-1);
	} 
	
	/**
	 * Método que calcula la potencia recursiva 3 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec3 (int n) { // calcula 2 elevado a n de forma recursiva 2^n = 2^(n/2)*2^(n/2) si n par y *2 si es impar 
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		if (n==0)
			return 1;
		else if (n%2==0)
			return pow2Rec3(n/2)*pow2Rec3(n/2);
		else 
			return pow2Rec3(n/2)*pow2Rec3(n/2)*2; 
	} 
	
	/**
	 * Método que calcula la potencia recursiva 4 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec4 (int n) {  // calcula 2 elevado a n de forma recursiva 2^n = como pow2Rec3 pero sin repetir llamada 
		doNothing();
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		if (n==0) {
			return 1;
		} else { 
			if (n%2==0) {
				long res = pow2Rec4(n/2);
				return res*res;
			}
			else { 
				long res = pow2Rec4(n/2);
				return 2*res*res;
			}
		}	
		} 
	  
	/**
	 * Método que calcula la potencia de un numero a elevado al numero introducido b
	 * 
	 * @param a, base
	 * @param b, exponente
	 * @return potencia de la base elevada al exponente
	 */
	public long potenciaRec(int a, int b) { // Calcula a elevado a b de forma recursiva por potencias sucesivas 
		if (a<0 || b<0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido"); 
		
		if(a==1 || b==0)
			return 1;
		else			
			return a*potenciaRec(a,b-1);
		 
	}
	
	/**
	 * Método que calcula el resto de la división de dos numeros
	 * 
	 * @param a, dividendo
	 * @param b, divisor
	 * @return resto
	 */
	public int restoDivRec (int a, int b) {  // calcula el resto de la división a/b de forma recursiva 
		if (a<0 || b<=0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido");
		
		if (a<b)
			return a;
		else
			return restoDivRec(a-b,b);		
	} 
	
	/**
	 * Método que calcula la división entera de dos numeros
	 * 
	 * @param a, dividendo
	 * @param b, divisor
	 * @return division entera
	 */
	public int divEntRec (int a, int b) {  // calcula la división entera a/b de forma recursiva 
		if (a<0 || b<=0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido");		
		
		if (a<b)
			return 0;
		else
			return 1+divEntRec(a-b,b);		
	} 
	
	/**
	 * Método que invierte un numero entero de forma recursiva
	 * 
	 * @param n, numero a invertir
	 * @return numero invertido
	 */
	public int invertirEnteroRec(int n) {  // Invierte un entero invertirEnteroRec(1234)=4321 de forma recursiva
		if (n<10)
			return n;
		else			
			return (n%10) * (int)Math.pow(10, Integer.toString(n/10).length())+ invertirEnteroRec(n/10);
	} 

	/**
	 * Método que invierte un string de forma recursiva
	 * 
	 * @param l, string a invertir
	 * @return string invertido
	 */
	public String invertirStringRec(String l) { // Invierte un string de forma recursiva invertirStringRec("abc")="cba" 
		if (l.length()==1)
			return l;
		else
			return invertirStringRec(l.substring(1)) + l.charAt(0);
	}
	  
	/**
	 * Método que tiene una complejidad temporal lineal
	 * 
	 * @param n, parametro
	 */
	public void linear (int n) { // Algoritmo con una complejidad temporal lineal 
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		for (int i=0; i<=n; i++) {
			doNothing();
			System.out.println("El algoritmo se ha ejecutado: " + i + " vez/veces");
		}
	} 

	/**
	 * Método que tiene una complejidad temporal lineal
	 * 
	 * @param n, parametro
	 */
	public void quadratic(int n) { // Algoritmo con una complejidad temporal cuadrática 
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		for (int i=0; i<=n; i++) {
			for (int j=0; j<=n;j++) {
				doNothing();
				System.out.println("El algoritmo se ha ejecutado: " + j + " vez/veces");
			}
			System.out.println("--------"+i+"---------");
		}
	} 

	  

	public void cubic(int n) { // Algoritmo con una complejidad temporal cúbica 
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		for (int i=0; i<=n; i++) {
			for (int j=0; j<=n;j++) {
				for (int k=0; k<=n;k++) {
					doNothing();
					("El algoritmo se ha ejecutado: " + k + " vez/veces");
				}
				System.out.println("--------"+j+"---------");
			}
			System.out.println("~--------"+j+"---------");
		}

	} 

	  

	public void logarithmic(int n) { // Algoritmo con una complejidad temporal logarítmica en cualquier base 

	if (n<0) 

	throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 

	} 	

	/**
	 * Método que comprueba si una matriz cuadrada es simetrica 
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	public boolean esSimetrica(int[][] m) { // Indica si es simétrica una matriz cuadrada de forma recursiva
		if (m.length == 1 && m[0].length == 1) {
			return true;
		} else if (!esCuadrada(m)) {
			return false;
		} else if (esIgualFilaColumna(m)){
			if (esSimetrica(eliminaFila(m))){
				return true;
			}			
		}
		return false;
	}
	
	/**
	 * Método que comprueba que la ultima fila es igual a la ultima columna
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	private boolean esIgualFilaColumna(int[][] m) {
		for (int i=0; i<m.length; i++) {
			if (m[m.length-1][i]!= m[i][m.length-1]) {
				return false;
			}
		}
		return true;
	}

	/**
	 * Método que elimina las filas de la matriz
	 * 
	 * @param m, matriz a la que eliminar las filas
	 * @return nueva matriz con las filas eliminadas
	 */
	private int[][] eliminaFila(int[][] m) {
		int [][] m2 = new int[m.length-1][m.length-1];		
		for (int i=0; i<m.length-1; i++) {
			for (int j=0; j<m.length-1; j++) {
				m2[i][j]=m[i][j];
			}
		}
		return m2;
	}
	
	/**
	 * Método que comprueba que una matriz es cuadrada
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	private boolean esCuadrada(int[][] m) {
		for (int i=0; i<m.length;i++) {
			if (m.length != m[i].length) {
				return false;
			}
		}
		return true;
	}
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-09-19 20:21:14.059
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-09-19 20:21:14.061
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-09-19 20:21:15.065
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package p1Algoritmia;

import java.security.InvalidParameterException;
/**
 * Titulo: Clase Algorithms
 * 
 * @author Omar Teixeira
 * @version 10/09/2021
 */
public class Algorithms {
	/**
	 * Constante Sleep Time
	 */
	private static final long SLEEP_TIME = 1;
	
	/**
	 * Método doNothing
	 */
	public static void doNothing() {
		try {
			Thread.sleep(SLEEP_TIME);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}

	/**
	 * Método que calcula el factorial de un numero mayor o igual a cero de forma recursiva
	 * 
	 * @param n, numero a calcular el factorial
	 * @return factorial
	 */
	public long factorial (int n) { // Calcula el factorial de n>=0 de forma recursiva
		doNothing();
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);		
		
		if (n==0)
			return 1;
		else
			return n*factorial(n-1);		
	} 
	
	/**
	 * Método que calcula el numero que ocupa el n introducido en la sucesión de fibonacci
	 * 
	 * @param n, numero a calcular el fibonacci
	 * @return valor fibonacci
	 */
	public int fibonacci (int n) { // Calcula el termino n-esimo teniendo en cuenta que el primer término se considera fib(0)=0; y fib(1)=1		
		if (n<0)
		throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		
		if (n==0)
			return 0;
		else if (n==1)
			return 1;
		else
			return fibonacci(n-1)+fibonacci(n-2);		
	} 
	
	/**
	 * Método que calcula la potencia recursiva 1 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec1(int n) {  // calcula 2 elevado a n de forma recursiva 2^n = 2*2^(n-1)
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		
		if (n==0)
			return 1;
		else 
			return 2*pow2Rec1(n-1);				
	} 
	
	/**
	 * Método que calcula la potencia iterativa de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Iter (int n) {  // calcula 2 elevado a n de forma iterativa 
	    if (n<0)
	    	throw new InvalidParameterException("No permitidos exponentes negativos como "+ n); 
	    
	    long pow=2;
	    for (int i=0; i<=n;i++) {
	    	doNothing();
	    	pow=2*pow;
	    }	    
	    return pow; 
	} 

	/**
	 * Método que calcula la potencia recursiva 2 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec2 (int n) { // calcula 2 elevado a n de forma recursiva 2^n = 2^(n-1)+2^(n-1) 
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		if (n==0)
			return 1;
		else 
			return pow2Rec2(n-1) + pow2Rec2(n-1);
	} 
	
	/**
	 * Método que calcula la potencia recursiva 3 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec3 (int n) { // calcula 2 elevado a n de forma recursiva 2^n = 2^(n/2)*2^(n/2) si n par y *2 si es impar 
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		if (n==0)
			return 1;
		else if (n%2==0)
			return pow2Rec3(n/2)*pow2Rec3(n/2);
		else 
			return pow2Rec3(n/2)*pow2Rec3(n/2)*2; 
	} 
	
	/**
	 * Método que calcula la potencia recursiva 4 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec4 (int n) {  // calcula 2 elevado a n de forma recursiva 2^n = como pow2Rec3 pero sin repetir llamada 
		doNothing();
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		if (n==0) {
			return 1;
		} else { 
			if (n%2==0) {
				long res = pow2Rec4(n/2);
				return res*res;
			}
			else { 
				long res = pow2Rec4(n/2);
				return 2*res*res;
			}
		}	
		} 
	  
	/**
	 * Método que calcula la potencia de un numero a elevado al numero introducido b
	 * 
	 * @param a, base
	 * @param b, exponente
	 * @return potencia de la base elevada al exponente
	 */
	public long potenciaRec(int a, int b) { // Calcula a elevado a b de forma recursiva por potencias sucesivas 
		if (a<0 || b<0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido"); 
		
		if(a==1 || b==0)
			return 1;
		else			
			return a*potenciaRec(a,b-1);
		 
	}
	
	/**
	 * Método que calcula el resto de la división de dos numeros
	 * 
	 * @param a, dividendo
	 * @param b, divisor
	 * @return resto
	 */
	public int restoDivRec (int a, int b) {  // calcula el resto de la división a/b de forma recursiva 
		if (a<0 || b<=0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido");
		
		if (a<b)
			return a;
		else
			return restoDivRec(a-b,b);		
	} 
	
	/**
	 * Método que calcula la división entera de dos numeros
	 * 
	 * @param a, dividendo
	 * @param b, divisor
	 * @return division entera
	 */
	public int divEntRec (int a, int b) {  // calcula la división entera a/b de forma recursiva 
		if (a<0 || b<=0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido");		
		
		if (a<b)
			return 0;
		else
			return 1+divEntRec(a-b,b);		
	} 
	
	/**
	 * Método que invierte un numero entero de forma recursiva
	 * 
	 * @param n, numero a invertir
	 * @return numero invertido
	 */
	public int invertirEnteroRec(int n) {  // Invierte un entero invertirEnteroRec(1234)=4321 de forma recursiva
		if (n<10)
			return n;
		else			
			return (n%10) * (int)Math.pow(10, Integer.toString(n/10).length())+ invertirEnteroRec(n/10);
	} 

	/**
	 * Método que invierte un string de forma recursiva
	 * 
	 * @param l, string a invertir
	 * @return string invertido
	 */
	public String invertirStringRec(String l) { // Invierte un string de forma recursiva invertirStringRec("abc")="cba" 
		if (l.length()==1)
			return l;
		else
			return invertirStringRec(l.substring(1)) + l.charAt(0);
	}
	  
	/**
	 * Método que tiene una complejidad temporal lineal
	 * 
	 * @param n, parametro
	 */
	public void linear (int n) { // Algoritmo con una complejidad temporal lineal 
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		for (int i=0; i<=n; i++) {
			doNothing();
			System.out.println("El algoritmo se ha ejecutado: " + i + " vez/veces");
		}
	} 

	/**
	 * Método que tiene una complejidad temporal lineal
	 * 
	 * @param n, parametro
	 */
	public void quadratic(int n) { // Algoritmo con una complejidad temporal cuadrática 
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		for (int i=0; i<=n; i++) {
			for (int j=0; j<=n;j++) {
				doNothing();
				System.out.println("El algoritmo se ha ejecutado: " + j + " vez/veces");
			}
			System.out.println("--------"+i+"---------");
		}
	} 

	  

	public void cubic(int n) { // Algoritmo con una complejidad temporal cúbica 
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		for (int i=0; i<=n; i++) {
			for (int j=0; j<=n;j++) {
				for (int k=0; k<=n;k++) {
					doNothing();
					("El algoritmo se ha ejecutado: " + k + " vez/veces");
				}
				System.out.println("--------"+j+"---------");
			}
			System.out.println("~-------"+j+"---------");
		}

	} 

	  

	public void logarithmic(int n) { // Algoritmo con una complejidad temporal logarítmica en cualquier base 

	if (n<0) 

	throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 

	} 	

	/**
	 * Método que comprueba si una matriz cuadrada es simetrica 
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	public boolean esSimetrica(int[][] m) { // Indica si es simétrica una matriz cuadrada de forma recursiva
		if (m.length == 1 && m[0].length == 1) {
			return true;
		} else if (!esCuadrada(m)) {
			return false;
		} else if (esIgualFilaColumna(m)){
			if (esSimetrica(eliminaFila(m))){
				return true;
			}			
		}
		return false;
	}
	
	/**
	 * Método que comprueba que la ultima fila es igual a la ultima columna
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	private boolean esIgualFilaColumna(int[][] m) {
		for (int i=0; i<m.length; i++) {
			if (m[m.length-1][i]!= m[i][m.length-1]) {
				return false;
			}
		}
		return true;
	}

	/**
	 * Método que elimina las filas de la matriz
	 * 
	 * @param m, matriz a la que eliminar las filas
	 * @return nueva matriz con las filas eliminadas
	 */
	private int[][] eliminaFila(int[][] m) {
		int [][] m2 = new int[m.length-1][m.length-1];		
		for (int i=0; i<m.length-1; i++) {
			for (int j=0; j<m.length-1; j++) {
				m2[i][j]=m[i][j];
			}
		}
		return m2;
	}
	
	/**
	 * Método que comprueba que una matriz es cuadrada
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	private boolean esCuadrada(int[][] m) {
		for (int i=0; i<m.length;i++) {
			if (m.length != m[i].length) {
				return false;
			}
		}
		return true;
	}
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-09-19 20:21:15.067
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-09-19 20:21:15.068
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-09-19 20:21:15.105
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package p1Algoritmia;

import java.security.InvalidParameterException;
/**
 * Titulo: Clase Algorithms
 * 
 * @author Omar Teixeira
 * @version 10/09/2021
 */
public class Algorithms {
	/**
	 * Constante Sleep Time
	 */
	private static final long SLEEP_TIME = 1;
	
	/**
	 * Método doNothing
	 */
	public static void doNothing() {
		try {
			Thread.sleep(SLEEP_TIME);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}

	/**
	 * Método que calcula el factorial de un numero mayor o igual a cero de forma recursiva
	 * 
	 * @param n, numero a calcular el factorial
	 * @return factorial
	 */
	public long factorial (int n) { // Calcula el factorial de n>=0 de forma recursiva
		doNothing();
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);		
		
		if (n==0)
			return 1;
		else
			return n*factorial(n-1);		
	} 
	
	/**
	 * Método que calcula el numero que ocupa el n introducido en la sucesión de fibonacci
	 * 
	 * @param n, numero a calcular el fibonacci
	 * @return valor fibonacci
	 */
	public int fibonacci (int n) { // Calcula el termino n-esimo teniendo en cuenta que el primer término se considera fib(0)=0; y fib(1)=1		
		if (n<0)
		throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		
		if (n==0)
			return 0;
		else if (n==1)
			return 1;
		else
			return fibonacci(n-1)+fibonacci(n-2);		
	} 
	
	/**
	 * Método que calcula la potencia recursiva 1 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec1(int n) {  // calcula 2 elevado a n de forma recursiva 2^n = 2*2^(n-1)
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		
		if (n==0)
			return 1;
		else 
			return 2*pow2Rec1(n-1);				
	} 
	
	/**
	 * Método que calcula la potencia iterativa de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Iter (int n) {  // calcula 2 elevado a n de forma iterativa 
	    if (n<0)
	    	throw new InvalidParameterException("No permitidos exponentes negativos como "+ n); 
	    
	    long pow=2;
	    for (int i=0; i<=n;i++) {
	    	doNothing();
	    	pow=2*pow;
	    }	    
	    return pow; 
	} 

	/**
	 * Método que calcula la potencia recursiva 2 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec2 (int n) { // calcula 2 elevado a n de forma recursiva 2^n = 2^(n-1)+2^(n-1) 
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		if (n==0)
			return 1;
		else 
			return pow2Rec2(n-1) + pow2Rec2(n-1);
	} 
	
	/**
	 * Método que calcula la potencia recursiva 3 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec3 (int n) { // calcula 2 elevado a n de forma recursiva 2^n = 2^(n/2)*2^(n/2) si n par y *2 si es impar 
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		if (n==0)
			return 1;
		else if (n%2==0)
			return pow2Rec3(n/2)*pow2Rec3(n/2);
		else 
			return pow2Rec3(n/2)*pow2Rec3(n/2)*2; 
	} 
	
	/**
	 * Método que calcula la potencia recursiva 4 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec4 (int n) {  // calcula 2 elevado a n de forma recursiva 2^n = como pow2Rec3 pero sin repetir llamada 
		doNothing();
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		if (n==0) {
			return 1;
		} else { 
			if (n%2==0) {
				long res = pow2Rec4(n/2);
				return res*res;
			}
			else { 
				long res = pow2Rec4(n/2);
				return 2*res*res;
			}
		}	
		} 
	  
	/**
	 * Método que calcula la potencia de un numero a elevado al numero introducido b
	 * 
	 * @param a, base
	 * @param b, exponente
	 * @return potencia de la base elevada al exponente
	 */
	public long potenciaRec(int a, int b) { // Calcula a elevado a b de forma recursiva por potencias sucesivas 
		if (a<0 || b<0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido"); 
		
		if(a==1 || b==0)
			return 1;
		else			
			return a*potenciaRec(a,b-1);
		 
	}
	
	/**
	 * Método que calcula el resto de la división de dos numeros
	 * 
	 * @param a, dividendo
	 * @param b, divisor
	 * @return resto
	 */
	public int restoDivRec (int a, int b) {  // calcula el resto de la división a/b de forma recursiva 
		if (a<0 || b<=0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido");
		
		if (a<b)
			return a;
		else
			return restoDivRec(a-b,b);		
	} 
	
	/**
	 * Método que calcula la división entera de dos numeros
	 * 
	 * @param a, dividendo
	 * @param b, divisor
	 * @return division entera
	 */
	public int divEntRec (int a, int b) {  // calcula la división entera a/b de forma recursiva 
		if (a<0 || b<=0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido");		
		
		if (a<b)
			return 0;
		else
			return 1+divEntRec(a-b,b);		
	} 
	
	/**
	 * Método que invierte un numero entero de forma recursiva
	 * 
	 * @param n, numero a invertir
	 * @return numero invertido
	 */
	public int invertirEnteroRec(int n) {  // Invierte un entero invertirEnteroRec(1234)=4321 de forma recursiva
		if (n<10)
			return n;
		else			
			return (n%10) * (int)Math.pow(10, Integer.toString(n/10).length())+ invertirEnteroRec(n/10);
	} 

	/**
	 * Método que invierte un string de forma recursiva
	 * 
	 * @param l, string a invertir
	 * @return string invertido
	 */
	public String invertirStringRec(String l) { // Invierte un string de forma recursiva invertirStringRec("abc")="cba" 
		if (l.length()==1)
			return l;
		else
			return invertirStringRec(l.substring(1)) + l.charAt(0);
	}
	  
	/**
	 * Método que tiene una complejidad temporal lineal
	 * 
	 * @param n, parametro
	 */
	public void linear (int n) { // Algoritmo con una complejidad temporal lineal 
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		for (int i=0; i<=n; i++) {
			doNothing();
			System.out.println("El algoritmo se ha ejecutado: " + i + " vez/veces");
		}
	} 

	/**
	 * Método que tiene una complejidad temporal lineal
	 * 
	 * @param n, parametro
	 */
	public void quadratic(int n) { // Algoritmo con una complejidad temporal cuadrática 
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		for (int i=0; i<=n; i++) {
			for (int j=0; j<=n;j++) {
				doNothing();
				System.out.println("El algoritmo se ha ejecutado: " + j + " vez/veces");
			}
			System.out.println("--------"+i+"---------");
		}
	} 

	  

	public void cubic(int n) { // Algoritmo con una complejidad temporal cúbica 
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		for (int i=0; i<=n; i++) {
			for (int j=0; j<=n;j++) {
				for (int k=0; k<=n;k++) {
					doNothing();
					("El algoritmo se ha ejecutado: " + k + " vez/veces");
				}
				System.out.println("--------"+j+"---------");
			}
			System.out.println("~-------"+j+"---------");
		}

	} 

	  

	public void logarithmic(int n) { // Algoritmo con una complejidad temporal logarítmica en cualquier base 

	if (n<0) 

	throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 

	} 	

	/**
	 * Método que comprueba si una matriz cuadrada es simetrica 
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	public boolean esSimetrica(int[][] m) { // Indica si es simétrica una matriz cuadrada de forma recursiva
		if (m.length == 1 && m[0].length == 1) {
			return true;
		} else if (!esCuadrada(m)) {
			return false;
		} else if (esIgualFilaColumna(m)){
			if (esSimetrica(eliminaFila(m))){
				return true;
			}			
		}
		return false;
	}
	
	/**
	 * Método que comprueba que la ultima fila es igual a la ultima columna
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	private boolean esIgualFilaColumna(int[][] m) {
		for (int i=0; i<m.length; i++) {
			if (m[m.length-1][i]!= m[i][m.length-1]) {
				return false;
			}
		}
		return true;
	}

	/**
	 * Método que elimina las filas de la matriz
	 * 
	 * @param m, matriz a la que eliminar las filas
	 * @return nueva matriz con las filas eliminadas
	 */
	private int[][] eliminaFila(int[][] m) {
		int [][] m2 = new int[m.length-1][m.length-1];		
		for (int i=0; i<m.length-1; i++) {
			for (int j=0; j<m.length-1; j++) {
				m2[i][j]=m[i][j];
			}
		}
		return m2;
	}
	
	/**
	 * Método que comprueba que una matriz es cuadrada
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	private boolean esCuadrada(int[][] m) {
		for (int i=0; i<m.length;i++) {
			if (m.length != m[i].length) {
				return false;
			}
		}
		return true;
	}
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-09-19 20:21:15.106
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-09-19 20:21:15.107
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-09-19 20:21:16.573
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package p1Algoritmia;

import java.security.InvalidParameterException;
/**
 * Titulo: Clase Algorithms
 * 
 * @author Omar Teixeira
 * @version 10/09/2021
 */
public class Algorithms {
	/**
	 * Constante Sleep Time
	 */
	private static final long SLEEP_TIME = 1;
	
	/**
	 * Método doNothing
	 */
	public static void doNothing() {
		try {
			Thread.sleep(SLEEP_TIME);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}

	/**
	 * Método que calcula el factorial de un numero mayor o igual a cero de forma recursiva
	 * 
	 * @param n, numero a calcular el factorial
	 * @return factorial
	 */
	public long factorial (int n) { // Calcula el factorial de n>=0 de forma recursiva
		doNothing();
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);		
		
		if (n==0)
			return 1;
		else
			return n*factorial(n-1);		
	} 
	
	/**
	 * Método que calcula el numero que ocupa el n introducido en la sucesión de fibonacci
	 * 
	 * @param n, numero a calcular el fibonacci
	 * @return valor fibonacci
	 */
	public int fibonacci (int n) { // Calcula el termino n-esimo teniendo en cuenta que el primer término se considera fib(0)=0; y fib(1)=1		
		if (n<0)
		throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		
		if (n==0)
			return 0;
		else if (n==1)
			return 1;
		else
			return fibonacci(n-1)+fibonacci(n-2);		
	} 
	
	/**
	 * Método que calcula la potencia recursiva 1 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec1(int n) {  // calcula 2 elevado a n de forma recursiva 2^n = 2*2^(n-1)
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		
		if (n==0)
			return 1;
		else 
			return 2*pow2Rec1(n-1);				
	} 
	
	/**
	 * Método que calcula la potencia iterativa de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Iter (int n) {  // calcula 2 elevado a n de forma iterativa 
	    if (n<0)
	    	throw new InvalidParameterException("No permitidos exponentes negativos como "+ n); 
	    
	    long pow=2;
	    for (int i=0; i<=n;i++) {
	    	doNothing();
	    	pow=2*pow;
	    }	    
	    return pow; 
	} 

	/**
	 * Método que calcula la potencia recursiva 2 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec2 (int n) { // calcula 2 elevado a n de forma recursiva 2^n = 2^(n-1)+2^(n-1) 
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		if (n==0)
			return 1;
		else 
			return pow2Rec2(n-1) + pow2Rec2(n-1);
	} 
	
	/**
	 * Método que calcula la potencia recursiva 3 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec3 (int n) { // calcula 2 elevado a n de forma recursiva 2^n = 2^(n/2)*2^(n/2) si n par y *2 si es impar 
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		if (n==0)
			return 1;
		else if (n%2==0)
			return pow2Rec3(n/2)*pow2Rec3(n/2);
		else 
			return pow2Rec3(n/2)*pow2Rec3(n/2)*2; 
	} 
	
	/**
	 * Método que calcula la potencia recursiva 4 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec4 (int n) {  // calcula 2 elevado a n de forma recursiva 2^n = como pow2Rec3 pero sin repetir llamada 
		doNothing();
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		if (n==0) {
			return 1;
		} else { 
			if (n%2==0) {
				long res = pow2Rec4(n/2);
				return res*res;
			}
			else { 
				long res = pow2Rec4(n/2);
				return 2*res*res;
			}
		}	
		} 
	  
	/**
	 * Método que calcula la potencia de un numero a elevado al numero introducido b
	 * 
	 * @param a, base
	 * @param b, exponente
	 * @return potencia de la base elevada al exponente
	 */
	public long potenciaRec(int a, int b) { // Calcula a elevado a b de forma recursiva por potencias sucesivas 
		if (a<0 || b<0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido"); 
		
		if(a==1 || b==0)
			return 1;
		else			
			return a*potenciaRec(a,b-1);
		 
	}
	
	/**
	 * Método que calcula el resto de la división de dos numeros
	 * 
	 * @param a, dividendo
	 * @param b, divisor
	 * @return resto
	 */
	public int restoDivRec (int a, int b) {  // calcula el resto de la división a/b de forma recursiva 
		if (a<0 || b<=0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido");
		
		if (a<b)
			return a;
		else
			return restoDivRec(a-b,b);		
	} 
	
	/**
	 * Método que calcula la división entera de dos numeros
	 * 
	 * @param a, dividendo
	 * @param b, divisor
	 * @return division entera
	 */
	public int divEntRec (int a, int b) {  // calcula la división entera a/b de forma recursiva 
		if (a<0 || b<=0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido");		
		
		if (a<b)
			return 0;
		else
			return 1+divEntRec(a-b,b);		
	} 
	
	/**
	 * Método que invierte un numero entero de forma recursiva
	 * 
	 * @param n, numero a invertir
	 * @return numero invertido
	 */
	public int invertirEnteroRec(int n) {  // Invierte un entero invertirEnteroRec(1234)=4321 de forma recursiva
		if (n<10)
			return n;
		else			
			return (n%10) * (int)Math.pow(10, Integer.toString(n/10).length())+ invertirEnteroRec(n/10);
	} 

	/**
	 * Método que invierte un string de forma recursiva
	 * 
	 * @param l, string a invertir
	 * @return string invertido
	 */
	public String invertirStringRec(String l) { // Invierte un string de forma recursiva invertirStringRec("abc")="cba" 
		if (l.length()==1)
			return l;
		else
			return invertirStringRec(l.substring(1)) + l.charAt(0);
	}
	  
	/**
	 * Método que tiene una complejidad temporal lineal
	 * 
	 * @param n, parametro
	 */
	public void linear (int n) { // Algoritmo con una complejidad temporal lineal 
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		for (int i=0; i<=n; i++) {
			doNothing();
			System.out.println("El algoritmo se ha ejecutado: " + i + " vez/veces");
		}
	} 

	/**
	 * Método que tiene una complejidad temporal lineal
	 * 
	 * @param n, parametro
	 */
	public void quadratic(int n) { // Algoritmo con una complejidad temporal cuadrática 
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		for (int i=0; i<=n; i++) {
			for (int j=0; j<=n;j++) {
				doNothing();
				System.out.println("El algoritmo se ha ejecutado: " + j + " vez/veces");
			}
			System.out.println("--------"+i+"---------");
		}
	} 

	  

	public void cubic(int n) { // Algoritmo con una complejidad temporal cúbica 
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		for (int i=0; i<=n; i++) {
			for (int j=0; j<=n;j++) {
				for (int k=0; k<=n;k++) {
					doNothing();
					("El algoritmo se ha ejecutado: " + k + " vez/veces");
				}
				System.out.println("--------"+j+"---------");
			}
			System.out.println("~~------"+j+"---------");
		}

	} 

	  

	public void logarithmic(int n) { // Algoritmo con una complejidad temporal logarítmica en cualquier base 

	if (n<0) 

	throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 

	} 	

	/**
	 * Método que comprueba si una matriz cuadrada es simetrica 
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	public boolean esSimetrica(int[][] m) { // Indica si es simétrica una matriz cuadrada de forma recursiva
		if (m.length == 1 && m[0].length == 1) {
			return true;
		} else if (!esCuadrada(m)) {
			return false;
		} else if (esIgualFilaColumna(m)){
			if (esSimetrica(eliminaFila(m))){
				return true;
			}			
		}
		return false;
	}
	
	/**
	 * Método que comprueba que la ultima fila es igual a la ultima columna
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	private boolean esIgualFilaColumna(int[][] m) {
		for (int i=0; i<m.length; i++) {
			if (m[m.length-1][i]!= m[i][m.length-1]) {
				return false;
			}
		}
		return true;
	}

	/**
	 * Método que elimina las filas de la matriz
	 * 
	 * @param m, matriz a la que eliminar las filas
	 * @return nueva matriz con las filas eliminadas
	 */
	private int[][] eliminaFila(int[][] m) {
		int [][] m2 = new int[m.length-1][m.length-1];		
		for (int i=0; i<m.length-1; i++) {
			for (int j=0; j<m.length-1; j++) {
				m2[i][j]=m[i][j];
			}
		}
		return m2;
	}
	
	/**
	 * Método que comprueba que una matriz es cuadrada
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	private boolean esCuadrada(int[][] m) {
		for (int i=0; i<m.length;i++) {
			if (m.length != m[i].length) {
				return false;
			}
		}
		return true;
	}
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-09-19 20:21:16.575
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-09-19 20:21:16.576
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-09-19 20:21:16.749
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package p1Algoritmia;

import java.security.InvalidParameterException;
/**
 * Titulo: Clase Algorithms
 * 
 * @author Omar Teixeira
 * @version 10/09/2021
 */
public class Algorithms {
	/**
	 * Constante Sleep Time
	 */
	private static final long SLEEP_TIME = 1;
	
	/**
	 * Método doNothing
	 */
	public static void doNothing() {
		try {
			Thread.sleep(SLEEP_TIME);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}

	/**
	 * Método que calcula el factorial de un numero mayor o igual a cero de forma recursiva
	 * 
	 * @param n, numero a calcular el factorial
	 * @return factorial
	 */
	public long factorial (int n) { // Calcula el factorial de n>=0 de forma recursiva
		doNothing();
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);		
		
		if (n==0)
			return 1;
		else
			return n*factorial(n-1);		
	} 
	
	/**
	 * Método que calcula el numero que ocupa el n introducido en la sucesión de fibonacci
	 * 
	 * @param n, numero a calcular el fibonacci
	 * @return valor fibonacci
	 */
	public int fibonacci (int n) { // Calcula el termino n-esimo teniendo en cuenta que el primer término se considera fib(0)=0; y fib(1)=1		
		if (n<0)
		throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		
		if (n==0)
			return 0;
		else if (n==1)
			return 1;
		else
			return fibonacci(n-1)+fibonacci(n-2);		
	} 
	
	/**
	 * Método que calcula la potencia recursiva 1 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec1(int n) {  // calcula 2 elevado a n de forma recursiva 2^n = 2*2^(n-1)
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		
		if (n==0)
			return 1;
		else 
			return 2*pow2Rec1(n-1);				
	} 
	
	/**
	 * Método que calcula la potencia iterativa de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Iter (int n) {  // calcula 2 elevado a n de forma iterativa 
	    if (n<0)
	    	throw new InvalidParameterException("No permitidos exponentes negativos como "+ n); 
	    
	    long pow=2;
	    for (int i=0; i<=n;i++) {
	    	doNothing();
	    	pow=2*pow;
	    }	    
	    return pow; 
	} 

	/**
	 * Método que calcula la potencia recursiva 2 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec2 (int n) { // calcula 2 elevado a n de forma recursiva 2^n = 2^(n-1)+2^(n-1) 
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		if (n==0)
			return 1;
		else 
			return pow2Rec2(n-1) + pow2Rec2(n-1);
	} 
	
	/**
	 * Método que calcula la potencia recursiva 3 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec3 (int n) { // calcula 2 elevado a n de forma recursiva 2^n = 2^(n/2)*2^(n/2) si n par y *2 si es impar 
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		if (n==0)
			return 1;
		else if (n%2==0)
			return pow2Rec3(n/2)*pow2Rec3(n/2);
		else 
			return pow2Rec3(n/2)*pow2Rec3(n/2)*2; 
	} 
	
	/**
	 * Método que calcula la potencia recursiva 4 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec4 (int n) {  // calcula 2 elevado a n de forma recursiva 2^n = como pow2Rec3 pero sin repetir llamada 
		doNothing();
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		if (n==0) {
			return 1;
		} else { 
			if (n%2==0) {
				long res = pow2Rec4(n/2);
				return res*res;
			}
			else { 
				long res = pow2Rec4(n/2);
				return 2*res*res;
			}
		}	
		} 
	  
	/**
	 * Método que calcula la potencia de un numero a elevado al numero introducido b
	 * 
	 * @param a, base
	 * @param b, exponente
	 * @return potencia de la base elevada al exponente
	 */
	public long potenciaRec(int a, int b) { // Calcula a elevado a b de forma recursiva por potencias sucesivas 
		if (a<0 || b<0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido"); 
		
		if(a==1 || b==0)
			return 1;
		else			
			return a*potenciaRec(a,b-1);
		 
	}
	
	/**
	 * Método que calcula el resto de la división de dos numeros
	 * 
	 * @param a, dividendo
	 * @param b, divisor
	 * @return resto
	 */
	public int restoDivRec (int a, int b) {  // calcula el resto de la división a/b de forma recursiva 
		if (a<0 || b<=0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido");
		
		if (a<b)
			return a;
		else
			return restoDivRec(a-b,b);		
	} 
	
	/**
	 * Método que calcula la división entera de dos numeros
	 * 
	 * @param a, dividendo
	 * @param b, divisor
	 * @return division entera
	 */
	public int divEntRec (int a, int b) {  // calcula la división entera a/b de forma recursiva 
		if (a<0 || b<=0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido");		
		
		if (a<b)
			return 0;
		else
			return 1+divEntRec(a-b,b);		
	} 
	
	/**
	 * Método que invierte un numero entero de forma recursiva
	 * 
	 * @param n, numero a invertir
	 * @return numero invertido
	 */
	public int invertirEnteroRec(int n) {  // Invierte un entero invertirEnteroRec(1234)=4321 de forma recursiva
		if (n<10)
			return n;
		else			
			return (n%10) * (int)Math.pow(10, Integer.toString(n/10).length())+ invertirEnteroRec(n/10);
	} 

	/**
	 * Método que invierte un string de forma recursiva
	 * 
	 * @param l, string a invertir
	 * @return string invertido
	 */
	public String invertirStringRec(String l) { // Invierte un string de forma recursiva invertirStringRec("abc")="cba" 
		if (l.length()==1)
			return l;
		else
			return invertirStringRec(l.substring(1)) + l.charAt(0);
	}
	  
	/**
	 * Método que tiene una complejidad temporal lineal
	 * 
	 * @param n, parametro
	 */
	public void linear (int n) { // Algoritmo con una complejidad temporal lineal 
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		for (int i=0; i<=n; i++) {
			doNothing();
			System.out.println("El algoritmo se ha ejecutado: " + i + " vez/veces");
		}
	} 

	/**
	 * Método que tiene una complejidad temporal lineal
	 * 
	 * @param n, parametro
	 */
	public void quadratic(int n) { // Algoritmo con una complejidad temporal cuadrática 
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		for (int i=0; i<=n; i++) {
			for (int j=0; j<=n;j++) {
				doNothing();
				System.out.println("El algoritmo se ha ejecutado: " + j + " vez/veces");
			}
			System.out.println("--------"+i+"---------");
		}
	} 

	  

	public void cubic(int n) { // Algoritmo con una complejidad temporal cúbica 
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		for (int i=0; i<=n; i++) {
			for (int j=0; j<=n;j++) {
				for (int k=0; k<=n;k++) {
					doNothing();
					("El algoritmo se ha ejecutado: " + k + " vez/veces");
				}
				System.out.println("--------"+j+"---------");
			}
			System.out.println("~~------"+j+"---------");
		}

	} 

	  

	public void logarithmic(int n) { // Algoritmo con una complejidad temporal logarítmica en cualquier base 

	if (n<0) 

	throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 

	} 	

	/**
	 * Método que comprueba si una matriz cuadrada es simetrica 
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	public boolean esSimetrica(int[][] m) { // Indica si es simétrica una matriz cuadrada de forma recursiva
		if (m.length == 1 && m[0].length == 1) {
			return true;
		} else if (!esCuadrada(m)) {
			return false;
		} else if (esIgualFilaColumna(m)){
			if (esSimetrica(eliminaFila(m))){
				return true;
			}			
		}
		return false;
	}
	
	/**
	 * Método que comprueba que la ultima fila es igual a la ultima columna
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	private boolean esIgualFilaColumna(int[][] m) {
		for (int i=0; i<m.length; i++) {
			if (m[m.length-1][i]!= m[i][m.length-1]) {
				return false;
			}
		}
		return true;
	}

	/**
	 * Método que elimina las filas de la matriz
	 * 
	 * @param m, matriz a la que eliminar las filas
	 * @return nueva matriz con las filas eliminadas
	 */
	private int[][] eliminaFila(int[][] m) {
		int [][] m2 = new int[m.length-1][m.length-1];		
		for (int i=0; i<m.length-1; i++) {
			for (int j=0; j<m.length-1; j++) {
				m2[i][j]=m[i][j];
			}
		}
		return m2;
	}
	
	/**
	 * Método que comprueba que una matriz es cuadrada
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	private boolean esCuadrada(int[][] m) {
		for (int i=0; i<m.length;i++) {
			if (m.length != m[i].length) {
				return false;
			}
		}
		return true;
	}
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-09-19 20:21:16.751
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-09-19 20:21:16.753
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-09-19 20:21:18.081
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package p1Algoritmia;

import java.security.InvalidParameterException;
/**
 * Titulo: Clase Algorithms
 * 
 * @author Omar Teixeira
 * @version 10/09/2021
 */
public class Algorithms {
	/**
	 * Constante Sleep Time
	 */
	private static final long SLEEP_TIME = 1;
	
	/**
	 * Método doNothing
	 */
	public static void doNothing() {
		try {
			Thread.sleep(SLEEP_TIME);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}

	/**
	 * Método que calcula el factorial de un numero mayor o igual a cero de forma recursiva
	 * 
	 * @param n, numero a calcular el factorial
	 * @return factorial
	 */
	public long factorial (int n) { // Calcula el factorial de n>=0 de forma recursiva
		doNothing();
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);		
		
		if (n==0)
			return 1;
		else
			return n*factorial(n-1);		
	} 
	
	/**
	 * Método que calcula el numero que ocupa el n introducido en la sucesión de fibonacci
	 * 
	 * @param n, numero a calcular el fibonacci
	 * @return valor fibonacci
	 */
	public int fibonacci (int n) { // Calcula el termino n-esimo teniendo en cuenta que el primer término se considera fib(0)=0; y fib(1)=1		
		if (n<0)
		throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		
		if (n==0)
			return 0;
		else if (n==1)
			return 1;
		else
			return fibonacci(n-1)+fibonacci(n-2);		
	} 
	
	/**
	 * Método que calcula la potencia recursiva 1 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec1(int n) {  // calcula 2 elevado a n de forma recursiva 2^n = 2*2^(n-1)
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		
		if (n==0)
			return 1;
		else 
			return 2*pow2Rec1(n-1);				
	} 
	
	/**
	 * Método que calcula la potencia iterativa de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Iter (int n) {  // calcula 2 elevado a n de forma iterativa 
	    if (n<0)
	    	throw new InvalidParameterException("No permitidos exponentes negativos como "+ n); 
	    
	    long pow=2;
	    for (int i=0; i<=n;i++) {
	    	doNothing();
	    	pow=2*pow;
	    }	    
	    return pow; 
	} 

	/**
	 * Método que calcula la potencia recursiva 2 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec2 (int n) { // calcula 2 elevado a n de forma recursiva 2^n = 2^(n-1)+2^(n-1) 
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		if (n==0)
			return 1;
		else 
			return pow2Rec2(n-1) + pow2Rec2(n-1);
	} 
	
	/**
	 * Método que calcula la potencia recursiva 3 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec3 (int n) { // calcula 2 elevado a n de forma recursiva 2^n = 2^(n/2)*2^(n/2) si n par y *2 si es impar 
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		if (n==0)
			return 1;
		else if (n%2==0)
			return pow2Rec3(n/2)*pow2Rec3(n/2);
		else 
			return pow2Rec3(n/2)*pow2Rec3(n/2)*2; 
	} 
	
	/**
	 * Método que calcula la potencia recursiva 4 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec4 (int n) {  // calcula 2 elevado a n de forma recursiva 2^n = como pow2Rec3 pero sin repetir llamada 
		doNothing();
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		if (n==0) {
			return 1;
		} else { 
			if (n%2==0) {
				long res = pow2Rec4(n/2);
				return res*res;
			}
			else { 
				long res = pow2Rec4(n/2);
				return 2*res*res;
			}
		}	
		} 
	  
	/**
	 * Método que calcula la potencia de un numero a elevado al numero introducido b
	 * 
	 * @param a, base
	 * @param b, exponente
	 * @return potencia de la base elevada al exponente
	 */
	public long potenciaRec(int a, int b) { // Calcula a elevado a b de forma recursiva por potencias sucesivas 
		if (a<0 || b<0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido"); 
		
		if(a==1 || b==0)
			return 1;
		else			
			return a*potenciaRec(a,b-1);
		 
	}
	
	/**
	 * Método que calcula el resto de la división de dos numeros
	 * 
	 * @param a, dividendo
	 * @param b, divisor
	 * @return resto
	 */
	public int restoDivRec (int a, int b) {  // calcula el resto de la división a/b de forma recursiva 
		if (a<0 || b<=0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido");
		
		if (a<b)
			return a;
		else
			return restoDivRec(a-b,b);		
	} 
	
	/**
	 * Método que calcula la división entera de dos numeros
	 * 
	 * @param a, dividendo
	 * @param b, divisor
	 * @return division entera
	 */
	public int divEntRec (int a, int b) {  // calcula la división entera a/b de forma recursiva 
		if (a<0 || b<=0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido");		
		
		if (a<b)
			return 0;
		else
			return 1+divEntRec(a-b,b);		
	} 
	
	/**
	 * Método que invierte un numero entero de forma recursiva
	 * 
	 * @param n, numero a invertir
	 * @return numero invertido
	 */
	public int invertirEnteroRec(int n) {  // Invierte un entero invertirEnteroRec(1234)=4321 de forma recursiva
		if (n<10)
			return n;
		else			
			return (n%10) * (int)Math.pow(10, Integer.toString(n/10).length())+ invertirEnteroRec(n/10);
	} 

	/**
	 * Método que invierte un string de forma recursiva
	 * 
	 * @param l, string a invertir
	 * @return string invertido
	 */
	public String invertirStringRec(String l) { // Invierte un string de forma recursiva invertirStringRec("abc")="cba" 
		if (l.length()==1)
			return l;
		else
			return invertirStringRec(l.substring(1)) + l.charAt(0);
	}
	  
	/**
	 * Método que tiene una complejidad temporal lineal
	 * 
	 * @param n, parametro
	 */
	public void linear (int n) { // Algoritmo con una complejidad temporal lineal 
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		for (int i=0; i<=n; i++) {
			doNothing();
			System.out.println("El algoritmo se ha ejecutado: " + i + " vez/veces");
		}
	} 

	/**
	 * Método que tiene una complejidad temporal lineal
	 * 
	 * @param n, parametro
	 */
	public void quadratic(int n) { // Algoritmo con una complejidad temporal cuadrática 
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		for (int i=0; i<=n; i++) {
			for (int j=0; j<=n;j++) {
				doNothing();
				System.out.println("El algoritmo se ha ejecutado: " + j + " vez/veces");
			}
			System.out.println("--------"+i+"---------");
		}
	} 

	  

	public void cubic(int n) { // Algoritmo con una complejidad temporal cúbica 
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		for (int i=0; i<=n; i++) {
			for (int j=0; j<=n;j++) {
				for (int k=0; k<=n;k++) {
					doNothing();
					("El algoritmo se ha ejecutado: " + k + " vez/veces");
				}
				System.out.println("--------"+j+"---------");
			}
			System.out.println("~~~-----"+j+"---------");
		}

	} 

	  

	public void logarithmic(int n) { // Algoritmo con una complejidad temporal logarítmica en cualquier base 

	if (n<0) 

	throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 

	} 	

	/**
	 * Método que comprueba si una matriz cuadrada es simetrica 
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	public boolean esSimetrica(int[][] m) { // Indica si es simétrica una matriz cuadrada de forma recursiva
		if (m.length == 1 && m[0].length == 1) {
			return true;
		} else if (!esCuadrada(m)) {
			return false;
		} else if (esIgualFilaColumna(m)){
			if (esSimetrica(eliminaFila(m))){
				return true;
			}			
		}
		return false;
	}
	
	/**
	 * Método que comprueba que la ultima fila es igual a la ultima columna
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	private boolean esIgualFilaColumna(int[][] m) {
		for (int i=0; i<m.length; i++) {
			if (m[m.length-1][i]!= m[i][m.length-1]) {
				return false;
			}
		}
		return true;
	}

	/**
	 * Método que elimina las filas de la matriz
	 * 
	 * @param m, matriz a la que eliminar las filas
	 * @return nueva matriz con las filas eliminadas
	 */
	private int[][] eliminaFila(int[][] m) {
		int [][] m2 = new int[m.length-1][m.length-1];		
		for (int i=0; i<m.length-1; i++) {
			for (int j=0; j<m.length-1; j++) {
				m2[i][j]=m[i][j];
			}
		}
		return m2;
	}
	
	/**
	 * Método que comprueba que una matriz es cuadrada
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	private boolean esCuadrada(int[][] m) {
		for (int i=0; i<m.length;i++) {
			if (m.length != m[i].length) {
				return false;
			}
		}
		return true;
	}
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-09-19 20:21:18.083
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-09-19 20:21:18.084
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-09-19 20:21:18.376
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package p1Algoritmia;

import java.security.InvalidParameterException;
/**
 * Titulo: Clase Algorithms
 * 
 * @author Omar Teixeira
 * @version 10/09/2021
 */
public class Algorithms {
	/**
	 * Constante Sleep Time
	 */
	private static final long SLEEP_TIME = 1;
	
	/**
	 * Método doNothing
	 */
	public static void doNothing() {
		try {
			Thread.sleep(SLEEP_TIME);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}

	/**
	 * Método que calcula el factorial de un numero mayor o igual a cero de forma recursiva
	 * 
	 * @param n, numero a calcular el factorial
	 * @return factorial
	 */
	public long factorial (int n) { // Calcula el factorial de n>=0 de forma recursiva
		doNothing();
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);		
		
		if (n==0)
			return 1;
		else
			return n*factorial(n-1);		
	} 
	
	/**
	 * Método que calcula el numero que ocupa el n introducido en la sucesión de fibonacci
	 * 
	 * @param n, numero a calcular el fibonacci
	 * @return valor fibonacci
	 */
	public int fibonacci (int n) { // Calcula el termino n-esimo teniendo en cuenta que el primer término se considera fib(0)=0; y fib(1)=1		
		if (n<0)
		throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		
		if (n==0)
			return 0;
		else if (n==1)
			return 1;
		else
			return fibonacci(n-1)+fibonacci(n-2);		
	} 
	
	/**
	 * Método que calcula la potencia recursiva 1 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec1(int n) {  // calcula 2 elevado a n de forma recursiva 2^n = 2*2^(n-1)
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		
		if (n==0)
			return 1;
		else 
			return 2*pow2Rec1(n-1);				
	} 
	
	/**
	 * Método que calcula la potencia iterativa de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Iter (int n) {  // calcula 2 elevado a n de forma iterativa 
	    if (n<0)
	    	throw new InvalidParameterException("No permitidos exponentes negativos como "+ n); 
	    
	    long pow=2;
	    for (int i=0; i<=n;i++) {
	    	doNothing();
	    	pow=2*pow;
	    }	    
	    return pow; 
	} 

	/**
	 * Método que calcula la potencia recursiva 2 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec2 (int n) { // calcula 2 elevado a n de forma recursiva 2^n = 2^(n-1)+2^(n-1) 
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		if (n==0)
			return 1;
		else 
			return pow2Rec2(n-1) + pow2Rec2(n-1);
	} 
	
	/**
	 * Método que calcula la potencia recursiva 3 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec3 (int n) { // calcula 2 elevado a n de forma recursiva 2^n = 2^(n/2)*2^(n/2) si n par y *2 si es impar 
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		if (n==0)
			return 1;
		else if (n%2==0)
			return pow2Rec3(n/2)*pow2Rec3(n/2);
		else 
			return pow2Rec3(n/2)*pow2Rec3(n/2)*2; 
	} 
	
	/**
	 * Método que calcula la potencia recursiva 4 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec4 (int n) {  // calcula 2 elevado a n de forma recursiva 2^n = como pow2Rec3 pero sin repetir llamada 
		doNothing();
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		if (n==0) {
			return 1;
		} else { 
			if (n%2==0) {
				long res = pow2Rec4(n/2);
				return res*res;
			}
			else { 
				long res = pow2Rec4(n/2);
				return 2*res*res;
			}
		}	
		} 
	  
	/**
	 * Método que calcula la potencia de un numero a elevado al numero introducido b
	 * 
	 * @param a, base
	 * @param b, exponente
	 * @return potencia de la base elevada al exponente
	 */
	public long potenciaRec(int a, int b) { // Calcula a elevado a b de forma recursiva por potencias sucesivas 
		if (a<0 || b<0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido"); 
		
		if(a==1 || b==0)
			return 1;
		else			
			return a*potenciaRec(a,b-1);
		 
	}
	
	/**
	 * Método que calcula el resto de la división de dos numeros
	 * 
	 * @param a, dividendo
	 * @param b, divisor
	 * @return resto
	 */
	public int restoDivRec (int a, int b) {  // calcula el resto de la división a/b de forma recursiva 
		if (a<0 || b<=0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido");
		
		if (a<b)
			return a;
		else
			return restoDivRec(a-b,b);		
	} 
	
	/**
	 * Método que calcula la división entera de dos numeros
	 * 
	 * @param a, dividendo
	 * @param b, divisor
	 * @return division entera
	 */
	public int divEntRec (int a, int b) {  // calcula la división entera a/b de forma recursiva 
		if (a<0 || b<=0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido");		
		
		if (a<b)
			return 0;
		else
			return 1+divEntRec(a-b,b);		
	} 
	
	/**
	 * Método que invierte un numero entero de forma recursiva
	 * 
	 * @param n, numero a invertir
	 * @return numero invertido
	 */
	public int invertirEnteroRec(int n) {  // Invierte un entero invertirEnteroRec(1234)=4321 de forma recursiva
		if (n<10)
			return n;
		else			
			return (n%10) * (int)Math.pow(10, Integer.toString(n/10).length())+ invertirEnteroRec(n/10);
	} 

	/**
	 * Método que invierte un string de forma recursiva
	 * 
	 * @param l, string a invertir
	 * @return string invertido
	 */
	public String invertirStringRec(String l) { // Invierte un string de forma recursiva invertirStringRec("abc")="cba" 
		if (l.length()==1)
			return l;
		else
			return invertirStringRec(l.substring(1)) + l.charAt(0);
	}
	  
	/**
	 * Método que tiene una complejidad temporal lineal
	 * 
	 * @param n, parametro
	 */
	public void linear (int n) { // Algoritmo con una complejidad temporal lineal 
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		for (int i=0; i<=n; i++) {
			doNothing();
			System.out.println("El algoritmo se ha ejecutado: " + i + " vez/veces");
		}
	} 

	/**
	 * Método que tiene una complejidad temporal lineal
	 * 
	 * @param n, parametro
	 */
	public void quadratic(int n) { // Algoritmo con una complejidad temporal cuadrática 
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		for (int i=0; i<=n; i++) {
			for (int j=0; j<=n;j++) {
				doNothing();
				System.out.println("El algoritmo se ha ejecutado: " + j + " vez/veces");
			}
			System.out.println("--------"+i+"---------");
		}
	} 

	  

	public void cubic(int n) { // Algoritmo con una complejidad temporal cúbica 
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		for (int i=0; i<=n; i++) {
			for (int j=0; j<=n;j++) {
				for (int k=0; k<=n;k++) {
					doNothing();
					("El algoritmo se ha ejecutado: " + k + " vez/veces");
				}
				System.out.println("--------"+j+"---------");
			}
			System.out.println("~~~-----"+j+"---------");
		}

	} 

	  

	public void logarithmic(int n) { // Algoritmo con una complejidad temporal logarítmica en cualquier base 

	if (n<0) 

	throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 

	} 	

	/**
	 * Método que comprueba si una matriz cuadrada es simetrica 
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	public boolean esSimetrica(int[][] m) { // Indica si es simétrica una matriz cuadrada de forma recursiva
		if (m.length == 1 && m[0].length == 1) {
			return true;
		} else if (!esCuadrada(m)) {
			return false;
		} else if (esIgualFilaColumna(m)){
			if (esSimetrica(eliminaFila(m))){
				return true;
			}			
		}
		return false;
	}
	
	/**
	 * Método que comprueba que la ultima fila es igual a la ultima columna
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	private boolean esIgualFilaColumna(int[][] m) {
		for (int i=0; i<m.length; i++) {
			if (m[m.length-1][i]!= m[i][m.length-1]) {
				return false;
			}
		}
		return true;
	}

	/**
	 * Método que elimina las filas de la matriz
	 * 
	 * @param m, matriz a la que eliminar las filas
	 * @return nueva matriz con las filas eliminadas
	 */
	private int[][] eliminaFila(int[][] m) {
		int [][] m2 = new int[m.length-1][m.length-1];		
		for (int i=0; i<m.length-1; i++) {
			for (int j=0; j<m.length-1; j++) {
				m2[i][j]=m[i][j];
			}
		}
		return m2;
	}
	
	/**
	 * Método que comprueba que una matriz es cuadrada
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	private boolean esCuadrada(int[][] m) {
		for (int i=0; i<m.length;i++) {
			if (m.length != m[i].length) {
				return false;
			}
		}
		return true;
	}
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-09-19 20:21:18.377
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-09-19 20:21:18.379
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-09-19 20:21:19.588
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package p1Algoritmia;

import java.security.InvalidParameterException;
/**
 * Titulo: Clase Algorithms
 * 
 * @author Omar Teixeira
 * @version 10/09/2021
 */
public class Algorithms {
	/**
	 * Constante Sleep Time
	 */
	private static final long SLEEP_TIME = 1;
	
	/**
	 * Método doNothing
	 */
	public static void doNothing() {
		try {
			Thread.sleep(SLEEP_TIME);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}

	/**
	 * Método que calcula el factorial de un numero mayor o igual a cero de forma recursiva
	 * 
	 * @param n, numero a calcular el factorial
	 * @return factorial
	 */
	public long factorial (int n) { // Calcula el factorial de n>=0 de forma recursiva
		doNothing();
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);		
		
		if (n==0)
			return 1;
		else
			return n*factorial(n-1);		
	} 
	
	/**
	 * Método que calcula el numero que ocupa el n introducido en la sucesión de fibonacci
	 * 
	 * @param n, numero a calcular el fibonacci
	 * @return valor fibonacci
	 */
	public int fibonacci (int n) { // Calcula el termino n-esimo teniendo en cuenta que el primer término se considera fib(0)=0; y fib(1)=1		
		if (n<0)
		throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		
		if (n==0)
			return 0;
		else if (n==1)
			return 1;
		else
			return fibonacci(n-1)+fibonacci(n-2);		
	} 
	
	/**
	 * Método que calcula la potencia recursiva 1 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec1(int n) {  // calcula 2 elevado a n de forma recursiva 2^n = 2*2^(n-1)
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		
		if (n==0)
			return 1;
		else 
			return 2*pow2Rec1(n-1);				
	} 
	
	/**
	 * Método que calcula la potencia iterativa de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Iter (int n) {  // calcula 2 elevado a n de forma iterativa 
	    if (n<0)
	    	throw new InvalidParameterException("No permitidos exponentes negativos como "+ n); 
	    
	    long pow=2;
	    for (int i=0; i<=n;i++) {
	    	doNothing();
	    	pow=2*pow;
	    }	    
	    return pow; 
	} 

	/**
	 * Método que calcula la potencia recursiva 2 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec2 (int n) { // calcula 2 elevado a n de forma recursiva 2^n = 2^(n-1)+2^(n-1) 
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		if (n==0)
			return 1;
		else 
			return pow2Rec2(n-1) + pow2Rec2(n-1);
	} 
	
	/**
	 * Método que calcula la potencia recursiva 3 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec3 (int n) { // calcula 2 elevado a n de forma recursiva 2^n = 2^(n/2)*2^(n/2) si n par y *2 si es impar 
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		if (n==0)
			return 1;
		else if (n%2==0)
			return pow2Rec3(n/2)*pow2Rec3(n/2);
		else 
			return pow2Rec3(n/2)*pow2Rec3(n/2)*2; 
	} 
	
	/**
	 * Método que calcula la potencia recursiva 4 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec4 (int n) {  // calcula 2 elevado a n de forma recursiva 2^n = como pow2Rec3 pero sin repetir llamada 
		doNothing();
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		if (n==0) {
			return 1;
		} else { 
			if (n%2==0) {
				long res = pow2Rec4(n/2);
				return res*res;
			}
			else { 
				long res = pow2Rec4(n/2);
				return 2*res*res;
			}
		}	
		} 
	  
	/**
	 * Método que calcula la potencia de un numero a elevado al numero introducido b
	 * 
	 * @param a, base
	 * @param b, exponente
	 * @return potencia de la base elevada al exponente
	 */
	public long potenciaRec(int a, int b) { // Calcula a elevado a b de forma recursiva por potencias sucesivas 
		if (a<0 || b<0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido"); 
		
		if(a==1 || b==0)
			return 1;
		else			
			return a*potenciaRec(a,b-1);
		 
	}
	
	/**
	 * Método que calcula el resto de la división de dos numeros
	 * 
	 * @param a, dividendo
	 * @param b, divisor
	 * @return resto
	 */
	public int restoDivRec (int a, int b) {  // calcula el resto de la división a/b de forma recursiva 
		if (a<0 || b<=0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido");
		
		if (a<b)
			return a;
		else
			return restoDivRec(a-b,b);		
	} 
	
	/**
	 * Método que calcula la división entera de dos numeros
	 * 
	 * @param a, dividendo
	 * @param b, divisor
	 * @return division entera
	 */
	public int divEntRec (int a, int b) {  // calcula la división entera a/b de forma recursiva 
		if (a<0 || b<=0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido");		
		
		if (a<b)
			return 0;
		else
			return 1+divEntRec(a-b,b);		
	} 
	
	/**
	 * Método que invierte un numero entero de forma recursiva
	 * 
	 * @param n, numero a invertir
	 * @return numero invertido
	 */
	public int invertirEnteroRec(int n) {  // Invierte un entero invertirEnteroRec(1234)=4321 de forma recursiva
		if (n<10)
			return n;
		else			
			return (n%10) * (int)Math.pow(10, Integer.toString(n/10).length())+ invertirEnteroRec(n/10);
	} 

	/**
	 * Método que invierte un string de forma recursiva
	 * 
	 * @param l, string a invertir
	 * @return string invertido
	 */
	public String invertirStringRec(String l) { // Invierte un string de forma recursiva invertirStringRec("abc")="cba" 
		if (l.length()==1)
			return l;
		else
			return invertirStringRec(l.substring(1)) + l.charAt(0);
	}
	  
	/**
	 * Método que tiene una complejidad temporal lineal
	 * 
	 * @param n, parametro
	 */
	public void linear (int n) { // Algoritmo con una complejidad temporal lineal 
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		for (int i=0; i<=n; i++) {
			doNothing();
			System.out.println("El algoritmo se ha ejecutado: " + i + " vez/veces");
		}
	} 

	/**
	 * Método que tiene una complejidad temporal lineal
	 * 
	 * @param n, parametro
	 */
	public void quadratic(int n) { // Algoritmo con una complejidad temporal cuadrática 
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		for (int i=0; i<=n; i++) {
			for (int j=0; j<=n;j++) {
				doNothing();
				System.out.println("El algoritmo se ha ejecutado: " + j + " vez/veces");
			}
			System.out.println("--------"+i+"---------");
		}
	} 

	  

	public void cubic(int n) { // Algoritmo con una complejidad temporal cúbica 
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		for (int i=0; i<=n; i++) {
			for (int j=0; j<=n;j++) {
				for (int k=0; k<=n;k++) {
					doNothing();
					("El algoritmo se ha ejecutado: " + k + " vez/veces");
				}
				System.out.println("--------"+j+"---------");
			}
			System.out.println("~~~----"+j+"---------");
		}

	} 

	  

	public void logarithmic(int n) { // Algoritmo con una complejidad temporal logarítmica en cualquier base 

	if (n<0) 

	throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 

	} 	

	/**
	 * Método que comprueba si una matriz cuadrada es simetrica 
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	public boolean esSimetrica(int[][] m) { // Indica si es simétrica una matriz cuadrada de forma recursiva
		if (m.length == 1 && m[0].length == 1) {
			return true;
		} else if (!esCuadrada(m)) {
			return false;
		} else if (esIgualFilaColumna(m)){
			if (esSimetrica(eliminaFila(m))){
				return true;
			}			
		}
		return false;
	}
	
	/**
	 * Método que comprueba que la ultima fila es igual a la ultima columna
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	private boolean esIgualFilaColumna(int[][] m) {
		for (int i=0; i<m.length; i++) {
			if (m[m.length-1][i]!= m[i][m.length-1]) {
				return false;
			}
		}
		return true;
	}

	/**
	 * Método que elimina las filas de la matriz
	 * 
	 * @param m, matriz a la que eliminar las filas
	 * @return nueva matriz con las filas eliminadas
	 */
	private int[][] eliminaFila(int[][] m) {
		int [][] m2 = new int[m.length-1][m.length-1];		
		for (int i=0; i<m.length-1; i++) {
			for (int j=0; j<m.length-1; j++) {
				m2[i][j]=m[i][j];
			}
		}
		return m2;
	}
	
	/**
	 * Método que comprueba que una matriz es cuadrada
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	private boolean esCuadrada(int[][] m) {
		for (int i=0; i<m.length;i++) {
			if (m.length != m[i].length) {
				return false;
			}
		}
		return true;
	}
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-09-19 20:21:19.590
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-09-19 20:21:19.592
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-09-19 20:21:19.595
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package p1Algoritmia;

import java.security.InvalidParameterException;
/**
 * Titulo: Clase Algorithms
 * 
 * @author Omar Teixeira
 * @version 10/09/2021
 */
public class Algorithms {
	/**
	 * Constante Sleep Time
	 */
	private static final long SLEEP_TIME = 1;
	
	/**
	 * Método doNothing
	 */
	public static void doNothing() {
		try {
			Thread.sleep(SLEEP_TIME);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}

	/**
	 * Método que calcula el factorial de un numero mayor o igual a cero de forma recursiva
	 * 
	 * @param n, numero a calcular el factorial
	 * @return factorial
	 */
	public long factorial (int n) { // Calcula el factorial de n>=0 de forma recursiva
		doNothing();
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);		
		
		if (n==0)
			return 1;
		else
			return n*factorial(n-1);		
	} 
	
	/**
	 * Método que calcula el numero que ocupa el n introducido en la sucesión de fibonacci
	 * 
	 * @param n, numero a calcular el fibonacci
	 * @return valor fibonacci
	 */
	public int fibonacci (int n) { // Calcula el termino n-esimo teniendo en cuenta que el primer término se considera fib(0)=0; y fib(1)=1		
		if (n<0)
		throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		
		if (n==0)
			return 0;
		else if (n==1)
			return 1;
		else
			return fibonacci(n-1)+fibonacci(n-2);		
	} 
	
	/**
	 * Método que calcula la potencia recursiva 1 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec1(int n) {  // calcula 2 elevado a n de forma recursiva 2^n = 2*2^(n-1)
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		
		if (n==0)
			return 1;
		else 
			return 2*pow2Rec1(n-1);				
	} 
	
	/**
	 * Método que calcula la potencia iterativa de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Iter (int n) {  // calcula 2 elevado a n de forma iterativa 
	    if (n<0)
	    	throw new InvalidParameterException("No permitidos exponentes negativos como "+ n); 
	    
	    long pow=2;
	    for (int i=0; i<=n;i++) {
	    	doNothing();
	    	pow=2*pow;
	    }	    
	    return pow; 
	} 

	/**
	 * Método que calcula la potencia recursiva 2 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec2 (int n) { // calcula 2 elevado a n de forma recursiva 2^n = 2^(n-1)+2^(n-1) 
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		if (n==0)
			return 1;
		else 
			return pow2Rec2(n-1) + pow2Rec2(n-1);
	} 
	
	/**
	 * Método que calcula la potencia recursiva 3 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec3 (int n) { // calcula 2 elevado a n de forma recursiva 2^n = 2^(n/2)*2^(n/2) si n par y *2 si es impar 
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		if (n==0)
			return 1;
		else if (n%2==0)
			return pow2Rec3(n/2)*pow2Rec3(n/2);
		else 
			return pow2Rec3(n/2)*pow2Rec3(n/2)*2; 
	} 
	
	/**
	 * Método que calcula la potencia recursiva 4 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec4 (int n) {  // calcula 2 elevado a n de forma recursiva 2^n = como pow2Rec3 pero sin repetir llamada 
		doNothing();
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		if (n==0) {
			return 1;
		} else { 
			if (n%2==0) {
				long res = pow2Rec4(n/2);
				return res*res;
			}
			else { 
				long res = pow2Rec4(n/2);
				return 2*res*res;
			}
		}	
		} 
	  
	/**
	 * Método que calcula la potencia de un numero a elevado al numero introducido b
	 * 
	 * @param a, base
	 * @param b, exponente
	 * @return potencia de la base elevada al exponente
	 */
	public long potenciaRec(int a, int b) { // Calcula a elevado a b de forma recursiva por potencias sucesivas 
		if (a<0 || b<0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido"); 
		
		if(a==1 || b==0)
			return 1;
		else			
			return a*potenciaRec(a,b-1);
		 
	}
	
	/**
	 * Método que calcula el resto de la división de dos numeros
	 * 
	 * @param a, dividendo
	 * @param b, divisor
	 * @return resto
	 */
	public int restoDivRec (int a, int b) {  // calcula el resto de la división a/b de forma recursiva 
		if (a<0 || b<=0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido");
		
		if (a<b)
			return a;
		else
			return restoDivRec(a-b,b);		
	} 
	
	/**
	 * Método que calcula la división entera de dos numeros
	 * 
	 * @param a, dividendo
	 * @param b, divisor
	 * @return division entera
	 */
	public int divEntRec (int a, int b) {  // calcula la división entera a/b de forma recursiva 
		if (a<0 || b<=0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido");		
		
		if (a<b)
			return 0;
		else
			return 1+divEntRec(a-b,b);		
	} 
	
	/**
	 * Método que invierte un numero entero de forma recursiva
	 * 
	 * @param n, numero a invertir
	 * @return numero invertido
	 */
	public int invertirEnteroRec(int n) {  // Invierte un entero invertirEnteroRec(1234)=4321 de forma recursiva
		if (n<10)
			return n;
		else			
			return (n%10) * (int)Math.pow(10, Integer.toString(n/10).length())+ invertirEnteroRec(n/10);
	} 

	/**
	 * Método que invierte un string de forma recursiva
	 * 
	 * @param l, string a invertir
	 * @return string invertido
	 */
	public String invertirStringRec(String l) { // Invierte un string de forma recursiva invertirStringRec("abc")="cba" 
		if (l.length()==1)
			return l;
		else
			return invertirStringRec(l.substring(1)) + l.charAt(0);
	}
	  
	/**
	 * Método que tiene una complejidad temporal lineal
	 * 
	 * @param n, parametro
	 */
	public void linear (int n) { // Algoritmo con una complejidad temporal lineal 
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		for (int i=0; i<=n; i++) {
			doNothing();
			System.out.println("El algoritmo se ha ejecutado: " + i + " vez/veces");
		}
	} 

	/**
	 * Método que tiene una complejidad temporal lineal
	 * 
	 * @param n, parametro
	 */
	public void quadratic(int n) { // Algoritmo con una complejidad temporal cuadrática 
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		for (int i=0; i<=n; i++) {
			for (int j=0; j<=n;j++) {
				doNothing();
				System.out.println("El algoritmo se ha ejecutado: " + j + " vez/veces");
			}
			System.out.println("--------"+i+"---------");
		}
	} 

	  

	public void cubic(int n) { // Algoritmo con una complejidad temporal cúbica 
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		for (int i=0; i<=n; i++) {
			for (int j=0; j<=n;j++) {
				for (int k=0; k<=n;k++) {
					doNothing();
					("El algoritmo se ha ejecutado: " + k + " vez/veces");
				}
				System.out.println("--------"+j+"---------");
			}
			System.out.println("~~~----"+j+"---------");
		}

	} 

	  

	public void logarithmic(int n) { // Algoritmo con una complejidad temporal logarítmica en cualquier base 

	if (n<0) 

	throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 

	} 	

	/**
	 * Método que comprueba si una matriz cuadrada es simetrica 
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	public boolean esSimetrica(int[][] m) { // Indica si es simétrica una matriz cuadrada de forma recursiva
		if (m.length == 1 && m[0].length == 1) {
			return true;
		} else if (!esCuadrada(m)) {
			return false;
		} else if (esIgualFilaColumna(m)){
			if (esSimetrica(eliminaFila(m))){
				return true;
			}			
		}
		return false;
	}
	
	/**
	 * Método que comprueba que la ultima fila es igual a la ultima columna
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	private boolean esIgualFilaColumna(int[][] m) {
		for (int i=0; i<m.length; i++) {
			if (m[m.length-1][i]!= m[i][m.length-1]) {
				return false;
			}
		}
		return true;
	}

	/**
	 * Método que elimina las filas de la matriz
	 * 
	 * @param m, matriz a la que eliminar las filas
	 * @return nueva matriz con las filas eliminadas
	 */
	private int[][] eliminaFila(int[][] m) {
		int [][] m2 = new int[m.length-1][m.length-1];		
		for (int i=0; i<m.length-1; i++) {
			for (int j=0; j<m.length-1; j++) {
				m2[i][j]=m[i][j];
			}
		}
		return m2;
	}
	
	/**
	 * Método que comprueba que una matriz es cuadrada
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	private boolean esCuadrada(int[][] m) {
		for (int i=0; i<m.length;i++) {
			if (m.length != m[i].length) {
				return false;
			}
		}
		return true;
	}
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-09-19 20:21:19.596
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-09-19 20:21:19.597
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-09-19 20:21:21.096
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package p1Algoritmia;

import java.security.InvalidParameterException;
/**
 * Titulo: Clase Algorithms
 * 
 * @author Omar Teixeira
 * @version 10/09/2021
 */
public class Algorithms {
	/**
	 * Constante Sleep Time
	 */
	private static final long SLEEP_TIME = 1;
	
	/**
	 * Método doNothing
	 */
	public static void doNothing() {
		try {
			Thread.sleep(SLEEP_TIME);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}

	/**
	 * Método que calcula el factorial de un numero mayor o igual a cero de forma recursiva
	 * 
	 * @param n, numero a calcular el factorial
	 * @return factorial
	 */
	public long factorial (int n) { // Calcula el factorial de n>=0 de forma recursiva
		doNothing();
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);		
		
		if (n==0)
			return 1;
		else
			return n*factorial(n-1);		
	} 
	
	/**
	 * Método que calcula el numero que ocupa el n introducido en la sucesión de fibonacci
	 * 
	 * @param n, numero a calcular el fibonacci
	 * @return valor fibonacci
	 */
	public int fibonacci (int n) { // Calcula el termino n-esimo teniendo en cuenta que el primer término se considera fib(0)=0; y fib(1)=1		
		if (n<0)
		throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		
		if (n==0)
			return 0;
		else if (n==1)
			return 1;
		else
			return fibonacci(n-1)+fibonacci(n-2);		
	} 
	
	/**
	 * Método que calcula la potencia recursiva 1 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec1(int n) {  // calcula 2 elevado a n de forma recursiva 2^n = 2*2^(n-1)
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		
		if (n==0)
			return 1;
		else 
			return 2*pow2Rec1(n-1);				
	} 
	
	/**
	 * Método que calcula la potencia iterativa de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Iter (int n) {  // calcula 2 elevado a n de forma iterativa 
	    if (n<0)
	    	throw new InvalidParameterException("No permitidos exponentes negativos como "+ n); 
	    
	    long pow=2;
	    for (int i=0; i<=n;i++) {
	    	doNothing();
	    	pow=2*pow;
	    }	    
	    return pow; 
	} 

	/**
	 * Método que calcula la potencia recursiva 2 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec2 (int n) { // calcula 2 elevado a n de forma recursiva 2^n = 2^(n-1)+2^(n-1) 
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		if (n==0)
			return 1;
		else 
			return pow2Rec2(n-1) + pow2Rec2(n-1);
	} 
	
	/**
	 * Método que calcula la potencia recursiva 3 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec3 (int n) { // calcula 2 elevado a n de forma recursiva 2^n = 2^(n/2)*2^(n/2) si n par y *2 si es impar 
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		if (n==0)
			return 1;
		else if (n%2==0)
			return pow2Rec3(n/2)*pow2Rec3(n/2);
		else 
			return pow2Rec3(n/2)*pow2Rec3(n/2)*2; 
	} 
	
	/**
	 * Método que calcula la potencia recursiva 4 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec4 (int n) {  // calcula 2 elevado a n de forma recursiva 2^n = como pow2Rec3 pero sin repetir llamada 
		doNothing();
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		if (n==0) {
			return 1;
		} else { 
			if (n%2==0) {
				long res = pow2Rec4(n/2);
				return res*res;
			}
			else { 
				long res = pow2Rec4(n/2);
				return 2*res*res;
			}
		}	
		} 
	  
	/**
	 * Método que calcula la potencia de un numero a elevado al numero introducido b
	 * 
	 * @param a, base
	 * @param b, exponente
	 * @return potencia de la base elevada al exponente
	 */
	public long potenciaRec(int a, int b) { // Calcula a elevado a b de forma recursiva por potencias sucesivas 
		if (a<0 || b<0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido"); 
		
		if(a==1 || b==0)
			return 1;
		else			
			return a*potenciaRec(a,b-1);
		 
	}
	
	/**
	 * Método que calcula el resto de la división de dos numeros
	 * 
	 * @param a, dividendo
	 * @param b, divisor
	 * @return resto
	 */
	public int restoDivRec (int a, int b) {  // calcula el resto de la división a/b de forma recursiva 
		if (a<0 || b<=0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido");
		
		if (a<b)
			return a;
		else
			return restoDivRec(a-b,b);		
	} 
	
	/**
	 * Método que calcula la división entera de dos numeros
	 * 
	 * @param a, dividendo
	 * @param b, divisor
	 * @return division entera
	 */
	public int divEntRec (int a, int b) {  // calcula la división entera a/b de forma recursiva 
		if (a<0 || b<=0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido");		
		
		if (a<b)
			return 0;
		else
			return 1+divEntRec(a-b,b);		
	} 
	
	/**
	 * Método que invierte un numero entero de forma recursiva
	 * 
	 * @param n, numero a invertir
	 * @return numero invertido
	 */
	public int invertirEnteroRec(int n) {  // Invierte un entero invertirEnteroRec(1234)=4321 de forma recursiva
		if (n<10)
			return n;
		else			
			return (n%10) * (int)Math.pow(10, Integer.toString(n/10).length())+ invertirEnteroRec(n/10);
	} 

	/**
	 * Método que invierte un string de forma recursiva
	 * 
	 * @param l, string a invertir
	 * @return string invertido
	 */
	public String invertirStringRec(String l) { // Invierte un string de forma recursiva invertirStringRec("abc")="cba" 
		if (l.length()==1)
			return l;
		else
			return invertirStringRec(l.substring(1)) + l.charAt(0);
	}
	  
	/**
	 * Método que tiene una complejidad temporal lineal
	 * 
	 * @param n, parametro
	 */
	public void linear (int n) { // Algoritmo con una complejidad temporal lineal 
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		for (int i=0; i<=n; i++) {
			doNothing();
			System.out.println("El algoritmo se ha ejecutado: " + i + " vez/veces");
		}
	} 

	/**
	 * Método que tiene una complejidad temporal lineal
	 * 
	 * @param n, parametro
	 */
	public void quadratic(int n) { // Algoritmo con una complejidad temporal cuadrática 
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		for (int i=0; i<=n; i++) {
			for (int j=0; j<=n;j++) {
				doNothing();
				System.out.println("El algoritmo se ha ejecutado: " + j + " vez/veces");
			}
			System.out.println("--------"+i+"---------");
		}
	} 

	  

	public void cubic(int n) { // Algoritmo con una complejidad temporal cúbica 
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		for (int i=0; i<=n; i++) {
			for (int j=0; j<=n;j++) {
				for (int k=0; k<=n;k++) {
					doNothing();
					("El algoritmo se ha ejecutado: " + k + " vez/veces");
				}
				System.out.println("--------"+j+"---------");
			}
			System.out.println("~~~~~---"+j+"---------");
		}

	} 

	  

	public void logarithmic(int n) { // Algoritmo con una complejidad temporal logarítmica en cualquier base 

	if (n<0) 

	throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 

	} 	

	/**
	 * Método que comprueba si una matriz cuadrada es simetrica 
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	public boolean esSimetrica(int[][] m) { // Indica si es simétrica una matriz cuadrada de forma recursiva
		if (m.length == 1 && m[0].length == 1) {
			return true;
		} else if (!esCuadrada(m)) {
			return false;
		} else if (esIgualFilaColumna(m)){
			if (esSimetrica(eliminaFila(m))){
				return true;
			}			
		}
		return false;
	}
	
	/**
	 * Método que comprueba que la ultima fila es igual a la ultima columna
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	private boolean esIgualFilaColumna(int[][] m) {
		for (int i=0; i<m.length; i++) {
			if (m[m.length-1][i]!= m[i][m.length-1]) {
				return false;
			}
		}
		return true;
	}

	/**
	 * Método que elimina las filas de la matriz
	 * 
	 * @param m, matriz a la que eliminar las filas
	 * @return nueva matriz con las filas eliminadas
	 */
	private int[][] eliminaFila(int[][] m) {
		int [][] m2 = new int[m.length-1][m.length-1];		
		for (int i=0; i<m.length-1; i++) {
			for (int j=0; j<m.length-1; j++) {
				m2[i][j]=m[i][j];
			}
		}
		return m2;
	}
	
	/**
	 * Método que comprueba que una matriz es cuadrada
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	private boolean esCuadrada(int[][] m) {
		for (int i=0; i<m.length;i++) {
			if (m.length != m[i].length) {
				return false;
			}
		}
		return true;
	}
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-09-19 20:21:21.098
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-09-19 20:21:21.099
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-09-19 20:21:21.103
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package p1Algoritmia;

import java.security.InvalidParameterException;
/**
 * Titulo: Clase Algorithms
 * 
 * @author Omar Teixeira
 * @version 10/09/2021
 */
public class Algorithms {
	/**
	 * Constante Sleep Time
	 */
	private static final long SLEEP_TIME = 1;
	
	/**
	 * Método doNothing
	 */
	public static void doNothing() {
		try {
			Thread.sleep(SLEEP_TIME);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}

	/**
	 * Método que calcula el factorial de un numero mayor o igual a cero de forma recursiva
	 * 
	 * @param n, numero a calcular el factorial
	 * @return factorial
	 */
	public long factorial (int n) { // Calcula el factorial de n>=0 de forma recursiva
		doNothing();
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);		
		
		if (n==0)
			return 1;
		else
			return n*factorial(n-1);		
	} 
	
	/**
	 * Método que calcula el numero que ocupa el n introducido en la sucesión de fibonacci
	 * 
	 * @param n, numero a calcular el fibonacci
	 * @return valor fibonacci
	 */
	public int fibonacci (int n) { // Calcula el termino n-esimo teniendo en cuenta que el primer término se considera fib(0)=0; y fib(1)=1		
		if (n<0)
		throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		
		if (n==0)
			return 0;
		else if (n==1)
			return 1;
		else
			return fibonacci(n-1)+fibonacci(n-2);		
	} 
	
	/**
	 * Método que calcula la potencia recursiva 1 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec1(int n) {  // calcula 2 elevado a n de forma recursiva 2^n = 2*2^(n-1)
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		
		if (n==0)
			return 1;
		else 
			return 2*pow2Rec1(n-1);				
	} 
	
	/**
	 * Método que calcula la potencia iterativa de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Iter (int n) {  // calcula 2 elevado a n de forma iterativa 
	    if (n<0)
	    	throw new InvalidParameterException("No permitidos exponentes negativos como "+ n); 
	    
	    long pow=2;
	    for (int i=0; i<=n;i++) {
	    	doNothing();
	    	pow=2*pow;
	    }	    
	    return pow; 
	} 

	/**
	 * Método que calcula la potencia recursiva 2 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec2 (int n) { // calcula 2 elevado a n de forma recursiva 2^n = 2^(n-1)+2^(n-1) 
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		if (n==0)
			return 1;
		else 
			return pow2Rec2(n-1) + pow2Rec2(n-1);
	} 
	
	/**
	 * Método que calcula la potencia recursiva 3 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec3 (int n) { // calcula 2 elevado a n de forma recursiva 2^n = 2^(n/2)*2^(n/2) si n par y *2 si es impar 
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		if (n==0)
			return 1;
		else if (n%2==0)
			return pow2Rec3(n/2)*pow2Rec3(n/2);
		else 
			return pow2Rec3(n/2)*pow2Rec3(n/2)*2; 
	} 
	
	/**
	 * Método que calcula la potencia recursiva 4 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec4 (int n) {  // calcula 2 elevado a n de forma recursiva 2^n = como pow2Rec3 pero sin repetir llamada 
		doNothing();
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		if (n==0) {
			return 1;
		} else { 
			if (n%2==0) {
				long res = pow2Rec4(n/2);
				return res*res;
			}
			else { 
				long res = pow2Rec4(n/2);
				return 2*res*res;
			}
		}	
		} 
	  
	/**
	 * Método que calcula la potencia de un numero a elevado al numero introducido b
	 * 
	 * @param a, base
	 * @param b, exponente
	 * @return potencia de la base elevada al exponente
	 */
	public long potenciaRec(int a, int b) { // Calcula a elevado a b de forma recursiva por potencias sucesivas 
		if (a<0 || b<0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido"); 
		
		if(a==1 || b==0)
			return 1;
		else			
			return a*potenciaRec(a,b-1);
		 
	}
	
	/**
	 * Método que calcula el resto de la división de dos numeros
	 * 
	 * @param a, dividendo
	 * @param b, divisor
	 * @return resto
	 */
	public int restoDivRec (int a, int b) {  // calcula el resto de la división a/b de forma recursiva 
		if (a<0 || b<=0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido");
		
		if (a<b)
			return a;
		else
			return restoDivRec(a-b,b);		
	} 
	
	/**
	 * Método que calcula la división entera de dos numeros
	 * 
	 * @param a, dividendo
	 * @param b, divisor
	 * @return division entera
	 */
	public int divEntRec (int a, int b) {  // calcula la división entera a/b de forma recursiva 
		if (a<0 || b<=0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido");		
		
		if (a<b)
			return 0;
		else
			return 1+divEntRec(a-b,b);		
	} 
	
	/**
	 * Método que invierte un numero entero de forma recursiva
	 * 
	 * @param n, numero a invertir
	 * @return numero invertido
	 */
	public int invertirEnteroRec(int n) {  // Invierte un entero invertirEnteroRec(1234)=4321 de forma recursiva
		if (n<10)
			return n;
		else			
			return (n%10) * (int)Math.pow(10, Integer.toString(n/10).length())+ invertirEnteroRec(n/10);
	} 

	/**
	 * Método que invierte un string de forma recursiva
	 * 
	 * @param l, string a invertir
	 * @return string invertido
	 */
	public String invertirStringRec(String l) { // Invierte un string de forma recursiva invertirStringRec("abc")="cba" 
		if (l.length()==1)
			return l;
		else
			return invertirStringRec(l.substring(1)) + l.charAt(0);
	}
	  
	/**
	 * Método que tiene una complejidad temporal lineal
	 * 
	 * @param n, parametro
	 */
	public void linear (int n) { // Algoritmo con una complejidad temporal lineal 
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		for (int i=0; i<=n; i++) {
			doNothing();
			System.out.println("El algoritmo se ha ejecutado: " + i + " vez/veces");
		}
	} 

	/**
	 * Método que tiene una complejidad temporal lineal
	 * 
	 * @param n, parametro
	 */
	public void quadratic(int n) { // Algoritmo con una complejidad temporal cuadrática 
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		for (int i=0; i<=n; i++) {
			for (int j=0; j<=n;j++) {
				doNothing();
				System.out.println("El algoritmo se ha ejecutado: " + j + " vez/veces");
			}
			System.out.println("--------"+i+"---------");
		}
	} 

	  

	public void cubic(int n) { // Algoritmo con una complejidad temporal cúbica 
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		for (int i=0; i<=n; i++) {
			for (int j=0; j<=n;j++) {
				for (int k=0; k<=n;k++) {
					doNothing();
					("El algoritmo se ha ejecutado: " + k + " vez/veces");
				}
				System.out.println("--------"+j+"---------");
			}
			System.out.println("~~~~~---"+j+"---------");
		}

	} 

	  

	public void logarithmic(int n) { // Algoritmo con una complejidad temporal logarítmica en cualquier base 

	if (n<0) 

	throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 

	} 	

	/**
	 * Método que comprueba si una matriz cuadrada es simetrica 
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	public boolean esSimetrica(int[][] m) { // Indica si es simétrica una matriz cuadrada de forma recursiva
		if (m.length == 1 && m[0].length == 1) {
			return true;
		} else if (!esCuadrada(m)) {
			return false;
		} else if (esIgualFilaColumna(m)){
			if (esSimetrica(eliminaFila(m))){
				return true;
			}			
		}
		return false;
	}
	
	/**
	 * Método que comprueba que la ultima fila es igual a la ultima columna
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	private boolean esIgualFilaColumna(int[][] m) {
		for (int i=0; i<m.length; i++) {
			if (m[m.length-1][i]!= m[i][m.length-1]) {
				return false;
			}
		}
		return true;
	}

	/**
	 * Método que elimina las filas de la matriz
	 * 
	 * @param m, matriz a la que eliminar las filas
	 * @return nueva matriz con las filas eliminadas
	 */
	private int[][] eliminaFila(int[][] m) {
		int [][] m2 = new int[m.length-1][m.length-1];		
		for (int i=0; i<m.length-1; i++) {
			for (int j=0; j<m.length-1; j++) {
				m2[i][j]=m[i][j];
			}
		}
		return m2;
	}
	
	/**
	 * Método que comprueba que una matriz es cuadrada
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	private boolean esCuadrada(int[][] m) {
		for (int i=0; i<m.length;i++) {
			if (m.length != m[i].length) {
				return false;
			}
		}
		return true;
	}
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-09-19 20:21:21.105
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-09-19 20:21:21.106
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-09-19 20:21:23.104
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package p1Algoritmia;

import java.security.InvalidParameterException;
/**
 * Titulo: Clase Algorithms
 * 
 * @author Omar Teixeira
 * @version 10/09/2021
 */
public class Algorithms {
	/**
	 * Constante Sleep Time
	 */
	private static final long SLEEP_TIME = 1;
	
	/**
	 * Método doNothing
	 */
	public static void doNothing() {
		try {
			Thread.sleep(SLEEP_TIME);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}

	/**
	 * Método que calcula el factorial de un numero mayor o igual a cero de forma recursiva
	 * 
	 * @param n, numero a calcular el factorial
	 * @return factorial
	 */
	public long factorial (int n) { // Calcula el factorial de n>=0 de forma recursiva
		doNothing();
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);		
		
		if (n==0)
			return 1;
		else
			return n*factorial(n-1);		
	} 
	
	/**
	 * Método que calcula el numero que ocupa el n introducido en la sucesión de fibonacci
	 * 
	 * @param n, numero a calcular el fibonacci
	 * @return valor fibonacci
	 */
	public int fibonacci (int n) { // Calcula el termino n-esimo teniendo en cuenta que el primer término se considera fib(0)=0; y fib(1)=1		
		if (n<0)
		throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		
		if (n==0)
			return 0;
		else if (n==1)
			return 1;
		else
			return fibonacci(n-1)+fibonacci(n-2);		
	} 
	
	/**
	 * Método que calcula la potencia recursiva 1 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec1(int n) {  // calcula 2 elevado a n de forma recursiva 2^n = 2*2^(n-1)
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		
		if (n==0)
			return 1;
		else 
			return 2*pow2Rec1(n-1);				
	} 
	
	/**
	 * Método que calcula la potencia iterativa de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Iter (int n) {  // calcula 2 elevado a n de forma iterativa 
	    if (n<0)
	    	throw new InvalidParameterException("No permitidos exponentes negativos como "+ n); 
	    
	    long pow=2;
	    for (int i=0; i<=n;i++) {
	    	doNothing();
	    	pow=2*pow;
	    }	    
	    return pow; 
	} 

	/**
	 * Método que calcula la potencia recursiva 2 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec2 (int n) { // calcula 2 elevado a n de forma recursiva 2^n = 2^(n-1)+2^(n-1) 
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		if (n==0)
			return 1;
		else 
			return pow2Rec2(n-1) + pow2Rec2(n-1);
	} 
	
	/**
	 * Método que calcula la potencia recursiva 3 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec3 (int n) { // calcula 2 elevado a n de forma recursiva 2^n = 2^(n/2)*2^(n/2) si n par y *2 si es impar 
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		if (n==0)
			return 1;
		else if (n%2==0)
			return pow2Rec3(n/2)*pow2Rec3(n/2);
		else 
			return pow2Rec3(n/2)*pow2Rec3(n/2)*2; 
	} 
	
	/**
	 * Método que calcula la potencia recursiva 4 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec4 (int n) {  // calcula 2 elevado a n de forma recursiva 2^n = como pow2Rec3 pero sin repetir llamada 
		doNothing();
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		if (n==0) {
			return 1;
		} else { 
			if (n%2==0) {
				long res = pow2Rec4(n/2);
				return res*res;
			}
			else { 
				long res = pow2Rec4(n/2);
				return 2*res*res;
			}
		}	
		} 
	  
	/**
	 * Método que calcula la potencia de un numero a elevado al numero introducido b
	 * 
	 * @param a, base
	 * @param b, exponente
	 * @return potencia de la base elevada al exponente
	 */
	public long potenciaRec(int a, int b) { // Calcula a elevado a b de forma recursiva por potencias sucesivas 
		if (a<0 || b<0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido"); 
		
		if(a==1 || b==0)
			return 1;
		else			
			return a*potenciaRec(a,b-1);
		 
	}
	
	/**
	 * Método que calcula el resto de la división de dos numeros
	 * 
	 * @param a, dividendo
	 * @param b, divisor
	 * @return resto
	 */
	public int restoDivRec (int a, int b) {  // calcula el resto de la división a/b de forma recursiva 
		if (a<0 || b<=0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido");
		
		if (a<b)
			return a;
		else
			return restoDivRec(a-b,b);		
	} 
	
	/**
	 * Método que calcula la división entera de dos numeros
	 * 
	 * @param a, dividendo
	 * @param b, divisor
	 * @return division entera
	 */
	public int divEntRec (int a, int b) {  // calcula la división entera a/b de forma recursiva 
		if (a<0 || b<=0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido");		
		
		if (a<b)
			return 0;
		else
			return 1+divEntRec(a-b,b);		
	} 
	
	/**
	 * Método que invierte un numero entero de forma recursiva
	 * 
	 * @param n, numero a invertir
	 * @return numero invertido
	 */
	public int invertirEnteroRec(int n) {  // Invierte un entero invertirEnteroRec(1234)=4321 de forma recursiva
		if (n<10)
			return n;
		else			
			return (n%10) * (int)Math.pow(10, Integer.toString(n/10).length())+ invertirEnteroRec(n/10);
	} 

	/**
	 * Método que invierte un string de forma recursiva
	 * 
	 * @param l, string a invertir
	 * @return string invertido
	 */
	public String invertirStringRec(String l) { // Invierte un string de forma recursiva invertirStringRec("abc")="cba" 
		if (l.length()==1)
			return l;
		else
			return invertirStringRec(l.substring(1)) + l.charAt(0);
	}
	  
	/**
	 * Método que tiene una complejidad temporal lineal
	 * 
	 * @param n, parametro
	 */
	public void linear (int n) { // Algoritmo con una complejidad temporal lineal 
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		for (int i=0; i<=n; i++) {
			doNothing();
			System.out.println("El algoritmo se ha ejecutado: " + i + " vez/veces");
		}
	} 

	/**
	 * Método que tiene una complejidad temporal lineal
	 * 
	 * @param n, parametro
	 */
	public void quadratic(int n) { // Algoritmo con una complejidad temporal cuadrática 
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		for (int i=0; i<=n; i++) {
			for (int j=0; j<=n;j++) {
				doNothing();
				System.out.println("El algoritmo se ha ejecutado: " + j + " vez/veces");
			}
			System.out.println("--------"+i+"---------");
		}
	} 

	  

	public void cubic(int n) { // Algoritmo con una complejidad temporal cúbica 
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		for (int i=0; i<=n; i++) {
			for (int j=0; j<=n;j++) {
				for (int k=0; k<=n;k++) {
					doNothing();
					("El algoritmo se ha ejecutado: " + k + " vez/veces");
				}
				System.out.println("--------"+j+"---------");
			}
			System.out.println("~~~~~~~--"+j+"---------");
		}

	} 

	  

	public void logarithmic(int n) { // Algoritmo con una complejidad temporal logarítmica en cualquier base 

	if (n<0) 

	throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 

	} 	

	/**
	 * Método que comprueba si una matriz cuadrada es simetrica 
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	public boolean esSimetrica(int[][] m) { // Indica si es simétrica una matriz cuadrada de forma recursiva
		if (m.length == 1 && m[0].length == 1) {
			return true;
		} else if (!esCuadrada(m)) {
			return false;
		} else if (esIgualFilaColumna(m)){
			if (esSimetrica(eliminaFila(m))){
				return true;
			}			
		}
		return false;
	}
	
	/**
	 * Método que comprueba que la ultima fila es igual a la ultima columna
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	private boolean esIgualFilaColumna(int[][] m) {
		for (int i=0; i<m.length; i++) {
			if (m[m.length-1][i]!= m[i][m.length-1]) {
				return false;
			}
		}
		return true;
	}

	/**
	 * Método que elimina las filas de la matriz
	 * 
	 * @param m, matriz a la que eliminar las filas
	 * @return nueva matriz con las filas eliminadas
	 */
	private int[][] eliminaFila(int[][] m) {
		int [][] m2 = new int[m.length-1][m.length-1];		
		for (int i=0; i<m.length-1; i++) {
			for (int j=0; j<m.length-1; j++) {
				m2[i][j]=m[i][j];
			}
		}
		return m2;
	}
	
	/**
	 * Método que comprueba que una matriz es cuadrada
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	private boolean esCuadrada(int[][] m) {
		for (int i=0; i<m.length;i++) {
			if (m.length != m[i].length) {
				return false;
			}
		}
		return true;
	}
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-09-19 20:21:23.106
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-09-19 20:21:23.107
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-09-19 20:21:23.110
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package p1Algoritmia;

import java.security.InvalidParameterException;
/**
 * Titulo: Clase Algorithms
 * 
 * @author Omar Teixeira
 * @version 10/09/2021
 */
public class Algorithms {
	/**
	 * Constante Sleep Time
	 */
	private static final long SLEEP_TIME = 1;
	
	/**
	 * Método doNothing
	 */
	public static void doNothing() {
		try {
			Thread.sleep(SLEEP_TIME);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}

	/**
	 * Método que calcula el factorial de un numero mayor o igual a cero de forma recursiva
	 * 
	 * @param n, numero a calcular el factorial
	 * @return factorial
	 */
	public long factorial (int n) { // Calcula el factorial de n>=0 de forma recursiva
		doNothing();
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);		
		
		if (n==0)
			return 1;
		else
			return n*factorial(n-1);		
	} 
	
	/**
	 * Método que calcula el numero que ocupa el n introducido en la sucesión de fibonacci
	 * 
	 * @param n, numero a calcular el fibonacci
	 * @return valor fibonacci
	 */
	public int fibonacci (int n) { // Calcula el termino n-esimo teniendo en cuenta que el primer término se considera fib(0)=0; y fib(1)=1		
		if (n<0)
		throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		
		if (n==0)
			return 0;
		else if (n==1)
			return 1;
		else
			return fibonacci(n-1)+fibonacci(n-2);		
	} 
	
	/**
	 * Método que calcula la potencia recursiva 1 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec1(int n) {  // calcula 2 elevado a n de forma recursiva 2^n = 2*2^(n-1)
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		
		if (n==0)
			return 1;
		else 
			return 2*pow2Rec1(n-1);				
	} 
	
	/**
	 * Método que calcula la potencia iterativa de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Iter (int n) {  // calcula 2 elevado a n de forma iterativa 
	    if (n<0)
	    	throw new InvalidParameterException("No permitidos exponentes negativos como "+ n); 
	    
	    long pow=2;
	    for (int i=0; i<=n;i++) {
	    	doNothing();
	    	pow=2*pow;
	    }	    
	    return pow; 
	} 

	/**
	 * Método que calcula la potencia recursiva 2 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec2 (int n) { // calcula 2 elevado a n de forma recursiva 2^n = 2^(n-1)+2^(n-1) 
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		if (n==0)
			return 1;
		else 
			return pow2Rec2(n-1) + pow2Rec2(n-1);
	} 
	
	/**
	 * Método que calcula la potencia recursiva 3 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec3 (int n) { // calcula 2 elevado a n de forma recursiva 2^n = 2^(n/2)*2^(n/2) si n par y *2 si es impar 
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		if (n==0)
			return 1;
		else if (n%2==0)
			return pow2Rec3(n/2)*pow2Rec3(n/2);
		else 
			return pow2Rec3(n/2)*pow2Rec3(n/2)*2; 
	} 
	
	/**
	 * Método que calcula la potencia recursiva 4 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec4 (int n) {  // calcula 2 elevado a n de forma recursiva 2^n = como pow2Rec3 pero sin repetir llamada 
		doNothing();
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		if (n==0) {
			return 1;
		} else { 
			if (n%2==0) {
				long res = pow2Rec4(n/2);
				return res*res;
			}
			else { 
				long res = pow2Rec4(n/2);
				return 2*res*res;
			}
		}	
		} 
	  
	/**
	 * Método que calcula la potencia de un numero a elevado al numero introducido b
	 * 
	 * @param a, base
	 * @param b, exponente
	 * @return potencia de la base elevada al exponente
	 */
	public long potenciaRec(int a, int b) { // Calcula a elevado a b de forma recursiva por potencias sucesivas 
		if (a<0 || b<0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido"); 
		
		if(a==1 || b==0)
			return 1;
		else			
			return a*potenciaRec(a,b-1);
		 
	}
	
	/**
	 * Método que calcula el resto de la división de dos numeros
	 * 
	 * @param a, dividendo
	 * @param b, divisor
	 * @return resto
	 */
	public int restoDivRec (int a, int b) {  // calcula el resto de la división a/b de forma recursiva 
		if (a<0 || b<=0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido");
		
		if (a<b)
			return a;
		else
			return restoDivRec(a-b,b);		
	} 
	
	/**
	 * Método que calcula la división entera de dos numeros
	 * 
	 * @param a, dividendo
	 * @param b, divisor
	 * @return division entera
	 */
	public int divEntRec (int a, int b) {  // calcula la división entera a/b de forma recursiva 
		if (a<0 || b<=0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido");		
		
		if (a<b)
			return 0;
		else
			return 1+divEntRec(a-b,b);		
	} 
	
	/**
	 * Método que invierte un numero entero de forma recursiva
	 * 
	 * @param n, numero a invertir
	 * @return numero invertido
	 */
	public int invertirEnteroRec(int n) {  // Invierte un entero invertirEnteroRec(1234)=4321 de forma recursiva
		if (n<10)
			return n;
		else			
			return (n%10) * (int)Math.pow(10, Integer.toString(n/10).length())+ invertirEnteroRec(n/10);
	} 

	/**
	 * Método que invierte un string de forma recursiva
	 * 
	 * @param l, string a invertir
	 * @return string invertido
	 */
	public String invertirStringRec(String l) { // Invierte un string de forma recursiva invertirStringRec("abc")="cba" 
		if (l.length()==1)
			return l;
		else
			return invertirStringRec(l.substring(1)) + l.charAt(0);
	}
	  
	/**
	 * Método que tiene una complejidad temporal lineal
	 * 
	 * @param n, parametro
	 */
	public void linear (int n) { // Algoritmo con una complejidad temporal lineal 
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		for (int i=0; i<=n; i++) {
			doNothing();
			System.out.println("El algoritmo se ha ejecutado: " + i + " vez/veces");
		}
	} 

	/**
	 * Método que tiene una complejidad temporal lineal
	 * 
	 * @param n, parametro
	 */
	public void quadratic(int n) { // Algoritmo con una complejidad temporal cuadrática 
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		for (int i=0; i<=n; i++) {
			for (int j=0; j<=n;j++) {
				doNothing();
				System.out.println("El algoritmo se ha ejecutado: " + j + " vez/veces");
			}
			System.out.println("--------"+i+"---------");
		}
	} 

	  

	public void cubic(int n) { // Algoritmo con una complejidad temporal cúbica 
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		for (int i=0; i<=n; i++) {
			for (int j=0; j<=n;j++) {
				for (int k=0; k<=n;k++) {
					doNothing();
					("El algoritmo se ha ejecutado: " + k + " vez/veces");
				}
				System.out.println("--------"+j+"---------");
			}
			System.out.println("~~~~~~~--"+j+"---------");
		}

	} 

	  

	public void logarithmic(int n) { // Algoritmo con una complejidad temporal logarítmica en cualquier base 

	if (n<0) 

	throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 

	} 	

	/**
	 * Método que comprueba si una matriz cuadrada es simetrica 
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	public boolean esSimetrica(int[][] m) { // Indica si es simétrica una matriz cuadrada de forma recursiva
		if (m.length == 1 && m[0].length == 1) {
			return true;
		} else if (!esCuadrada(m)) {
			return false;
		} else if (esIgualFilaColumna(m)){
			if (esSimetrica(eliminaFila(m))){
				return true;
			}			
		}
		return false;
	}
	
	/**
	 * Método que comprueba que la ultima fila es igual a la ultima columna
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	private boolean esIgualFilaColumna(int[][] m) {
		for (int i=0; i<m.length; i++) {
			if (m[m.length-1][i]!= m[i][m.length-1]) {
				return false;
			}
		}
		return true;
	}

	/**
	 * Método que elimina las filas de la matriz
	 * 
	 * @param m, matriz a la que eliminar las filas
	 * @return nueva matriz con las filas eliminadas
	 */
	private int[][] eliminaFila(int[][] m) {
		int [][] m2 = new int[m.length-1][m.length-1];		
		for (int i=0; i<m.length-1; i++) {
			for (int j=0; j<m.length-1; j++) {
				m2[i][j]=m[i][j];
			}
		}
		return m2;
	}
	
	/**
	 * Método que comprueba que una matriz es cuadrada
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	private boolean esCuadrada(int[][] m) {
		for (int i=0; i<m.length;i++) {
			if (m.length != m[i].length) {
				return false;
			}
		}
		return true;
	}
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-09-19 20:21:23.111
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-09-19 20:21:23.113
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-09-19 20:21:24.112
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package p1Algoritmia;

import java.security.InvalidParameterException;
/**
 * Titulo: Clase Algorithms
 * 
 * @author Omar Teixeira
 * @version 10/09/2021
 */
public class Algorithms {
	/**
	 * Constante Sleep Time
	 */
	private static final long SLEEP_TIME = 1;
	
	/**
	 * Método doNothing
	 */
	public static void doNothing() {
		try {
			Thread.sleep(SLEEP_TIME);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}

	/**
	 * Método que calcula el factorial de un numero mayor o igual a cero de forma recursiva
	 * 
	 * @param n, numero a calcular el factorial
	 * @return factorial
	 */
	public long factorial (int n) { // Calcula el factorial de n>=0 de forma recursiva
		doNothing();
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);		
		
		if (n==0)
			return 1;
		else
			return n*factorial(n-1);		
	} 
	
	/**
	 * Método que calcula el numero que ocupa el n introducido en la sucesión de fibonacci
	 * 
	 * @param n, numero a calcular el fibonacci
	 * @return valor fibonacci
	 */
	public int fibonacci (int n) { // Calcula el termino n-esimo teniendo en cuenta que el primer término se considera fib(0)=0; y fib(1)=1		
		if (n<0)
		throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		
		if (n==0)
			return 0;
		else if (n==1)
			return 1;
		else
			return fibonacci(n-1)+fibonacci(n-2);		
	} 
	
	/**
	 * Método que calcula la potencia recursiva 1 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec1(int n) {  // calcula 2 elevado a n de forma recursiva 2^n = 2*2^(n-1)
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		
		if (n==0)
			return 1;
		else 
			return 2*pow2Rec1(n-1);				
	} 
	
	/**
	 * Método que calcula la potencia iterativa de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Iter (int n) {  // calcula 2 elevado a n de forma iterativa 
	    if (n<0)
	    	throw new InvalidParameterException("No permitidos exponentes negativos como "+ n); 
	    
	    long pow=2;
	    for (int i=0; i<=n;i++) {
	    	doNothing();
	    	pow=2*pow;
	    }	    
	    return pow; 
	} 

	/**
	 * Método que calcula la potencia recursiva 2 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec2 (int n) { // calcula 2 elevado a n de forma recursiva 2^n = 2^(n-1)+2^(n-1) 
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		if (n==0)
			return 1;
		else 
			return pow2Rec2(n-1) + pow2Rec2(n-1);
	} 
	
	/**
	 * Método que calcula la potencia recursiva 3 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec3 (int n) { // calcula 2 elevado a n de forma recursiva 2^n = 2^(n/2)*2^(n/2) si n par y *2 si es impar 
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		if (n==0)
			return 1;
		else if (n%2==0)
			return pow2Rec3(n/2)*pow2Rec3(n/2);
		else 
			return pow2Rec3(n/2)*pow2Rec3(n/2)*2; 
	} 
	
	/**
	 * Método que calcula la potencia recursiva 4 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec4 (int n) {  // calcula 2 elevado a n de forma recursiva 2^n = como pow2Rec3 pero sin repetir llamada 
		doNothing();
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		if (n==0) {
			return 1;
		} else { 
			if (n%2==0) {
				long res = pow2Rec4(n/2);
				return res*res;
			}
			else { 
				long res = pow2Rec4(n/2);
				return 2*res*res;
			}
		}	
		} 
	  
	/**
	 * Método que calcula la potencia de un numero a elevado al numero introducido b
	 * 
	 * @param a, base
	 * @param b, exponente
	 * @return potencia de la base elevada al exponente
	 */
	public long potenciaRec(int a, int b) { // Calcula a elevado a b de forma recursiva por potencias sucesivas 
		if (a<0 || b<0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido"); 
		
		if(a==1 || b==0)
			return 1;
		else			
			return a*potenciaRec(a,b-1);
		 
	}
	
	/**
	 * Método que calcula el resto de la división de dos numeros
	 * 
	 * @param a, dividendo
	 * @param b, divisor
	 * @return resto
	 */
	public int restoDivRec (int a, int b) {  // calcula el resto de la división a/b de forma recursiva 
		if (a<0 || b<=0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido");
		
		if (a<b)
			return a;
		else
			return restoDivRec(a-b,b);		
	} 
	
	/**
	 * Método que calcula la división entera de dos numeros
	 * 
	 * @param a, dividendo
	 * @param b, divisor
	 * @return division entera
	 */
	public int divEntRec (int a, int b) {  // calcula la división entera a/b de forma recursiva 
		if (a<0 || b<=0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido");		
		
		if (a<b)
			return 0;
		else
			return 1+divEntRec(a-b,b);		
	} 
	
	/**
	 * Método que invierte un numero entero de forma recursiva
	 * 
	 * @param n, numero a invertir
	 * @return numero invertido
	 */
	public int invertirEnteroRec(int n) {  // Invierte un entero invertirEnteroRec(1234)=4321 de forma recursiva
		if (n<10)
			return n;
		else			
			return (n%10) * (int)Math.pow(10, Integer.toString(n/10).length())+ invertirEnteroRec(n/10);
	} 

	/**
	 * Método que invierte un string de forma recursiva
	 * 
	 * @param l, string a invertir
	 * @return string invertido
	 */
	public String invertirStringRec(String l) { // Invierte un string de forma recursiva invertirStringRec("abc")="cba" 
		if (l.length()==1)
			return l;
		else
			return invertirStringRec(l.substring(1)) + l.charAt(0);
	}
	  
	/**
	 * Método que tiene una complejidad temporal lineal
	 * 
	 * @param n, parametro
	 */
	public void linear (int n) { // Algoritmo con una complejidad temporal lineal 
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		for (int i=0; i<=n; i++) {
			doNothing();
			System.out.println("El algoritmo se ha ejecutado: " + i + " vez/veces");
		}
	} 

	/**
	 * Método que tiene una complejidad temporal lineal
	 * 
	 * @param n, parametro
	 */
	public void quadratic(int n) { // Algoritmo con una complejidad temporal cuadrática 
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		for (int i=0; i<=n; i++) {
			for (int j=0; j<=n;j++) {
				doNothing();
				System.out.println("El algoritmo se ha ejecutado: " + j + " vez/veces");
			}
			System.out.println("--------"+i+"---------");
		}
	} 

	  

	public void cubic(int n) { // Algoritmo con una complejidad temporal cúbica 
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		for (int i=0; i<=n; i++) {
			for (int j=0; j<=n;j++) {
				for (int k=0; k<=n;k++) {
					doNothing();
					("El algoritmo se ha ejecutado: " + k + " vez/veces");
				}
				System.out.println("--------"+j+"---------");
			}
			System.out.println("~~~~~~~-"+j+"---------");
		}

	} 

	  

	public void logarithmic(int n) { // Algoritmo con una complejidad temporal logarítmica en cualquier base 

	if (n<0) 

	throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 

	} 	

	/**
	 * Método que comprueba si una matriz cuadrada es simetrica 
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	public boolean esSimetrica(int[][] m) { // Indica si es simétrica una matriz cuadrada de forma recursiva
		if (m.length == 1 && m[0].length == 1) {
			return true;
		} else if (!esCuadrada(m)) {
			return false;
		} else if (esIgualFilaColumna(m)){
			if (esSimetrica(eliminaFila(m))){
				return true;
			}			
		}
		return false;
	}
	
	/**
	 * Método que comprueba que la ultima fila es igual a la ultima columna
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	private boolean esIgualFilaColumna(int[][] m) {
		for (int i=0; i<m.length; i++) {
			if (m[m.length-1][i]!= m[i][m.length-1]) {
				return false;
			}
		}
		return true;
	}

	/**
	 * Método que elimina las filas de la matriz
	 * 
	 * @param m, matriz a la que eliminar las filas
	 * @return nueva matriz con las filas eliminadas
	 */
	private int[][] eliminaFila(int[][] m) {
		int [][] m2 = new int[m.length-1][m.length-1];		
		for (int i=0; i<m.length-1; i++) {
			for (int j=0; j<m.length-1; j++) {
				m2[i][j]=m[i][j];
			}
		}
		return m2;
	}
	
	/**
	 * Método que comprueba que una matriz es cuadrada
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	private boolean esCuadrada(int[][] m) {
		for (int i=0; i<m.length;i++) {
			if (m.length != m[i].length) {
				return false;
			}
		}
		return true;
	}
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-09-19 20:21:24.113
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-09-19 20:21:24.115
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-09-19 20:21:25.119
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package p1Algoritmia;

import java.security.InvalidParameterException;
/**
 * Titulo: Clase Algorithms
 * 
 * @author Omar Teixeira
 * @version 10/09/2021
 */
public class Algorithms {
	/**
	 * Constante Sleep Time
	 */
	private static final long SLEEP_TIME = 1;
	
	/**
	 * Método doNothing
	 */
	public static void doNothing() {
		try {
			Thread.sleep(SLEEP_TIME);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}

	/**
	 * Método que calcula el factorial de un numero mayor o igual a cero de forma recursiva
	 * 
	 * @param n, numero a calcular el factorial
	 * @return factorial
	 */
	public long factorial (int n) { // Calcula el factorial de n>=0 de forma recursiva
		doNothing();
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);		
		
		if (n==0)
			return 1;
		else
			return n*factorial(n-1);		
	} 
	
	/**
	 * Método que calcula el numero que ocupa el n introducido en la sucesión de fibonacci
	 * 
	 * @param n, numero a calcular el fibonacci
	 * @return valor fibonacci
	 */
	public int fibonacci (int n) { // Calcula el termino n-esimo teniendo en cuenta que el primer término se considera fib(0)=0; y fib(1)=1		
		if (n<0)
		throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		
		if (n==0)
			return 0;
		else if (n==1)
			return 1;
		else
			return fibonacci(n-1)+fibonacci(n-2);		
	} 
	
	/**
	 * Método que calcula la potencia recursiva 1 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec1(int n) {  // calcula 2 elevado a n de forma recursiva 2^n = 2*2^(n-1)
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		
		if (n==0)
			return 1;
		else 
			return 2*pow2Rec1(n-1);				
	} 
	
	/**
	 * Método que calcula la potencia iterativa de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Iter (int n) {  // calcula 2 elevado a n de forma iterativa 
	    if (n<0)
	    	throw new InvalidParameterException("No permitidos exponentes negativos como "+ n); 
	    
	    long pow=2;
	    for (int i=0; i<=n;i++) {
	    	doNothing();
	    	pow=2*pow;
	    }	    
	    return pow; 
	} 

	/**
	 * Método que calcula la potencia recursiva 2 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec2 (int n) { // calcula 2 elevado a n de forma recursiva 2^n = 2^(n-1)+2^(n-1) 
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		if (n==0)
			return 1;
		else 
			return pow2Rec2(n-1) + pow2Rec2(n-1);
	} 
	
	/**
	 * Método que calcula la potencia recursiva 3 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec3 (int n) { // calcula 2 elevado a n de forma recursiva 2^n = 2^(n/2)*2^(n/2) si n par y *2 si es impar 
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		if (n==0)
			return 1;
		else if (n%2==0)
			return pow2Rec3(n/2)*pow2Rec3(n/2);
		else 
			return pow2Rec3(n/2)*pow2Rec3(n/2)*2; 
	} 
	
	/**
	 * Método que calcula la potencia recursiva 4 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec4 (int n) {  // calcula 2 elevado a n de forma recursiva 2^n = como pow2Rec3 pero sin repetir llamada 
		doNothing();
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		if (n==0) {
			return 1;
		} else { 
			if (n%2==0) {
				long res = pow2Rec4(n/2);
				return res*res;
			}
			else { 
				long res = pow2Rec4(n/2);
				return 2*res*res;
			}
		}	
		} 
	  
	/**
	 * Método que calcula la potencia de un numero a elevado al numero introducido b
	 * 
	 * @param a, base
	 * @param b, exponente
	 * @return potencia de la base elevada al exponente
	 */
	public long potenciaRec(int a, int b) { // Calcula a elevado a b de forma recursiva por potencias sucesivas 
		if (a<0 || b<0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido"); 
		
		if(a==1 || b==0)
			return 1;
		else			
			return a*potenciaRec(a,b-1);
		 
	}
	
	/**
	 * Método que calcula el resto de la división de dos numeros
	 * 
	 * @param a, dividendo
	 * @param b, divisor
	 * @return resto
	 */
	public int restoDivRec (int a, int b) {  // calcula el resto de la división a/b de forma recursiva 
		if (a<0 || b<=0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido");
		
		if (a<b)
			return a;
		else
			return restoDivRec(a-b,b);		
	} 
	
	/**
	 * Método que calcula la división entera de dos numeros
	 * 
	 * @param a, dividendo
	 * @param b, divisor
	 * @return division entera
	 */
	public int divEntRec (int a, int b) {  // calcula la división entera a/b de forma recursiva 
		if (a<0 || b<=0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido");		
		
		if (a<b)
			return 0;
		else
			return 1+divEntRec(a-b,b);		
	} 
	
	/**
	 * Método que invierte un numero entero de forma recursiva
	 * 
	 * @param n, numero a invertir
	 * @return numero invertido
	 */
	public int invertirEnteroRec(int n) {  // Invierte un entero invertirEnteroRec(1234)=4321 de forma recursiva
		if (n<10)
			return n;
		else			
			return (n%10) * (int)Math.pow(10, Integer.toString(n/10).length())+ invertirEnteroRec(n/10);
	} 

	/**
	 * Método que invierte un string de forma recursiva
	 * 
	 * @param l, string a invertir
	 * @return string invertido
	 */
	public String invertirStringRec(String l) { // Invierte un string de forma recursiva invertirStringRec("abc")="cba" 
		if (l.length()==1)
			return l;
		else
			return invertirStringRec(l.substring(1)) + l.charAt(0);
	}
	  
	/**
	 * Método que tiene una complejidad temporal lineal
	 * 
	 * @param n, parametro
	 */
	public void linear (int n) { // Algoritmo con una complejidad temporal lineal 
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		for (int i=0; i<=n; i++) {
			doNothing();
			System.out.println("El algoritmo se ha ejecutado: " + i + " vez/veces");
		}
	} 

	/**
	 * Método que tiene una complejidad temporal lineal
	 * 
	 * @param n, parametro
	 */
	public void quadratic(int n) { // Algoritmo con una complejidad temporal cuadrática 
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		for (int i=0; i<=n; i++) {
			for (int j=0; j<=n;j++) {
				doNothing();
				System.out.println("El algoritmo se ha ejecutado: " + j + " vez/veces");
			}
			System.out.println("--------"+i+"---------");
		}
	} 

	  

	public void cubic(int n) { // Algoritmo con una complejidad temporal cúbica 
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		for (int i=0; i<=n; i++) {
			for (int j=0; j<=n;j++) {
				for (int k=0; k<=n;k++) {
					doNothing();
					("El algoritmo se ha ejecutado: " + k + " vez/veces");
				}
				System.out.println("--------"+j+"---------");
			}
			System.out.println("~~~~~~~"+j+"---------");
		}

	} 

	  

	public void logarithmic(int n) { // Algoritmo con una complejidad temporal logarítmica en cualquier base 

	if (n<0) 

	throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 

	} 	

	/**
	 * Método que comprueba si una matriz cuadrada es simetrica 
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	public boolean esSimetrica(int[][] m) { // Indica si es simétrica una matriz cuadrada de forma recursiva
		if (m.length == 1 && m[0].length == 1) {
			return true;
		} else if (!esCuadrada(m)) {
			return false;
		} else if (esIgualFilaColumna(m)){
			if (esSimetrica(eliminaFila(m))){
				return true;
			}			
		}
		return false;
	}
	
	/**
	 * Método que comprueba que la ultima fila es igual a la ultima columna
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	private boolean esIgualFilaColumna(int[][] m) {
		for (int i=0; i<m.length; i++) {
			if (m[m.length-1][i]!= m[i][m.length-1]) {
				return false;
			}
		}
		return true;
	}

	/**
	 * Método que elimina las filas de la matriz
	 * 
	 * @param m, matriz a la que eliminar las filas
	 * @return nueva matriz con las filas eliminadas
	 */
	private int[][] eliminaFila(int[][] m) {
		int [][] m2 = new int[m.length-1][m.length-1];		
		for (int i=0; i<m.length-1; i++) {
			for (int j=0; j<m.length-1; j++) {
				m2[i][j]=m[i][j];
			}
		}
		return m2;
	}
	
	/**
	 * Método que comprueba que una matriz es cuadrada
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	private boolean esCuadrada(int[][] m) {
		for (int i=0; i<m.length;i++) {
			if (m.length != m[i].length) {
				return false;
			}
		}
		return true;
	}
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-09-19 20:21:25.121
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-09-19 20:21:25.122
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-09-19 20:21:25.542
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package p1Algoritmia;

import java.security.InvalidParameterException;
/**
 * Titulo: Clase Algorithms
 * 
 * @author Omar Teixeira
 * @version 10/09/2021
 */
public class Algorithms {
	/**
	 * Constante Sleep Time
	 */
	private static final long SLEEP_TIME = 1;
	
	/**
	 * Método doNothing
	 */
	public static void doNothing() {
		try {
			Thread.sleep(SLEEP_TIME);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}

	/**
	 * Método que calcula el factorial de un numero mayor o igual a cero de forma recursiva
	 * 
	 * @param n, numero a calcular el factorial
	 * @return factorial
	 */
	public long factorial (int n) { // Calcula el factorial de n>=0 de forma recursiva
		doNothing();
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);		
		
		if (n==0)
			return 1;
		else
			return n*factorial(n-1);		
	} 
	
	/**
	 * Método que calcula el numero que ocupa el n introducido en la sucesión de fibonacci
	 * 
	 * @param n, numero a calcular el fibonacci
	 * @return valor fibonacci
	 */
	public int fibonacci (int n) { // Calcula el termino n-esimo teniendo en cuenta que el primer término se considera fib(0)=0; y fib(1)=1		
		if (n<0)
		throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		
		if (n==0)
			return 0;
		else if (n==1)
			return 1;
		else
			return fibonacci(n-1)+fibonacci(n-2);		
	} 
	
	/**
	 * Método que calcula la potencia recursiva 1 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec1(int n) {  // calcula 2 elevado a n de forma recursiva 2^n = 2*2^(n-1)
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		
		if (n==0)
			return 1;
		else 
			return 2*pow2Rec1(n-1);				
	} 
	
	/**
	 * Método que calcula la potencia iterativa de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Iter (int n) {  // calcula 2 elevado a n de forma iterativa 
	    if (n<0)
	    	throw new InvalidParameterException("No permitidos exponentes negativos como "+ n); 
	    
	    long pow=2;
	    for (int i=0; i<=n;i++) {
	    	doNothing();
	    	pow=2*pow;
	    }	    
	    return pow; 
	} 

	/**
	 * Método que calcula la potencia recursiva 2 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec2 (int n) { // calcula 2 elevado a n de forma recursiva 2^n = 2^(n-1)+2^(n-1) 
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		if (n==0)
			return 1;
		else 
			return pow2Rec2(n-1) + pow2Rec2(n-1);
	} 
	
	/**
	 * Método que calcula la potencia recursiva 3 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec3 (int n) { // calcula 2 elevado a n de forma recursiva 2^n = 2^(n/2)*2^(n/2) si n par y *2 si es impar 
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		if (n==0)
			return 1;
		else if (n%2==0)
			return pow2Rec3(n/2)*pow2Rec3(n/2);
		else 
			return pow2Rec3(n/2)*pow2Rec3(n/2)*2; 
	} 
	
	/**
	 * Método que calcula la potencia recursiva 4 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec4 (int n) {  // calcula 2 elevado a n de forma recursiva 2^n = como pow2Rec3 pero sin repetir llamada 
		doNothing();
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		if (n==0) {
			return 1;
		} else { 
			if (n%2==0) {
				long res = pow2Rec4(n/2);
				return res*res;
			}
			else { 
				long res = pow2Rec4(n/2);
				return 2*res*res;
			}
		}	
		} 
	  
	/**
	 * Método que calcula la potencia de un numero a elevado al numero introducido b
	 * 
	 * @param a, base
	 * @param b, exponente
	 * @return potencia de la base elevada al exponente
	 */
	public long potenciaRec(int a, int b) { // Calcula a elevado a b de forma recursiva por potencias sucesivas 
		if (a<0 || b<0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido"); 
		
		if(a==1 || b==0)
			return 1;
		else			
			return a*potenciaRec(a,b-1);
		 
	}
	
	/**
	 * Método que calcula el resto de la división de dos numeros
	 * 
	 * @param a, dividendo
	 * @param b, divisor
	 * @return resto
	 */
	public int restoDivRec (int a, int b) {  // calcula el resto de la división a/b de forma recursiva 
		if (a<0 || b<=0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido");
		
		if (a<b)
			return a;
		else
			return restoDivRec(a-b,b);		
	} 
	
	/**
	 * Método que calcula la división entera de dos numeros
	 * 
	 * @param a, dividendo
	 * @param b, divisor
	 * @return division entera
	 */
	public int divEntRec (int a, int b) {  // calcula la división entera a/b de forma recursiva 
		if (a<0 || b<=0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido");		
		
		if (a<b)
			return 0;
		else
			return 1+divEntRec(a-b,b);		
	} 
	
	/**
	 * Método que invierte un numero entero de forma recursiva
	 * 
	 * @param n, numero a invertir
	 * @return numero invertido
	 */
	public int invertirEnteroRec(int n) {  // Invierte un entero invertirEnteroRec(1234)=4321 de forma recursiva
		if (n<10)
			return n;
		else			
			return (n%10) * (int)Math.pow(10, Integer.toString(n/10).length())+ invertirEnteroRec(n/10);
	} 

	/**
	 * Método que invierte un string de forma recursiva
	 * 
	 * @param l, string a invertir
	 * @return string invertido
	 */
	public String invertirStringRec(String l) { // Invierte un string de forma recursiva invertirStringRec("abc")="cba" 
		if (l.length()==1)
			return l;
		else
			return invertirStringRec(l.substring(1)) + l.charAt(0);
	}
	  
	/**
	 * Método que tiene una complejidad temporal lineal
	 * 
	 * @param n, parametro
	 */
	public void linear (int n) { // Algoritmo con una complejidad temporal lineal 
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		for (int i=0; i<=n; i++) {
			doNothing();
			System.out.println("El algoritmo se ha ejecutado: " + i + " vez/veces");
		}
	} 

	/**
	 * Método que tiene una complejidad temporal lineal
	 * 
	 * @param n, parametro
	 */
	public void quadratic(int n) { // Algoritmo con una complejidad temporal cuadrática 
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		for (int i=0; i<=n; i++) {
			for (int j=0; j<=n;j++) {
				doNothing();
				System.out.println("El algoritmo se ha ejecutado: " + j + " vez/veces");
			}
			System.out.println("--------"+i+"---------");
		}
	} 

	  

	public void cubic(int n) { // Algoritmo con una complejidad temporal cúbica 
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		for (int i=0; i<=n; i++) {
			for (int j=0; j<=n;j++) {
				for (int k=0; k<=n;k++) {
					doNothing();
					("El algoritmo se ha ejecutado: " + k + " vez/veces");
				}
				System.out.println("--------"+j+"---------");
			}
			System.out.println("~~~~~~~"+j+"---------");
		}

	} 

	  

	public void logarithmic(int n) { // Algoritmo con una complejidad temporal logarítmica en cualquier base 

	if (n<0) 

	throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 

	} 	

	/**
	 * Método que comprueba si una matriz cuadrada es simetrica 
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	public boolean esSimetrica(int[][] m) { // Indica si es simétrica una matriz cuadrada de forma recursiva
		if (m.length == 1 && m[0].length == 1) {
			return true;
		} else if (!esCuadrada(m)) {
			return false;
		} else if (esIgualFilaColumna(m)){
			if (esSimetrica(eliminaFila(m))){
				return true;
			}			
		}
		return false;
	}
	
	/**
	 * Método que comprueba que la ultima fila es igual a la ultima columna
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	private boolean esIgualFilaColumna(int[][] m) {
		for (int i=0; i<m.length; i++) {
			if (m[m.length-1][i]!= m[i][m.length-1]) {
				return false;
			}
		}
		return true;
	}

	/**
	 * Método que elimina las filas de la matriz
	 * 
	 * @param m, matriz a la que eliminar las filas
	 * @return nueva matriz con las filas eliminadas
	 */
	private int[][] eliminaFila(int[][] m) {
		int [][] m2 = new int[m.length-1][m.length-1];		
		for (int i=0; i<m.length-1; i++) {
			for (int j=0; j<m.length-1; j++) {
				m2[i][j]=m[i][j];
			}
		}
		return m2;
	}
	
	/**
	 * Método que comprueba que una matriz es cuadrada
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	private boolean esCuadrada(int[][] m) {
		for (int i=0; i<m.length;i++) {
			if (m.length != m[i].length) {
				return false;
			}
		}
		return true;
	}
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-09-19 20:21:25.543
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-09-19 20:21:25.545
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-09-19 20:21:26.627
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package p1Algoritmia;

import java.security.InvalidParameterException;
/**
 * Titulo: Clase Algorithms
 * 
 * @author Omar Teixeira
 * @version 10/09/2021
 */
public class Algorithms {
	/**
	 * Constante Sleep Time
	 */
	private static final long SLEEP_TIME = 1;
	
	/**
	 * Método doNothing
	 */
	public static void doNothing() {
		try {
			Thread.sleep(SLEEP_TIME);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}

	/**
	 * Método que calcula el factorial de un numero mayor o igual a cero de forma recursiva
	 * 
	 * @param n, numero a calcular el factorial
	 * @return factorial
	 */
	public long factorial (int n) { // Calcula el factorial de n>=0 de forma recursiva
		doNothing();
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);		
		
		if (n==0)
			return 1;
		else
			return n*factorial(n-1);		
	} 
	
	/**
	 * Método que calcula el numero que ocupa el n introducido en la sucesión de fibonacci
	 * 
	 * @param n, numero a calcular el fibonacci
	 * @return valor fibonacci
	 */
	public int fibonacci (int n) { // Calcula el termino n-esimo teniendo en cuenta que el primer término se considera fib(0)=0; y fib(1)=1		
		if (n<0)
		throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		
		if (n==0)
			return 0;
		else if (n==1)
			return 1;
		else
			return fibonacci(n-1)+fibonacci(n-2);		
	} 
	
	/**
	 * Método que calcula la potencia recursiva 1 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec1(int n) {  // calcula 2 elevado a n de forma recursiva 2^n = 2*2^(n-1)
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		
		if (n==0)
			return 1;
		else 
			return 2*pow2Rec1(n-1);				
	} 
	
	/**
	 * Método que calcula la potencia iterativa de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Iter (int n) {  // calcula 2 elevado a n de forma iterativa 
	    if (n<0)
	    	throw new InvalidParameterException("No permitidos exponentes negativos como "+ n); 
	    
	    long pow=2;
	    for (int i=0; i<=n;i++) {
	    	doNothing();
	    	pow=2*pow;
	    }	    
	    return pow; 
	} 

	/**
	 * Método que calcula la potencia recursiva 2 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec2 (int n) { // calcula 2 elevado a n de forma recursiva 2^n = 2^(n-1)+2^(n-1) 
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		if (n==0)
			return 1;
		else 
			return pow2Rec2(n-1) + pow2Rec2(n-1);
	} 
	
	/**
	 * Método que calcula la potencia recursiva 3 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec3 (int n) { // calcula 2 elevado a n de forma recursiva 2^n = 2^(n/2)*2^(n/2) si n par y *2 si es impar 
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		if (n==0)
			return 1;
		else if (n%2==0)
			return pow2Rec3(n/2)*pow2Rec3(n/2);
		else 
			return pow2Rec3(n/2)*pow2Rec3(n/2)*2; 
	} 
	
	/**
	 * Método que calcula la potencia recursiva 4 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec4 (int n) {  // calcula 2 elevado a n de forma recursiva 2^n = como pow2Rec3 pero sin repetir llamada 
		doNothing();
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		if (n==0) {
			return 1;
		} else { 
			if (n%2==0) {
				long res = pow2Rec4(n/2);
				return res*res;
			}
			else { 
				long res = pow2Rec4(n/2);
				return 2*res*res;
			}
		}	
		} 
	  
	/**
	 * Método que calcula la potencia de un numero a elevado al numero introducido b
	 * 
	 * @param a, base
	 * @param b, exponente
	 * @return potencia de la base elevada al exponente
	 */
	public long potenciaRec(int a, int b) { // Calcula a elevado a b de forma recursiva por potencias sucesivas 
		if (a<0 || b<0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido"); 
		
		if(a==1 || b==0)
			return 1;
		else			
			return a*potenciaRec(a,b-1);
		 
	}
	
	/**
	 * Método que calcula el resto de la división de dos numeros
	 * 
	 * @param a, dividendo
	 * @param b, divisor
	 * @return resto
	 */
	public int restoDivRec (int a, int b) {  // calcula el resto de la división a/b de forma recursiva 
		if (a<0 || b<=0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido");
		
		if (a<b)
			return a;
		else
			return restoDivRec(a-b,b);		
	} 
	
	/**
	 * Método que calcula la división entera de dos numeros
	 * 
	 * @param a, dividendo
	 * @param b, divisor
	 * @return division entera
	 */
	public int divEntRec (int a, int b) {  // calcula la división entera a/b de forma recursiva 
		if (a<0 || b<=0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido");		
		
		if (a<b)
			return 0;
		else
			return 1+divEntRec(a-b,b);		
	} 
	
	/**
	 * Método que invierte un numero entero de forma recursiva
	 * 
	 * @param n, numero a invertir
	 * @return numero invertido
	 */
	public int invertirEnteroRec(int n) {  // Invierte un entero invertirEnteroRec(1234)=4321 de forma recursiva
		if (n<10)
			return n;
		else			
			return (n%10) * (int)Math.pow(10, Integer.toString(n/10).length())+ invertirEnteroRec(n/10);
	} 

	/**
	 * Método que invierte un string de forma recursiva
	 * 
	 * @param l, string a invertir
	 * @return string invertido
	 */
	public String invertirStringRec(String l) { // Invierte un string de forma recursiva invertirStringRec("abc")="cba" 
		if (l.length()==1)
			return l;
		else
			return invertirStringRec(l.substring(1)) + l.charAt(0);
	}
	  
	/**
	 * Método que tiene una complejidad temporal lineal
	 * 
	 * @param n, parametro
	 */
	public void linear (int n) { // Algoritmo con una complejidad temporal lineal 
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		for (int i=0; i<=n; i++) {
			doNothing();
			System.out.println("El algoritmo se ha ejecutado: " + i + " vez/veces");
		}
	} 

	/**
	 * Método que tiene una complejidad temporal lineal
	 * 
	 * @param n, parametro
	 */
	public void quadratic(int n) { // Algoritmo con una complejidad temporal cuadrática 
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		for (int i=0; i<=n; i++) {
			for (int j=0; j<=n;j++) {
				doNothing();
				System.out.println("El algoritmo se ha ejecutado: " + j + " vez/veces");
			}
			System.out.println("--------"+i+"---------");
		}
	} 

	  

	public void cubic(int n) { // Algoritmo con una complejidad temporal cúbica 
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		for (int i=0; i<=n; i++) {
			for (int j=0; j<=n;j++) {
				for (int k=0; k<=n;k++) {
					doNothing();
					("El algoritmo se ha ejecutado: " + k + " vez/veces");
				}
				System.out.println("--------"+j+"---------");
			}
			System.out.println("~~~~~~~~"+j+"---------");
		}

	} 

	  

	public void logarithmic(int n) { // Algoritmo con una complejidad temporal logarítmica en cualquier base 

	if (n<0) 

	throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 

	} 	

	/**
	 * Método que comprueba si una matriz cuadrada es simetrica 
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	public boolean esSimetrica(int[][] m) { // Indica si es simétrica una matriz cuadrada de forma recursiva
		if (m.length == 1 && m[0].length == 1) {
			return true;
		} else if (!esCuadrada(m)) {
			return false;
		} else if (esIgualFilaColumna(m)){
			if (esSimetrica(eliminaFila(m))){
				return true;
			}			
		}
		return false;
	}
	
	/**
	 * Método que comprueba que la ultima fila es igual a la ultima columna
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	private boolean esIgualFilaColumna(int[][] m) {
		for (int i=0; i<m.length; i++) {
			if (m[m.length-1][i]!= m[i][m.length-1]) {
				return false;
			}
		}
		return true;
	}

	/**
	 * Método que elimina las filas de la matriz
	 * 
	 * @param m, matriz a la que eliminar las filas
	 * @return nueva matriz con las filas eliminadas
	 */
	private int[][] eliminaFila(int[][] m) {
		int [][] m2 = new int[m.length-1][m.length-1];		
		for (int i=0; i<m.length-1; i++) {
			for (int j=0; j<m.length-1; j++) {
				m2[i][j]=m[i][j];
			}
		}
		return m2;
	}
	
	/**
	 * Método que comprueba que una matriz es cuadrada
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	private boolean esCuadrada(int[][] m) {
		for (int i=0; i<m.length;i++) {
			if (m.length != m[i].length) {
				return false;
			}
		}
		return true;
	}
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-09-19 20:21:26.629
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-09-19 20:21:26.630
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-09-19 20:21:26.682
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package p1Algoritmia;

import java.security.InvalidParameterException;
/**
 * Titulo: Clase Algorithms
 * 
 * @author Omar Teixeira
 * @version 10/09/2021
 */
public class Algorithms {
	/**
	 * Constante Sleep Time
	 */
	private static final long SLEEP_TIME = 1;
	
	/**
	 * Método doNothing
	 */
	public static void doNothing() {
		try {
			Thread.sleep(SLEEP_TIME);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}

	/**
	 * Método que calcula el factorial de un numero mayor o igual a cero de forma recursiva
	 * 
	 * @param n, numero a calcular el factorial
	 * @return factorial
	 */
	public long factorial (int n) { // Calcula el factorial de n>=0 de forma recursiva
		doNothing();
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);		
		
		if (n==0)
			return 1;
		else
			return n*factorial(n-1);		
	} 
	
	/**
	 * Método que calcula el numero que ocupa el n introducido en la sucesión de fibonacci
	 * 
	 * @param n, numero a calcular el fibonacci
	 * @return valor fibonacci
	 */
	public int fibonacci (int n) { // Calcula el termino n-esimo teniendo en cuenta que el primer término se considera fib(0)=0; y fib(1)=1		
		if (n<0)
		throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		
		if (n==0)
			return 0;
		else if (n==1)
			return 1;
		else
			return fibonacci(n-1)+fibonacci(n-2);		
	} 
	
	/**
	 * Método que calcula la potencia recursiva 1 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec1(int n) {  // calcula 2 elevado a n de forma recursiva 2^n = 2*2^(n-1)
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		
		if (n==0)
			return 1;
		else 
			return 2*pow2Rec1(n-1);				
	} 
	
	/**
	 * Método que calcula la potencia iterativa de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Iter (int n) {  // calcula 2 elevado a n de forma iterativa 
	    if (n<0)
	    	throw new InvalidParameterException("No permitidos exponentes negativos como "+ n); 
	    
	    long pow=2;
	    for (int i=0; i<=n;i++) {
	    	doNothing();
	    	pow=2*pow;
	    }	    
	    return pow; 
	} 

	/**
	 * Método que calcula la potencia recursiva 2 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec2 (int n) { // calcula 2 elevado a n de forma recursiva 2^n = 2^(n-1)+2^(n-1) 
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		if (n==0)
			return 1;
		else 
			return pow2Rec2(n-1) + pow2Rec2(n-1);
	} 
	
	/**
	 * Método que calcula la potencia recursiva 3 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec3 (int n) { // calcula 2 elevado a n de forma recursiva 2^n = 2^(n/2)*2^(n/2) si n par y *2 si es impar 
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		if (n==0)
			return 1;
		else if (n%2==0)
			return pow2Rec3(n/2)*pow2Rec3(n/2);
		else 
			return pow2Rec3(n/2)*pow2Rec3(n/2)*2; 
	} 
	
	/**
	 * Método que calcula la potencia recursiva 4 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec4 (int n) {  // calcula 2 elevado a n de forma recursiva 2^n = como pow2Rec3 pero sin repetir llamada 
		doNothing();
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		if (n==0) {
			return 1;
		} else { 
			if (n%2==0) {
				long res = pow2Rec4(n/2);
				return res*res;
			}
			else { 
				long res = pow2Rec4(n/2);
				return 2*res*res;
			}
		}	
		} 
	  
	/**
	 * Método que calcula la potencia de un numero a elevado al numero introducido b
	 * 
	 * @param a, base
	 * @param b, exponente
	 * @return potencia de la base elevada al exponente
	 */
	public long potenciaRec(int a, int b) { // Calcula a elevado a b de forma recursiva por potencias sucesivas 
		if (a<0 || b<0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido"); 
		
		if(a==1 || b==0)
			return 1;
		else			
			return a*potenciaRec(a,b-1);
		 
	}
	
	/**
	 * Método que calcula el resto de la división de dos numeros
	 * 
	 * @param a, dividendo
	 * @param b, divisor
	 * @return resto
	 */
	public int restoDivRec (int a, int b) {  // calcula el resto de la división a/b de forma recursiva 
		if (a<0 || b<=0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido");
		
		if (a<b)
			return a;
		else
			return restoDivRec(a-b,b);		
	} 
	
	/**
	 * Método que calcula la división entera de dos numeros
	 * 
	 * @param a, dividendo
	 * @param b, divisor
	 * @return division entera
	 */
	public int divEntRec (int a, int b) {  // calcula la división entera a/b de forma recursiva 
		if (a<0 || b<=0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido");		
		
		if (a<b)
			return 0;
		else
			return 1+divEntRec(a-b,b);		
	} 
	
	/**
	 * Método que invierte un numero entero de forma recursiva
	 * 
	 * @param n, numero a invertir
	 * @return numero invertido
	 */
	public int invertirEnteroRec(int n) {  // Invierte un entero invertirEnteroRec(1234)=4321 de forma recursiva
		if (n<10)
			return n;
		else			
			return (n%10) * (int)Math.pow(10, Integer.toString(n/10).length())+ invertirEnteroRec(n/10);
	} 

	/**
	 * Método que invierte un string de forma recursiva
	 * 
	 * @param l, string a invertir
	 * @return string invertido
	 */
	public String invertirStringRec(String l) { // Invierte un string de forma recursiva invertirStringRec("abc")="cba" 
		if (l.length()==1)
			return l;
		else
			return invertirStringRec(l.substring(1)) + l.charAt(0);
	}
	  
	/**
	 * Método que tiene una complejidad temporal lineal
	 * 
	 * @param n, parametro
	 */
	public void linear (int n) { // Algoritmo con una complejidad temporal lineal 
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		for (int i=0; i<=n; i++) {
			doNothing();
			System.out.println("El algoritmo se ha ejecutado: " + i + " vez/veces");
		}
	} 

	/**
	 * Método que tiene una complejidad temporal lineal
	 * 
	 * @param n, parametro
	 */
	public void quadratic(int n) { // Algoritmo con una complejidad temporal cuadrática 
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		for (int i=0; i<=n; i++) {
			for (int j=0; j<=n;j++) {
				doNothing();
				System.out.println("El algoritmo se ha ejecutado: " + j + " vez/veces");
			}
			System.out.println("--------"+i+"---------");
		}
	} 

	  

	public void cubic(int n) { // Algoritmo con una complejidad temporal cúbica 
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		for (int i=0; i<=n; i++) {
			for (int j=0; j<=n;j++) {
				for (int k=0; k<=n;k++) {
					doNothing();
					("El algoritmo se ha ejecutado: " + k + " vez/veces");
				}
				System.out.println("--------"+j+"---------");
			}
			System.out.println("~~~~~~~~"+j+"---------");
		}

	} 

	  

	public void logarithmic(int n) { // Algoritmo con una complejidad temporal logarítmica en cualquier base 

	if (n<0) 

	throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 

	} 	

	/**
	 * Método que comprueba si una matriz cuadrada es simetrica 
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	public boolean esSimetrica(int[][] m) { // Indica si es simétrica una matriz cuadrada de forma recursiva
		if (m.length == 1 && m[0].length == 1) {
			return true;
		} else if (!esCuadrada(m)) {
			return false;
		} else if (esIgualFilaColumna(m)){
			if (esSimetrica(eliminaFila(m))){
				return true;
			}			
		}
		return false;
	}
	
	/**
	 * Método que comprueba que la ultima fila es igual a la ultima columna
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	private boolean esIgualFilaColumna(int[][] m) {
		for (int i=0; i<m.length; i++) {
			if (m[m.length-1][i]!= m[i][m.length-1]) {
				return false;
			}
		}
		return true;
	}

	/**
	 * Método que elimina las filas de la matriz
	 * 
	 * @param m, matriz a la que eliminar las filas
	 * @return nueva matriz con las filas eliminadas
	 */
	private int[][] eliminaFila(int[][] m) {
		int [][] m2 = new int[m.length-1][m.length-1];		
		for (int i=0; i<m.length-1; i++) {
			for (int j=0; j<m.length-1; j++) {
				m2[i][j]=m[i][j];
			}
		}
		return m2;
	}
	
	/**
	 * Método que comprueba que una matriz es cuadrada
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	private boolean esCuadrada(int[][] m) {
		for (int i=0; i<m.length;i++) {
			if (m.length != m[i].length) {
				return false;
			}
		}
		return true;
	}
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-09-19 20:21:26.684
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-09-19 20:21:26.685
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-09-19 20:21:28.978
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package p1Algoritmia;

import java.security.InvalidParameterException;
/**
 * Titulo: Clase Algorithms
 * 
 * @author Omar Teixeira
 * @version 10/09/2021
 */
public class Algorithms {
	/**
	 * Constante Sleep Time
	 */
	private static final long SLEEP_TIME = 1;
	
	/**
	 * Método doNothing
	 */
	public static void doNothing() {
		try {
			Thread.sleep(SLEEP_TIME);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}

	/**
	 * Método que calcula el factorial de un numero mayor o igual a cero de forma recursiva
	 * 
	 * @param n, numero a calcular el factorial
	 * @return factorial
	 */
	public long factorial (int n) { // Calcula el factorial de n>=0 de forma recursiva
		doNothing();
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);		
		
		if (n==0)
			return 1;
		else
			return n*factorial(n-1);		
	} 
	
	/**
	 * Método que calcula el numero que ocupa el n introducido en la sucesión de fibonacci
	 * 
	 * @param n, numero a calcular el fibonacci
	 * @return valor fibonacci
	 */
	public int fibonacci (int n) { // Calcula el termino n-esimo teniendo en cuenta que el primer término se considera fib(0)=0; y fib(1)=1		
		if (n<0)
		throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		
		if (n==0)
			return 0;
		else if (n==1)
			return 1;
		else
			return fibonacci(n-1)+fibonacci(n-2);		
	} 
	
	/**
	 * Método que calcula la potencia recursiva 1 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec1(int n) {  // calcula 2 elevado a n de forma recursiva 2^n = 2*2^(n-1)
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		
		if (n==0)
			return 1;
		else 
			return 2*pow2Rec1(n-1);				
	} 
	
	/**
	 * Método que calcula la potencia iterativa de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Iter (int n) {  // calcula 2 elevado a n de forma iterativa 
	    if (n<0)
	    	throw new InvalidParameterException("No permitidos exponentes negativos como "+ n); 
	    
	    long pow=2;
	    for (int i=0; i<=n;i++) {
	    	doNothing();
	    	pow=2*pow;
	    }	    
	    return pow; 
	} 

	/**
	 * Método que calcula la potencia recursiva 2 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec2 (int n) { // calcula 2 elevado a n de forma recursiva 2^n = 2^(n-1)+2^(n-1) 
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		if (n==0)
			return 1;
		else 
			return pow2Rec2(n-1) + pow2Rec2(n-1);
	} 
	
	/**
	 * Método que calcula la potencia recursiva 3 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec3 (int n) { // calcula 2 elevado a n de forma recursiva 2^n = 2^(n/2)*2^(n/2) si n par y *2 si es impar 
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		if (n==0)
			return 1;
		else if (n%2==0)
			return pow2Rec3(n/2)*pow2Rec3(n/2);
		else 
			return pow2Rec3(n/2)*pow2Rec3(n/2)*2; 
	} 
	
	/**
	 * Método que calcula la potencia recursiva 4 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec4 (int n) {  // calcula 2 elevado a n de forma recursiva 2^n = como pow2Rec3 pero sin repetir llamada 
		doNothing();
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		if (n==0) {
			return 1;
		} else { 
			if (n%2==0) {
				long res = pow2Rec4(n/2);
				return res*res;
			}
			else { 
				long res = pow2Rec4(n/2);
				return 2*res*res;
			}
		}	
		} 
	  
	/**
	 * Método que calcula la potencia de un numero a elevado al numero introducido b
	 * 
	 * @param a, base
	 * @param b, exponente
	 * @return potencia de la base elevada al exponente
	 */
	public long potenciaRec(int a, int b) { // Calcula a elevado a b de forma recursiva por potencias sucesivas 
		if (a<0 || b<0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido"); 
		
		if(a==1 || b==0)
			return 1;
		else			
			return a*potenciaRec(a,b-1);
		 
	}
	
	/**
	 * Método que calcula el resto de la división de dos numeros
	 * 
	 * @param a, dividendo
	 * @param b, divisor
	 * @return resto
	 */
	public int restoDivRec (int a, int b) {  // calcula el resto de la división a/b de forma recursiva 
		if (a<0 || b<=0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido");
		
		if (a<b)
			return a;
		else
			return restoDivRec(a-b,b);		
	} 
	
	/**
	 * Método que calcula la división entera de dos numeros
	 * 
	 * @param a, dividendo
	 * @param b, divisor
	 * @return division entera
	 */
	public int divEntRec (int a, int b) {  // calcula la división entera a/b de forma recursiva 
		if (a<0 || b<=0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido");		
		
		if (a<b)
			return 0;
		else
			return 1+divEntRec(a-b,b);		
	} 
	
	/**
	 * Método que invierte un numero entero de forma recursiva
	 * 
	 * @param n, numero a invertir
	 * @return numero invertido
	 */
	public int invertirEnteroRec(int n) {  // Invierte un entero invertirEnteroRec(1234)=4321 de forma recursiva
		if (n<10)
			return n;
		else			
			return (n%10) * (int)Math.pow(10, Integer.toString(n/10).length())+ invertirEnteroRec(n/10);
	} 

	/**
	 * Método que invierte un string de forma recursiva
	 * 
	 * @param l, string a invertir
	 * @return string invertido
	 */
	public String invertirStringRec(String l) { // Invierte un string de forma recursiva invertirStringRec("abc")="cba" 
		if (l.length()==1)
			return l;
		else
			return invertirStringRec(l.substring(1)) + l.charAt(0);
	}
	  
	/**
	 * Método que tiene una complejidad temporal lineal
	 * 
	 * @param n, parametro
	 */
	public void linear (int n) { // Algoritmo con una complejidad temporal lineal 
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		for (int i=0; i<=n; i++) {
			doNothing();
			System.out.println("El algoritmo se ha ejecutado: " + i + " vez/veces");
		}
	} 

	/**
	 * Método que tiene una complejidad temporal lineal
	 * 
	 * @param n, parametro
	 */
	public void quadratic(int n) { // Algoritmo con una complejidad temporal cuadrática 
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		for (int i=0; i<=n; i++) {
			for (int j=0; j<=n;j++) {
				doNothing();
				System.out.println("El algoritmo se ha ejecutado: " + j + " vez/veces");
			}
			System.out.println("--------"+i+"---------");
		}
	} 

	  

	public void cubic(int n) { // Algoritmo con una complejidad temporal cúbica 
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		for (int i=0; i<=n; i++) {
			for (int j=0; j<=n;j++) {
				for (int k=0; k<=n;k++) {
					doNothing();
					("El algoritmo se ha ejecutado: " + k + " vez/veces");
				}
				System.out.println("--------"+j+"---------");
			}
			System.out.println("~~~~~~~~"+j+"---------");
		}

	} 

	  

	public void logarithmic(int n) { // Algoritmo con una complejidad temporal logarítmica en cualquier base 

	if (n<0) 

	throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 

	} 	

	/**
	 * Método que comprueba si una matriz cuadrada es simetrica 
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	public boolean esSimetrica(int[][] m) { // Indica si es simétrica una matriz cuadrada de forma recursiva
		if (m.length == 1 && m[0].length == 1) {
			return true;
		} else if (!esCuadrada(m)) {
			return false;
		} else if (esIgualFilaColumna(m)){
			if (esSimetrica(eliminaFila(m))){
				return true;
			}			
		}
		return false;
	}
	
	/**
	 * Método que comprueba que la ultima fila es igual a la ultima columna
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	private boolean esIgualFilaColumna(int[][] m) {
		for (int i=0; i<m.length; i++) {
			if (m[m.length-1][i]!= m[i][m.length-1]) {
				return false;
			}
		}
		return true;
	}

	/**
	 * Método que elimina las filas de la matriz
	 * 
	 * @param m, matriz a la que eliminar las filas
	 * @return nueva matriz con las filas eliminadas
	 */
	private int[][] eliminaFila(int[][] m) {
		int [][] m2 = new int[m.length-1][m.length-1];		
		for (int i=0; i<m.length-1; i++) {
			for (int j=0; j<m.length-1; j++) {
				m2[i][j]=m[i][j];
			}
		}
		return m2;
	}
	
	/**
	 * Método que comprueba que una matriz es cuadrada
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	private boolean esCuadrada(int[][] m) {
		for (int i=0; i<m.length;i++) {
			if (m.length != m[i].length) {
				return false;
			}
		}
		return true;
	}
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-09-19 20:21:28.980
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-09-19 20:21:28.981
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-09-19 20:21:29.521
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package p1Algoritmia;

import java.security.InvalidParameterException;
/**
 * Titulo: Clase Algorithms
 * 
 * @author Omar Teixeira
 * @version 10/09/2021
 */
public class Algorithms {
	/**
	 * Constante Sleep Time
	 */
	private static final long SLEEP_TIME = 1;
	
	/**
	 * Método doNothing
	 */
	public static void doNothing() {
		try {
			Thread.sleep(SLEEP_TIME);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}

	/**
	 * Método que calcula el factorial de un numero mayor o igual a cero de forma recursiva
	 * 
	 * @param n, numero a calcular el factorial
	 * @return factorial
	 */
	public long factorial (int n) { // Calcula el factorial de n>=0 de forma recursiva
		doNothing();
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);		
		
		if (n==0)
			return 1;
		else
			return n*factorial(n-1);		
	} 
	
	/**
	 * Método que calcula el numero que ocupa el n introducido en la sucesión de fibonacci
	 * 
	 * @param n, numero a calcular el fibonacci
	 * @return valor fibonacci
	 */
	public int fibonacci (int n) { // Calcula el termino n-esimo teniendo en cuenta que el primer término se considera fib(0)=0; y fib(1)=1		
		if (n<0)
		throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		
		if (n==0)
			return 0;
		else if (n==1)
			return 1;
		else
			return fibonacci(n-1)+fibonacci(n-2);		
	} 
	
	/**
	 * Método que calcula la potencia recursiva 1 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec1(int n) {  // calcula 2 elevado a n de forma recursiva 2^n = 2*2^(n-1)
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		
		if (n==0)
			return 1;
		else 
			return 2*pow2Rec1(n-1);				
	} 
	
	/**
	 * Método que calcula la potencia iterativa de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Iter (int n) {  // calcula 2 elevado a n de forma iterativa 
	    if (n<0)
	    	throw new InvalidParameterException("No permitidos exponentes negativos como "+ n); 
	    
	    long pow=2;
	    for (int i=0; i<=n;i++) {
	    	doNothing();
	    	pow=2*pow;
	    }	    
	    return pow; 
	} 

	/**
	 * Método que calcula la potencia recursiva 2 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec2 (int n) { // calcula 2 elevado a n de forma recursiva 2^n = 2^(n-1)+2^(n-1) 
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		if (n==0)
			return 1;
		else 
			return pow2Rec2(n-1) + pow2Rec2(n-1);
	} 
	
	/**
	 * Método que calcula la potencia recursiva 3 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec3 (int n) { // calcula 2 elevado a n de forma recursiva 2^n = 2^(n/2)*2^(n/2) si n par y *2 si es impar 
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		if (n==0)
			return 1;
		else if (n%2==0)
			return pow2Rec3(n/2)*pow2Rec3(n/2);
		else 
			return pow2Rec3(n/2)*pow2Rec3(n/2)*2; 
	} 
	
	/**
	 * Método que calcula la potencia recursiva 4 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec4 (int n) {  // calcula 2 elevado a n de forma recursiva 2^n = como pow2Rec3 pero sin repetir llamada 
		doNothing();
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		if (n==0) {
			return 1;
		} else { 
			if (n%2==0) {
				long res = pow2Rec4(n/2);
				return res*res;
			}
			else { 
				long res = pow2Rec4(n/2);
				return 2*res*res;
			}
		}	
		} 
	  
	/**
	 * Método que calcula la potencia de un numero a elevado al numero introducido b
	 * 
	 * @param a, base
	 * @param b, exponente
	 * @return potencia de la base elevada al exponente
	 */
	public long potenciaRec(int a, int b) { // Calcula a elevado a b de forma recursiva por potencias sucesivas 
		if (a<0 || b<0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido"); 
		
		if(a==1 || b==0)
			return 1;
		else			
			return a*potenciaRec(a,b-1);
		 
	}
	
	/**
	 * Método que calcula el resto de la división de dos numeros
	 * 
	 * @param a, dividendo
	 * @param b, divisor
	 * @return resto
	 */
	public int restoDivRec (int a, int b) {  // calcula el resto de la división a/b de forma recursiva 
		if (a<0 || b<=0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido");
		
		if (a<b)
			return a;
		else
			return restoDivRec(a-b,b);		
	} 
	
	/**
	 * Método que calcula la división entera de dos numeros
	 * 
	 * @param a, dividendo
	 * @param b, divisor
	 * @return division entera
	 */
	public int divEntRec (int a, int b) {  // calcula la división entera a/b de forma recursiva 
		if (a<0 || b<=0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido");		
		
		if (a<b)
			return 0;
		else
			return 1+divEntRec(a-b,b);		
	} 
	
	/**
	 * Método que invierte un numero entero de forma recursiva
	 * 
	 * @param n, numero a invertir
	 * @return numero invertido
	 */
	public int invertirEnteroRec(int n) {  // Invierte un entero invertirEnteroRec(1234)=4321 de forma recursiva
		if (n<10)
			return n;
		else			
			return (n%10) * (int)Math.pow(10, Integer.toString(n/10).length())+ invertirEnteroRec(n/10);
	} 

	/**
	 * Método que invierte un string de forma recursiva
	 * 
	 * @param l, string a invertir
	 * @return string invertido
	 */
	public String invertirStringRec(String l) { // Invierte un string de forma recursiva invertirStringRec("abc")="cba" 
		if (l.length()==1)
			return l;
		else
			return invertirStringRec(l.substring(1)) + l.charAt(0);
	}
	  
	/**
	 * Método que tiene una complejidad temporal lineal
	 * 
	 * @param n, parametro
	 */
	public void linear (int n) { // Algoritmo con una complejidad temporal lineal 
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		for (int i=0; i<=n; i++) {
			doNothing();
			System.out.println("El algoritmo se ha ejecutado: " + i + " vez/veces");
		}
	} 

	/**
	 * Método que tiene una complejidad temporal lineal
	 * 
	 * @param n, parametro
	 */
	public void quadratic(int n) { // Algoritmo con una complejidad temporal cuadrática 
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		for (int i=0; i<=n; i++) {
			for (int j=0; j<=n;j++) {
				doNothing();
				System.out.println("El algoritmo se ha ejecutado: " + j + " vez/veces");
			}
			System.out.println("--------"+i+"---------");
		}
	} 

	  

	public void cubic(int n) { // Algoritmo con una complejidad temporal cúbica 
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		for (int i=0; i<=n; i++) {
			for (int j=0; j<=n;j++) {
				for (int k=0; k<=n;k++) {
					doNothing();
					("El algoritmo se ha ejecutado: " + k + " vez/veces");
				}
				System.out.println("--------"+j+"---------");
			}
			System.out.println("~~~~~~~~"+j+"---------");
		}

	} 

	  

	public void logarithmic(int n) { // Algoritmo con una complejidad temporal logarítmica en cualquier base 

	if (n<0) 

	throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 

	} 	

	/**
	 * Método que comprueba si una matriz cuadrada es simetrica 
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	public boolean esSimetrica(int[][] m) { // Indica si es simétrica una matriz cuadrada de forma recursiva
		if (m.length == 1 && m[0].length == 1) {
			return true;
		} else if (!esCuadrada(m)) {
			return false;
		} else if (esIgualFilaColumna(m)){
			if (esSimetrica(eliminaFila(m))){
				return true;
			}			
		}
		return false;
	}
	
	/**
	 * Método que comprueba que la ultima fila es igual a la ultima columna
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	private boolean esIgualFilaColumna(int[][] m) {
		for (int i=0; i<m.length; i++) {
			if (m[m.length-1][i]!= m[i][m.length-1]) {
				return false;
			}
		}
		return true;
	}

	/**
	 * Método que elimina las filas de la matriz
	 * 
	 * @param m, matriz a la que eliminar las filas
	 * @return nueva matriz con las filas eliminadas
	 */
	private int[][] eliminaFila(int[][] m) {
		int [][] m2 = new int[m.length-1][m.length-1];		
		for (int i=0; i<m.length-1; i++) {
			for (int j=0; j<m.length-1; j++) {
				m2[i][j]=m[i][j];
			}
		}
		return m2;
	}
	
	/**
	 * Método que comprueba que una matriz es cuadrada
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	private boolean esCuadrada(int[][] m) {
		for (int i=0; i<m.length;i++) {
			if (m.length != m[i].length) {
				return false;
			}
		}
		return true;
	}
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-09-19 20:21:29.523
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-09-19 20:21:29.524
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2021-09-19 20:21:32.585
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package p1Algoritmia;

import java.security.InvalidParameterException;
/**
 * Titulo: Clase Algorithms
 * 
 * @author Omar Teixeira
 * @version 10/09/2021
 */
public class Algorithms {
	/**
	 * Constante Sleep Time
	 */
	private static final long SLEEP_TIME = 1;
	
	/**
	 * Método doNothing
	 */
	public static void doNothing() {
		try {
			Thread.sleep(SLEEP_TIME);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}

	/**
	 * Método que calcula el factorial de un numero mayor o igual a cero de forma recursiva
	 * 
	 * @param n, numero a calcular el factorial
	 * @return factorial
	 */
	public long factorial (int n) { // Calcula el factorial de n>=0 de forma recursiva
		doNothing();
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);		
		
		if (n==0)
			return 1;
		else
			return n*factorial(n-1);		
	} 
	
	/**
	 * Método que calcula el numero que ocupa el n introducido en la sucesión de fibonacci
	 * 
	 * @param n, numero a calcular el fibonacci
	 * @return valor fibonacci
	 */
	public int fibonacci (int n) { // Calcula el termino n-esimo teniendo en cuenta que el primer término se considera fib(0)=0; y fib(1)=1		
		if (n<0)
		throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		
		if (n==0)
			return 0;
		else if (n==1)
			return 1;
		else
			return fibonacci(n-1)+fibonacci(n-2);		
	} 
	
	/**
	 * Método que calcula la potencia recursiva 1 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec1(int n) {  // calcula 2 elevado a n de forma recursiva 2^n = 2*2^(n-1)
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		
		if (n==0)
			return 1;
		else 
			return 2*pow2Rec1(n-1);				
	} 
	
	/**
	 * Método que calcula la potencia iterativa de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Iter (int n) {  // calcula 2 elevado a n de forma iterativa 
	    if (n<0)
	    	throw new InvalidParameterException("No permitidos exponentes negativos como "+ n); 
	    
	    long pow=2;
	    for (int i=0; i<=n;i++) {
	    	doNothing();
	    	pow=2*pow;
	    }	    
	    return pow; 
	} 

	/**
	 * Método que calcula la potencia recursiva 2 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec2 (int n) { // calcula 2 elevado a n de forma recursiva 2^n = 2^(n-1)+2^(n-1) 
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		if (n==0)
			return 1;
		else 
			return pow2Rec2(n-1) + pow2Rec2(n-1);
	} 
	
	/**
	 * Método que calcula la potencia recursiva 3 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec3 (int n) { // calcula 2 elevado a n de forma recursiva 2^n = 2^(n/2)*2^(n/2) si n par y *2 si es impar 
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		if (n==0)
			return 1;
		else if (n%2==0)
			return pow2Rec3(n/2)*pow2Rec3(n/2);
		else 
			return pow2Rec3(n/2)*pow2Rec3(n/2)*2; 
	} 
	
	/**
	 * Método que calcula la potencia recursiva 4 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec4 (int n) {  // calcula 2 elevado a n de forma recursiva 2^n = como pow2Rec3 pero sin repetir llamada 
		doNothing();
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		if (n==0) {
			return 1;
		} else { 
			if (n%2==0) {
				long res = pow2Rec4(n/2);
				return res*res;
			}
			else { 
				long res = pow2Rec4(n/2);
				return 2*res*res;
			}
		}	
		} 
	  
	/**
	 * Método que calcula la potencia de un numero a elevado al numero introducido b
	 * 
	 * @param a, base
	 * @param b, exponente
	 * @return potencia de la base elevada al exponente
	 */
	public long potenciaRec(int a, int b) { // Calcula a elevado a b de forma recursiva por potencias sucesivas 
		if (a<0 || b<0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido"); 
		
		if(a==1 || b==0)
			return 1;
		else			
			return a*potenciaRec(a,b-1);
		 
	}
	
	/**
	 * Método que calcula el resto de la división de dos numeros
	 * 
	 * @param a, dividendo
	 * @param b, divisor
	 * @return resto
	 */
	public int restoDivRec (int a, int b) {  // calcula el resto de la división a/b de forma recursiva 
		if (a<0 || b<=0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido");
		
		if (a<b)
			return a;
		else
			return restoDivRec(a-b,b);		
	} 
	
	/**
	 * Método que calcula la división entera de dos numeros
	 * 
	 * @param a, dividendo
	 * @param b, divisor
	 * @return division entera
	 */
	public int divEntRec (int a, int b) {  // calcula la división entera a/b de forma recursiva 
		if (a<0 || b<=0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido");		
		
		if (a<b)
			return 0;
		else
			return 1+divEntRec(a-b,b);		
	} 
	
	/**
	 * Método que invierte un numero entero de forma recursiva
	 * 
	 * @param n, numero a invertir
	 * @return numero invertido
	 */
	public int invertirEnteroRec(int n) {  // Invierte un entero invertirEnteroRec(1234)=4321 de forma recursiva
		if (n<10)
			return n;
		else			
			return (n%10) * (int)Math.pow(10, Integer.toString(n/10).length())+ invertirEnteroRec(n/10);
	} 

	/**
	 * Método que invierte un string de forma recursiva
	 * 
	 * @param l, string a invertir
	 * @return string invertido
	 */
	public String invertirStringRec(String l) { // Invierte un string de forma recursiva invertirStringRec("abc")="cba" 
		if (l.length()==1)
			return l;
		else
			return invertirStringRec(l.substring(1)) + l.charAt(0);
	}
	  
	/**
	 * Método que tiene una complejidad temporal lineal
	 * 
	 * @param n, parametro
	 */
	public void linear (int n) { // Algoritmo con una complejidad temporal lineal 
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		for (int i=0; i<=n; i++) {
			doNothing();
			System.out.println("El algoritmo se ha ejecutado: " + i + " vez/veces");
		}
	} 

	/**
	 * Método que tiene una complejidad temporal lineal
	 * 
	 * @param n, parametro
	 */
	public void quadratic(int n) { // Algoritmo con una complejidad temporal cuadrática 
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		for (int i=0; i<=n; i++) {
			for (int j=0; j<=n;j++) {
				doNothing();
				System.out.println("El algoritmo se ha ejecutado: " + j + " vez/veces");
			}
			System.out.println("--------"+i+"---------");
		}
	} 

	  

	public void cubic(int n) { // Algoritmo con una complejidad temporal cúbica 
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		for (int i=0; i<=n; i++) {
			for (int j=0; j<=n;j++) {
				for (int k=0; k<=n;k++) {
					doNothing();
					("El algoritmo se ha ejecutado: " + k + " vez/veces");
				}
				System.out.println("--------"+j+"---------");
			}
			System.out.println("~~~~~~~~"+j+"---------");
		}

	} 

	  

	public void logarithmic(int n) { // Algoritmo con una complejidad temporal logarítmica en cualquier base 

	if (n<0) 

	throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 

	} 	

	/**
	 * Método que comprueba si una matriz cuadrada es simetrica 
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	public boolean esSimetrica(int[][] m) { // Indica si es simétrica una matriz cuadrada de forma recursiva
		if (m.length == 1 && m[0].length == 1) {
			return true;
		} else if (!esCuadrada(m)) {
			return false;
		} else if (esIgualFilaColumna(m)){
			if (esSimetrica(eliminaFila(m))){
				return true;
			}			
		}
		return false;
	}
	
	/**
	 * Método que comprueba que la ultima fila es igual a la ultima columna
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	private boolean esIgualFilaColumna(int[][] m) {
		for (int i=0; i<m.length; i++) {
			if (m[m.length-1][i]!= m[i][m.length-1]) {
				return false;
			}
		}
		return true;
	}

	/**
	 * Método que elimina las filas de la matriz
	 * 
	 * @param m, matriz a la que eliminar las filas
	 * @return nueva matriz con las filas eliminadas
	 */
	private int[][] eliminaFila(int[][] m) {
		int [][] m2 = new int[m.length-1][m.length-1];		
		for (int i=0; i<m.length-1; i++) {
			for (int j=0; j<m.length-1; j++) {
				m2[i][j]=m[i][j];
			}
		}
		return m2;
	}
	
	/**
	 * Método que comprueba que una matriz es cuadrada
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	private boolean esCuadrada(int[][] m) {
		for (int i=0; i<m.length;i++) {
			if (m.length != m[i].length) {
				return false;
			}
		}
		return true;
	}
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:439)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:366)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:326)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:276)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at jdk.internal.reflect.GeneratedMethodAccessor50.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:319)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:253)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:487)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:584)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:653)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:443)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1270)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1042)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1067)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1052)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1094)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1519)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4882)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4760)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4930)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3624)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-09-19 20:21:32.587
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:439)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:366)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:326)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:276)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at jdk.internal.reflect.GeneratedMethodAccessor50.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:319)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:253)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:487)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:584)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:653)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:443)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1270)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1042)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1067)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1052)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1094)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1519)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4882)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4760)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4930)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3624)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-09-19 20:21:32.588
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:439)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:366)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:326)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:276)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at jdk.internal.reflect.GeneratedMethodAccessor50.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:319)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:253)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:487)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:584)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:653)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:443)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1270)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1042)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1067)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1052)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1094)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1519)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4882)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4760)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4930)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3624)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.jdt.core 4 4 2021-09-19 20:21:32.790
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package p1Algoritmia;

import java.security.InvalidParameterException;
/**
 * Titulo: Clase Algorithms
 * 
 * @author Omar Teixeira
 * @version 10/09/2021
 */
public class Algorithms {
	/**
	 * Constante Sleep Time
	 */
	private static final long SLEEP_TIME = 1;
	
	/**
	 * Método doNothing
	 */
	public static void doNothing() {
		try {
			Thread.sleep(SLEEP_TIME);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}

	/**
	 * Método que calcula el factorial de un numero mayor o igual a cero de forma recursiva
	 * 
	 * @param n, numero a calcular el factorial
	 * @return factorial
	 */
	public long factorial (int n) { // Calcula el factorial de n>=0 de forma recursiva
		doNothing();
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);		
		
		if (n==0)
			return 1;
		else
			return n*factorial(n-1);		
	} 
	
	/**
	 * Método que calcula el numero que ocupa el n introducido en la sucesión de fibonacci
	 * 
	 * @param n, numero a calcular el fibonacci
	 * @return valor fibonacci
	 */
	public int fibonacci (int n) { // Calcula el termino n-esimo teniendo en cuenta que el primer término se considera fib(0)=0; y fib(1)=1		
		if (n<0)
		throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		
		if (n==0)
			return 0;
		else if (n==1)
			return 1;
		else
			return fibonacci(n-1)+fibonacci(n-2);		
	} 
	
	/**
	 * Método que calcula la potencia recursiva 1 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec1(int n) {  // calcula 2 elevado a n de forma recursiva 2^n = 2*2^(n-1)
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		
		if (n==0)
			return 1;
		else 
			return 2*pow2Rec1(n-1);				
	} 
	
	/**
	 * Método que calcula la potencia iterativa de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Iter (int n) {  // calcula 2 elevado a n de forma iterativa 
	    if (n<0)
	    	throw new InvalidParameterException("No permitidos exponentes negativos como "+ n); 
	    
	    long pow=2;
	    for (int i=0; i<=n;i++) {
	    	doNothing();
	    	pow=2*pow;
	    }	    
	    return pow; 
	} 

	/**
	 * Método que calcula la potencia recursiva 2 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec2 (int n) { // calcula 2 elevado a n de forma recursiva 2^n = 2^(n-1)+2^(n-1) 
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		if (n==0)
			return 1;
		else 
			return pow2Rec2(n-1) + pow2Rec2(n-1);
	} 
	
	/**
	 * Método que calcula la potencia recursiva 3 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec3 (int n) { // calcula 2 elevado a n de forma recursiva 2^n = 2^(n/2)*2^(n/2) si n par y *2 si es impar 
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		if (n==0)
			return 1;
		else if (n%2==0)
			return pow2Rec3(n/2)*pow2Rec3(n/2);
		else 
			return pow2Rec3(n/2)*pow2Rec3(n/2)*2; 
	} 
	
	/**
	 * Método que calcula la potencia recursiva 4 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec4 (int n) {  // calcula 2 elevado a n de forma recursiva 2^n = como pow2Rec3 pero sin repetir llamada 
		doNothing();
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		if (n==0) {
			return 1;
		} else { 
			if (n%2==0) {
				long res = pow2Rec4(n/2);
				return res*res;
			}
			else { 
				long res = pow2Rec4(n/2);
				return 2*res*res;
			}
		}	
		} 
	  
	/**
	 * Método que calcula la potencia de un numero a elevado al numero introducido b
	 * 
	 * @param a, base
	 * @param b, exponente
	 * @return potencia de la base elevada al exponente
	 */
	public long potenciaRec(int a, int b) { // Calcula a elevado a b de forma recursiva por potencias sucesivas 
		if (a<0 || b<0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido"); 
		
		if(a==1 || b==0)
			return 1;
		else			
			return a*potenciaRec(a,b-1);
		 
	}
	
	/**
	 * Método que calcula el resto de la división de dos numeros
	 * 
	 * @param a, dividendo
	 * @param b, divisor
	 * @return resto
	 */
	public int restoDivRec (int a, int b) {  // calcula el resto de la división a/b de forma recursiva 
		if (a<0 || b<=0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido");
		
		if (a<b)
			return a;
		else
			return restoDivRec(a-b,b);		
	} 
	
	/**
	 * Método que calcula la división entera de dos numeros
	 * 
	 * @param a, dividendo
	 * @param b, divisor
	 * @return division entera
	 */
	public int divEntRec (int a, int b) {  // calcula la división entera a/b de forma recursiva 
		if (a<0 || b<=0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido");		
		
		if (a<b)
			return 0;
		else
			return 1+divEntRec(a-b,b);		
	} 
	
	/**
	 * Método que invierte un numero entero de forma recursiva
	 * 
	 * @param n, numero a invertir
	 * @return numero invertido
	 */
	public int invertirEnteroRec(int n) {  // Invierte un entero invertirEnteroRec(1234)=4321 de forma recursiva
		if (n<10)
			return n;
		else			
			return (n%10) * (int)Math.pow(10, Integer.toString(n/10).length())+ invertirEnteroRec(n/10);
	} 

	/**
	 * Método que invierte un string de forma recursiva
	 * 
	 * @param l, string a invertir
	 * @return string invertido
	 */
	public String invertirStringRec(String l) { // Invierte un string de forma recursiva invertirStringRec("abc")="cba" 
		if (l.length()==1)
			return l;
		else
			return invertirStringRec(l.substring(1)) + l.charAt(0);
	}
	  
	/**
	 * Método que tiene una complejidad temporal lineal
	 * 
	 * @param n, parametro
	 */
	public void linear (int n) { // Algoritmo con una complejidad temporal lineal 
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		for (int i=0; i<=n; i++) {
			doNothing();
			System.out.println("El algoritmo se ha ejecutado: " + i + " vez/veces");
		}
	} 

	/**
	 * Método que tiene una complejidad temporal lineal
	 * 
	 * @param n, parametro
	 */
	public void quadratic(int n) { // Algoritmo con una complejidad temporal cuadrática 
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		for (int i=0; i<=n; i++) {
			for (int j=0; j<=n;j++) {
				doNothing();
				System.out.println("El algoritmo se ha ejecutado: " + j + " vez/veces");
			}
			System.out.println("--------"+i+"---------");
		}
	} 

	  

	public void cubic(int n) { // Algoritmo con una complejidad temporal cúbica 
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		for (int i=0; i<=n; i++) {
			for (int j=0; j<=n;j++) {
				for (int k=0; k<=n;k++) {
					doNothing();
					("El algoritmo se ha ejecutado: " + k + " vez/veces");
				}
				System.out.println("--------"+j+"---------");
			}
			System.out.println("~~~~~~~~"+j+"---------");
		}

	} 

	  

	public void logarithmic(int n) { // Algoritmo con una complejidad temporal logarítmica en cualquier base 

	if (n<0) 

	throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 

	} 	

	/**
	 * Método que comprueba si una matriz cuadrada es simetrica 
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	public boolean esSimetrica(int[][] m) { // Indica si es simétrica una matriz cuadrada de forma recursiva
		if (m.length == 1 && m[0].length == 1) {
			return true;
		} else if (!esCuadrada(m)) {
			return false;
		} else if (esIgualFilaColumna(m)){
			if (esSimetrica(eliminaFila(m))){
				return true;
			}			
		}
		return false;
	}
	
	/**
	 * Método que comprueba que la ultima fila es igual a la ultima columna
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	private boolean esIgualFilaColumna(int[][] m) {
		for (int i=0; i<m.length; i++) {
			if (m[m.length-1][i]!= m[i][m.length-1]) {
				return false;
			}
		}
		return true;
	}

	/**
	 * Método que elimina las filas de la matriz
	 * 
	 * @param m, matriz a la que eliminar las filas
	 * @return nueva matriz con las filas eliminadas
	 */
	private int[][] eliminaFila(int[][] m) {
		int [][] m2 = new int[m.length-1][m.length-1];		
		for (int i=0; i<m.length-1; i++) {
			for (int j=0; j<m.length-1; j++) {
				m2[i][j]=m[i][j];
			}
		}
		return m2;
	}
	
	/**
	 * Método que comprueba que una matriz es cuadrada
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	private boolean esCuadrada(int[][] m) {
		for (int i=0; i<m.length;i++) {
			if (m.length != m[i].length) {
				return false;
			}
		}
		return true;
	}
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-09-19 20:21:32.792
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-09-19 20:21:32.793
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-09-19 20:21:35.639
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package p1Algoritmia;

import java.security.InvalidParameterException;
/**
 * Titulo: Clase Algorithms
 * 
 * @author Omar Teixeira
 * @version 10/09/2021
 */
public class Algorithms {
	/**
	 * Constante Sleep Time
	 */
	private static final long SLEEP_TIME = 1;
	
	/**
	 * Método doNothing
	 */
	public static void doNothing() {
		try {
			Thread.sleep(SLEEP_TIME);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}

	/**
	 * Método que calcula el factorial de un numero mayor o igual a cero de forma recursiva
	 * 
	 * @param n, numero a calcular el factorial
	 * @return factorial
	 */
	public long factorial (int n) { // Calcula el factorial de n>=0 de forma recursiva
		doNothing();
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);		
		
		if (n==0)
			return 1;
		else
			return n*factorial(n-1);		
	} 
	
	/**
	 * Método que calcula el numero que ocupa el n introducido en la sucesión de fibonacci
	 * 
	 * @param n, numero a calcular el fibonacci
	 * @return valor fibonacci
	 */
	public int fibonacci (int n) { // Calcula el termino n-esimo teniendo en cuenta que el primer término se considera fib(0)=0; y fib(1)=1		
		if (n<0)
		throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		
		if (n==0)
			return 0;
		else if (n==1)
			return 1;
		else
			return fibonacci(n-1)+fibonacci(n-2);		
	} 
	
	/**
	 * Método que calcula la potencia recursiva 1 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec1(int n) {  // calcula 2 elevado a n de forma recursiva 2^n = 2*2^(n-1)
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		
		if (n==0)
			return 1;
		else 
			return 2*pow2Rec1(n-1);				
	} 
	
	/**
	 * Método que calcula la potencia iterativa de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Iter (int n) {  // calcula 2 elevado a n de forma iterativa 
	    if (n<0)
	    	throw new InvalidParameterException("No permitidos exponentes negativos como "+ n); 
	    
	    long pow=2;
	    for (int i=0; i<=n;i++) {
	    	doNothing();
	    	pow=2*pow;
	    }	    
	    return pow; 
	} 

	/**
	 * Método que calcula la potencia recursiva 2 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec2 (int n) { // calcula 2 elevado a n de forma recursiva 2^n = 2^(n-1)+2^(n-1) 
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		if (n==0)
			return 1;
		else 
			return pow2Rec2(n-1) + pow2Rec2(n-1);
	} 
	
	/**
	 * Método que calcula la potencia recursiva 3 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec3 (int n) { // calcula 2 elevado a n de forma recursiva 2^n = 2^(n/2)*2^(n/2) si n par y *2 si es impar 
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		if (n==0)
			return 1;
		else if (n%2==0)
			return pow2Rec3(n/2)*pow2Rec3(n/2);
		else 
			return pow2Rec3(n/2)*pow2Rec3(n/2)*2; 
	} 
	
	/**
	 * Método que calcula la potencia recursiva 4 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec4 (int n) {  // calcula 2 elevado a n de forma recursiva 2^n = como pow2Rec3 pero sin repetir llamada 
		doNothing();
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		if (n==0) {
			return 1;
		} else { 
			if (n%2==0) {
				long res = pow2Rec4(n/2);
				return res*res;
			}
			else { 
				long res = pow2Rec4(n/2);
				return 2*res*res;
			}
		}	
		} 
	  
	/**
	 * Método que calcula la potencia de un numero a elevado al numero introducido b
	 * 
	 * @param a, base
	 * @param b, exponente
	 * @return potencia de la base elevada al exponente
	 */
	public long potenciaRec(int a, int b) { // Calcula a elevado a b de forma recursiva por potencias sucesivas 
		if (a<0 || b<0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido"); 
		
		if(a==1 || b==0)
			return 1;
		else			
			return a*potenciaRec(a,b-1);
		 
	}
	
	/**
	 * Método que calcula el resto de la división de dos numeros
	 * 
	 * @param a, dividendo
	 * @param b, divisor
	 * @return resto
	 */
	public int restoDivRec (int a, int b) {  // calcula el resto de la división a/b de forma recursiva 
		if (a<0 || b<=0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido");
		
		if (a<b)
			return a;
		else
			return restoDivRec(a-b,b);		
	} 
	
	/**
	 * Método que calcula la división entera de dos numeros
	 * 
	 * @param a, dividendo
	 * @param b, divisor
	 * @return division entera
	 */
	public int divEntRec (int a, int b) {  // calcula la división entera a/b de forma recursiva 
		if (a<0 || b<=0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido");		
		
		if (a<b)
			return 0;
		else
			return 1+divEntRec(a-b,b);		
	} 
	
	/**
	 * Método que invierte un numero entero de forma recursiva
	 * 
	 * @param n, numero a invertir
	 * @return numero invertido
	 */
	public int invertirEnteroRec(int n) {  // Invierte un entero invertirEnteroRec(1234)=4321 de forma recursiva
		if (n<10)
			return n;
		else			
			return (n%10) * (int)Math.pow(10, Integer.toString(n/10).length())+ invertirEnteroRec(n/10);
	} 

	/**
	 * Método que invierte un string de forma recursiva
	 * 
	 * @param l, string a invertir
	 * @return string invertido
	 */
	public String invertirStringRec(String l) { // Invierte un string de forma recursiva invertirStringRec("abc")="cba" 
		if (l.length()==1)
			return l;
		else
			return invertirStringRec(l.substring(1)) + l.charAt(0);
	}
	  
	/**
	 * Método que tiene una complejidad temporal lineal
	 * 
	 * @param n, parametro
	 */
	public void linear (int n) { // Algoritmo con una complejidad temporal lineal 
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		for (int i=0; i<=n; i++) {
			doNothing();
			System.out.println("El algoritmo se ha ejecutado: " + i + " vez/veces");
		}
	} 

	/**
	 * Método que tiene una complejidad temporal lineal
	 * 
	 * @param n, parametro
	 */
	public void quadratic(int n) { // Algoritmo con una complejidad temporal cuadrática 
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		for (int i=0; i<=n; i++) {
			for (int j=0; j<=n;j++) {
				doNothing();
				System.out.println("El algoritmo se ha ejecutado: " + j + " vez/veces");
			}
			System.out.println("--------"+i+"---------");
		}
	} 

	  

	public void cubic(int n) { // Algoritmo con una complejidad temporal cúbica 
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		for (int i=0; i<=n; i++) {
			for (int j=0; j<=n;j++) {
				for (int k=0; k<=n;k++) {
					doNothing();
					("El algoritmo se ha ejecutado: " + k + " vez/veces");
				}
				System.out.println("--------"+j+"---------");
			}
			System.out.println("~~~~~~~~"+j+"~~~~~~~~");
		}

	} 

	  

	public void logarithmic(int n) { // Algoritmo con una complejidad temporal logarítmica en cualquier base 

	if (n<0) 

	throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 

	} 	

	/**
	 * Método que comprueba si una matriz cuadrada es simetrica 
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	public boolean esSimetrica(int[][] m) { // Indica si es simétrica una matriz cuadrada de forma recursiva
		if (m.length == 1 && m[0].length == 1) {
			return true;
		} else if (!esCuadrada(m)) {
			return false;
		} else if (esIgualFilaColumna(m)){
			if (esSimetrica(eliminaFila(m))){
				return true;
			}			
		}
		return false;
	}
	
	/**
	 * Método que comprueba que la ultima fila es igual a la ultima columna
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	private boolean esIgualFilaColumna(int[][] m) {
		for (int i=0; i<m.length; i++) {
			if (m[m.length-1][i]!= m[i][m.length-1]) {
				return false;
			}
		}
		return true;
	}

	/**
	 * Método que elimina las filas de la matriz
	 * 
	 * @param m, matriz a la que eliminar las filas
	 * @return nueva matriz con las filas eliminadas
	 */
	private int[][] eliminaFila(int[][] m) {
		int [][] m2 = new int[m.length-1][m.length-1];		
		for (int i=0; i<m.length-1; i++) {
			for (int j=0; j<m.length-1; j++) {
				m2[i][j]=m[i][j];
			}
		}
		return m2;
	}
	
	/**
	 * Método que comprueba que una matriz es cuadrada
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	private boolean esCuadrada(int[][] m) {
		for (int i=0; i<m.length;i++) {
			if (m.length != m[i].length) {
				return false;
			}
		}
		return true;
	}
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-09-19 20:21:35.640
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-09-19 20:21:35.642
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-09-19 20:21:35.646
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package p1Algoritmia;

import java.security.InvalidParameterException;
/**
 * Titulo: Clase Algorithms
 * 
 * @author Omar Teixeira
 * @version 10/09/2021
 */
public class Algorithms {
	/**
	 * Constante Sleep Time
	 */
	private static final long SLEEP_TIME = 1;
	
	/**
	 * Método doNothing
	 */
	public static void doNothing() {
		try {
			Thread.sleep(SLEEP_TIME);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}

	/**
	 * Método que calcula el factorial de un numero mayor o igual a cero de forma recursiva
	 * 
	 * @param n, numero a calcular el factorial
	 * @return factorial
	 */
	public long factorial (int n) { // Calcula el factorial de n>=0 de forma recursiva
		doNothing();
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);		
		
		if (n==0)
			return 1;
		else
			return n*factorial(n-1);		
	} 
	
	/**
	 * Método que calcula el numero que ocupa el n introducido en la sucesión de fibonacci
	 * 
	 * @param n, numero a calcular el fibonacci
	 * @return valor fibonacci
	 */
	public int fibonacci (int n) { // Calcula el termino n-esimo teniendo en cuenta que el primer término se considera fib(0)=0; y fib(1)=1		
		if (n<0)
		throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		
		if (n==0)
			return 0;
		else if (n==1)
			return 1;
		else
			return fibonacci(n-1)+fibonacci(n-2);		
	} 
	
	/**
	 * Método que calcula la potencia recursiva 1 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec1(int n) {  // calcula 2 elevado a n de forma recursiva 2^n = 2*2^(n-1)
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		
		if (n==0)
			return 1;
		else 
			return 2*pow2Rec1(n-1);				
	} 
	
	/**
	 * Método que calcula la potencia iterativa de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Iter (int n) {  // calcula 2 elevado a n de forma iterativa 
	    if (n<0)
	    	throw new InvalidParameterException("No permitidos exponentes negativos como "+ n); 
	    
	    long pow=2;
	    for (int i=0; i<=n;i++) {
	    	doNothing();
	    	pow=2*pow;
	    }	    
	    return pow; 
	} 

	/**
	 * Método que calcula la potencia recursiva 2 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec2 (int n) { // calcula 2 elevado a n de forma recursiva 2^n = 2^(n-1)+2^(n-1) 
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		if (n==0)
			return 1;
		else 
			return pow2Rec2(n-1) + pow2Rec2(n-1);
	} 
	
	/**
	 * Método que calcula la potencia recursiva 3 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec3 (int n) { // calcula 2 elevado a n de forma recursiva 2^n = 2^(n/2)*2^(n/2) si n par y *2 si es impar 
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		if (n==0)
			return 1;
		else if (n%2==0)
			return pow2Rec3(n/2)*pow2Rec3(n/2);
		else 
			return pow2Rec3(n/2)*pow2Rec3(n/2)*2; 
	} 
	
	/**
	 * Método que calcula la potencia recursiva 4 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec4 (int n) {  // calcula 2 elevado a n de forma recursiva 2^n = como pow2Rec3 pero sin repetir llamada 
		doNothing();
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		if (n==0) {
			return 1;
		} else { 
			if (n%2==0) {
				long res = pow2Rec4(n/2);
				return res*res;
			}
			else { 
				long res = pow2Rec4(n/2);
				return 2*res*res;
			}
		}	
		} 
	  
	/**
	 * Método que calcula la potencia de un numero a elevado al numero introducido b
	 * 
	 * @param a, base
	 * @param b, exponente
	 * @return potencia de la base elevada al exponente
	 */
	public long potenciaRec(int a, int b) { // Calcula a elevado a b de forma recursiva por potencias sucesivas 
		if (a<0 || b<0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido"); 
		
		if(a==1 || b==0)
			return 1;
		else			
			return a*potenciaRec(a,b-1);
		 
	}
	
	/**
	 * Método que calcula el resto de la división de dos numeros
	 * 
	 * @param a, dividendo
	 * @param b, divisor
	 * @return resto
	 */
	public int restoDivRec (int a, int b) {  // calcula el resto de la división a/b de forma recursiva 
		if (a<0 || b<=0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido");
		
		if (a<b)
			return a;
		else
			return restoDivRec(a-b,b);		
	} 
	
	/**
	 * Método que calcula la división entera de dos numeros
	 * 
	 * @param a, dividendo
	 * @param b, divisor
	 * @return division entera
	 */
	public int divEntRec (int a, int b) {  // calcula la división entera a/b de forma recursiva 
		if (a<0 || b<=0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido");		
		
		if (a<b)
			return 0;
		else
			return 1+divEntRec(a-b,b);		
	} 
	
	/**
	 * Método que invierte un numero entero de forma recursiva
	 * 
	 * @param n, numero a invertir
	 * @return numero invertido
	 */
	public int invertirEnteroRec(int n) {  // Invierte un entero invertirEnteroRec(1234)=4321 de forma recursiva
		if (n<10)
			return n;
		else			
			return (n%10) * (int)Math.pow(10, Integer.toString(n/10).length())+ invertirEnteroRec(n/10);
	} 

	/**
	 * Método que invierte un string de forma recursiva
	 * 
	 * @param l, string a invertir
	 * @return string invertido
	 */
	public String invertirStringRec(String l) { // Invierte un string de forma recursiva invertirStringRec("abc")="cba" 
		if (l.length()==1)
			return l;
		else
			return invertirStringRec(l.substring(1)) + l.charAt(0);
	}
	  
	/**
	 * Método que tiene una complejidad temporal lineal
	 * 
	 * @param n, parametro
	 */
	public void linear (int n) { // Algoritmo con una complejidad temporal lineal 
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		for (int i=0; i<=n; i++) {
			doNothing();
			System.out.println("El algoritmo se ha ejecutado: " + i + " vez/veces");
		}
	} 

	/**
	 * Método que tiene una complejidad temporal lineal
	 * 
	 * @param n, parametro
	 */
	public void quadratic(int n) { // Algoritmo con una complejidad temporal cuadrática 
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		for (int i=0; i<=n; i++) {
			for (int j=0; j<=n;j++) {
				doNothing();
				System.out.println("El algoritmo se ha ejecutado: " + j + " vez/veces");
			}
			System.out.println("--------"+i+"---------");
		}
	} 

	  

	public void cubic(int n) { // Algoritmo con una complejidad temporal cúbica 
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		for (int i=0; i<=n; i++) {
			for (int j=0; j<=n;j++) {
				for (int k=0; k<=n;k++) {
					doNothing();
					("El algoritmo se ha ejecutado: " + k + " vez/veces");
				}
				System.out.println("--------"+j+"---------");
			}
			System.out.println("~~~~~~~~"+j+"~~~~~~~~");
		}

	} 

	  

	public void logarithmic(int n) { // Algoritmo con una complejidad temporal logarítmica en cualquier base 

	if (n<0) 

	throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 

	} 	

	/**
	 * Método que comprueba si una matriz cuadrada es simetrica 
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	public boolean esSimetrica(int[][] m) { // Indica si es simétrica una matriz cuadrada de forma recursiva
		if (m.length == 1 && m[0].length == 1) {
			return true;
		} else if (!esCuadrada(m)) {
			return false;
		} else if (esIgualFilaColumna(m)){
			if (esSimetrica(eliminaFila(m))){
				return true;
			}			
		}
		return false;
	}
	
	/**
	 * Método que comprueba que la ultima fila es igual a la ultima columna
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	private boolean esIgualFilaColumna(int[][] m) {
		for (int i=0; i<m.length; i++) {
			if (m[m.length-1][i]!= m[i][m.length-1]) {
				return false;
			}
		}
		return true;
	}

	/**
	 * Método que elimina las filas de la matriz
	 * 
	 * @param m, matriz a la que eliminar las filas
	 * @return nueva matriz con las filas eliminadas
	 */
	private int[][] eliminaFila(int[][] m) {
		int [][] m2 = new int[m.length-1][m.length-1];		
		for (int i=0; i<m.length-1; i++) {
			for (int j=0; j<m.length-1; j++) {
				m2[i][j]=m[i][j];
			}
		}
		return m2;
	}
	
	/**
	 * Método que comprueba que una matriz es cuadrada
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	private boolean esCuadrada(int[][] m) {
		for (int i=0; i<m.length;i++) {
			if (m.length != m[i].length) {
				return false;
			}
		}
		return true;
	}
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-09-19 20:21:35.647
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-09-19 20:21:35.648
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-09-19 20:21:37.344
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package p1Algoritmia;

import java.security.InvalidParameterException;
/**
 * Titulo: Clase Algorithms
 * 
 * @author Omar Teixeira
 * @version 10/09/2021
 */
public class Algorithms {
	/**
	 * Constante Sleep Time
	 */
	private static final long SLEEP_TIME = 1;
	
	/**
	 * Método doNothing
	 */
	public static void doNothing() {
		try {
			Thread.sleep(SLEEP_TIME);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}

	/**
	 * Método que calcula el factorial de un numero mayor o igual a cero de forma recursiva
	 * 
	 * @param n, numero a calcular el factorial
	 * @return factorial
	 */
	public long factorial (int n) { // Calcula el factorial de n>=0 de forma recursiva
		doNothing();
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);		
		
		if (n==0)
			return 1;
		else
			return n*factorial(n-1);		
	} 
	
	/**
	 * Método que calcula el numero que ocupa el n introducido en la sucesión de fibonacci
	 * 
	 * @param n, numero a calcular el fibonacci
	 * @return valor fibonacci
	 */
	public int fibonacci (int n) { // Calcula el termino n-esimo teniendo en cuenta que el primer término se considera fib(0)=0; y fib(1)=1		
		if (n<0)
		throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		
		if (n==0)
			return 0;
		else if (n==1)
			return 1;
		else
			return fibonacci(n-1)+fibonacci(n-2);		
	} 
	
	/**
	 * Método que calcula la potencia recursiva 1 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec1(int n) {  // calcula 2 elevado a n de forma recursiva 2^n = 2*2^(n-1)
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		
		if (n==0)
			return 1;
		else 
			return 2*pow2Rec1(n-1);				
	} 
	
	/**
	 * Método que calcula la potencia iterativa de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Iter (int n) {  // calcula 2 elevado a n de forma iterativa 
	    if (n<0)
	    	throw new InvalidParameterException("No permitidos exponentes negativos como "+ n); 
	    
	    long pow=2;
	    for (int i=0; i<=n;i++) {
	    	doNothing();
	    	pow=2*pow;
	    }	    
	    return pow; 
	} 

	/**
	 * Método que calcula la potencia recursiva 2 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec2 (int n) { // calcula 2 elevado a n de forma recursiva 2^n = 2^(n-1)+2^(n-1) 
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		if (n==0)
			return 1;
		else 
			return pow2Rec2(n-1) + pow2Rec2(n-1);
	} 
	
	/**
	 * Método que calcula la potencia recursiva 3 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec3 (int n) { // calcula 2 elevado a n de forma recursiva 2^n = 2^(n/2)*2^(n/2) si n par y *2 si es impar 
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		if (n==0)
			return 1;
		else if (n%2==0)
			return pow2Rec3(n/2)*pow2Rec3(n/2);
		else 
			return pow2Rec3(n/2)*pow2Rec3(n/2)*2; 
	} 
	
	/**
	 * Método que calcula la potencia recursiva 4 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec4 (int n) {  // calcula 2 elevado a n de forma recursiva 2^n = como pow2Rec3 pero sin repetir llamada 
		doNothing();
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		if (n==0) {
			return 1;
		} else { 
			if (n%2==0) {
				long res = pow2Rec4(n/2);
				return res*res;
			}
			else { 
				long res = pow2Rec4(n/2);
				return 2*res*res;
			}
		}	
		} 
	  
	/**
	 * Método que calcula la potencia de un numero a elevado al numero introducido b
	 * 
	 * @param a, base
	 * @param b, exponente
	 * @return potencia de la base elevada al exponente
	 */
	public long potenciaRec(int a, int b) { // Calcula a elevado a b de forma recursiva por potencias sucesivas 
		if (a<0 || b<0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido"); 
		
		if(a==1 || b==0)
			return 1;
		else			
			return a*potenciaRec(a,b-1);
		 
	}
	
	/**
	 * Método que calcula el resto de la división de dos numeros
	 * 
	 * @param a, dividendo
	 * @param b, divisor
	 * @return resto
	 */
	public int restoDivRec (int a, int b) {  // calcula el resto de la división a/b de forma recursiva 
		if (a<0 || b<=0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido");
		
		if (a<b)
			return a;
		else
			return restoDivRec(a-b,b);		
	} 
	
	/**
	 * Método que calcula la división entera de dos numeros
	 * 
	 * @param a, dividendo
	 * @param b, divisor
	 * @return division entera
	 */
	public int divEntRec (int a, int b) {  // calcula la división entera a/b de forma recursiva 
		if (a<0 || b<=0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido");		
		
		if (a<b)
			return 0;
		else
			return 1+divEntRec(a-b,b);		
	} 
	
	/**
	 * Método que invierte un numero entero de forma recursiva
	 * 
	 * @param n, numero a invertir
	 * @return numero invertido
	 */
	public int invertirEnteroRec(int n) {  // Invierte un entero invertirEnteroRec(1234)=4321 de forma recursiva
		if (n<10)
			return n;
		else			
			return (n%10) * (int)Math.pow(10, Integer.toString(n/10).length())+ invertirEnteroRec(n/10);
	} 

	/**
	 * Método que invierte un string de forma recursiva
	 * 
	 * @param l, string a invertir
	 * @return string invertido
	 */
	public String invertirStringRec(String l) { // Invierte un string de forma recursiva invertirStringRec("abc")="cba" 
		if (l.length()==1)
			return l;
		else
			return invertirStringRec(l.substring(1)) + l.charAt(0);
	}
	  
	/**
	 * Método que tiene una complejidad temporal lineal
	 * 
	 * @param n, parametro
	 */
	public void linear (int n) { // Algoritmo con una complejidad temporal lineal 
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		for (int i=0; i<=n; i++) {
			doNothing();
			System.out.println("El algoritmo se ha ejecutado: " + i + " vez/veces");
		}
	} 

	/**
	 * Método que tiene una complejidad temporal lineal
	 * 
	 * @param n, parametro
	 */
	public void quadratic(int n) { // Algoritmo con una complejidad temporal cuadrática 
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		for (int i=0; i<=n; i++) {
			for (int j=0; j<=n;j++) {
				doNothing();
				System.out.println("El algoritmo se ha ejecutado: " + j + " vez/veces");
			}
			System.out.println("--------"+i+"---------");
		}
	} 

	  

	public void cubic(int n) { // Algoritmo con una complejidad temporal cúbica 
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		for (int i=0; i<=n; i++) {
			for (int j=0; j<=n;j++) {
				for (int k=0; k<=n;k++) {
					doNothing();
					("El algoritmo se ha ejecutado: " + k + " vez/veces");
				}
				System.out.println("--------"+j+"---------");
			}
			System.out.println("~~~~~~~~"+j+"~~~~~~~~");
		}

	} 

	  

	public void logarithmic(int n) { // Algoritmo con una complejidad temporal logarítmica en cualquier base 

	if (n<0) 

	throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 

	} 	

	/**
	 * Método que comprueba si una matriz cuadrada es simetrica 
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	public boolean esSimetrica(int[][] m) { // Indica si es simétrica una matriz cuadrada de forma recursiva
		if (m.length == 1 && m[0].length == 1) {
			return true;
		} else if (!esCuadrada(m)) {
			return false;
		} else if (esIgualFilaColumna(m)){
			if (esSimetrica(eliminaFila(m))){
				return true;
			}			
		}
		return false;
	}
	
	/**
	 * Método que comprueba que la ultima fila es igual a la ultima columna
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	private boolean esIgualFilaColumna(int[][] m) {
		for (int i=0; i<m.length; i++) {
			if (m[m.length-1][i]!= m[i][m.length-1]) {
				return false;
			}
		}
		return true;
	}

	/**
	 * Método que elimina las filas de la matriz
	 * 
	 * @param m, matriz a la que eliminar las filas
	 * @return nueva matriz con las filas eliminadas
	 */
	private int[][] eliminaFila(int[][] m) {
		int [][] m2 = new int[m.length-1][m.length-1];		
		for (int i=0; i<m.length-1; i++) {
			for (int j=0; j<m.length-1; j++) {
				m2[i][j]=m[i][j];
			}
		}
		return m2;
	}
	
	/**
	 * Método que comprueba que una matriz es cuadrada
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	private boolean esCuadrada(int[][] m) {
		for (int i=0; i<m.length;i++) {
			if (m.length != m[i].length) {
				return false;
			}
		}
		return true;
	}
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-09-19 20:21:37.346
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-09-19 20:21:37.347
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-09-19 20:21:38.911
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package p1Algoritmia;

import java.security.InvalidParameterException;
/**
 * Titulo: Clase Algorithms
 * 
 * @author Omar Teixeira
 * @version 10/09/2021
 */
public class Algorithms {
	/**
	 * Constante Sleep Time
	 */
	private static final long SLEEP_TIME = 1;
	
	/**
	 * Método doNothing
	 */
	public static void doNothing() {
		try {
			Thread.sleep(SLEEP_TIME);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}

	/**
	 * Método que calcula el factorial de un numero mayor o igual a cero de forma recursiva
	 * 
	 * @param n, numero a calcular el factorial
	 * @return factorial
	 */
	public long factorial (int n) { // Calcula el factorial de n>=0 de forma recursiva
		doNothing();
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);		
		
		if (n==0)
			return 1;
		else
			return n*factorial(n-1);		
	} 
	
	/**
	 * Método que calcula el numero que ocupa el n introducido en la sucesión de fibonacci
	 * 
	 * @param n, numero a calcular el fibonacci
	 * @return valor fibonacci
	 */
	public int fibonacci (int n) { // Calcula el termino n-esimo teniendo en cuenta que el primer término se considera fib(0)=0; y fib(1)=1		
		if (n<0)
		throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		
		if (n==0)
			return 0;
		else if (n==1)
			return 1;
		else
			return fibonacci(n-1)+fibonacci(n-2);		
	} 
	
	/**
	 * Método que calcula la potencia recursiva 1 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec1(int n) {  // calcula 2 elevado a n de forma recursiva 2^n = 2*2^(n-1)
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		
		if (n==0)
			return 1;
		else 
			return 2*pow2Rec1(n-1);				
	} 
	
	/**
	 * Método que calcula la potencia iterativa de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Iter (int n) {  // calcula 2 elevado a n de forma iterativa 
	    if (n<0)
	    	throw new InvalidParameterException("No permitidos exponentes negativos como "+ n); 
	    
	    long pow=2;
	    for (int i=0; i<=n;i++) {
	    	doNothing();
	    	pow=2*pow;
	    }	    
	    return pow; 
	} 

	/**
	 * Método que calcula la potencia recursiva 2 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec2 (int n) { // calcula 2 elevado a n de forma recursiva 2^n = 2^(n-1)+2^(n-1) 
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		if (n==0)
			return 1;
		else 
			return pow2Rec2(n-1) + pow2Rec2(n-1);
	} 
	
	/**
	 * Método que calcula la potencia recursiva 3 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec3 (int n) { // calcula 2 elevado a n de forma recursiva 2^n = 2^(n/2)*2^(n/2) si n par y *2 si es impar 
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		if (n==0)
			return 1;
		else if (n%2==0)
			return pow2Rec3(n/2)*pow2Rec3(n/2);
		else 
			return pow2Rec3(n/2)*pow2Rec3(n/2)*2; 
	} 
	
	/**
	 * Método que calcula la potencia recursiva 4 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec4 (int n) {  // calcula 2 elevado a n de forma recursiva 2^n = como pow2Rec3 pero sin repetir llamada 
		doNothing();
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		if (n==0) {
			return 1;
		} else { 
			if (n%2==0) {
				long res = pow2Rec4(n/2);
				return res*res;
			}
			else { 
				long res = pow2Rec4(n/2);
				return 2*res*res;
			}
		}	
		} 
	  
	/**
	 * Método que calcula la potencia de un numero a elevado al numero introducido b
	 * 
	 * @param a, base
	 * @param b, exponente
	 * @return potencia de la base elevada al exponente
	 */
	public long potenciaRec(int a, int b) { // Calcula a elevado a b de forma recursiva por potencias sucesivas 
		if (a<0 || b<0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido"); 
		
		if(a==1 || b==0)
			return 1;
		else			
			return a*potenciaRec(a,b-1);
		 
	}
	
	/**
	 * Método que calcula el resto de la división de dos numeros
	 * 
	 * @param a, dividendo
	 * @param b, divisor
	 * @return resto
	 */
	public int restoDivRec (int a, int b) {  // calcula el resto de la división a/b de forma recursiva 
		if (a<0 || b<=0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido");
		
		if (a<b)
			return a;
		else
			return restoDivRec(a-b,b);		
	} 
	
	/**
	 * Método que calcula la división entera de dos numeros
	 * 
	 * @param a, dividendo
	 * @param b, divisor
	 * @return division entera
	 */
	public int divEntRec (int a, int b) {  // calcula la división entera a/b de forma recursiva 
		if (a<0 || b<=0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido");		
		
		if (a<b)
			return 0;
		else
			return 1+divEntRec(a-b,b);		
	} 
	
	/**
	 * Método que invierte un numero entero de forma recursiva
	 * 
	 * @param n, numero a invertir
	 * @return numero invertido
	 */
	public int invertirEnteroRec(int n) {  // Invierte un entero invertirEnteroRec(1234)=4321 de forma recursiva
		if (n<10)
			return n;
		else			
			return (n%10) * (int)Math.pow(10, Integer.toString(n/10).length())+ invertirEnteroRec(n/10);
	} 

	/**
	 * Método que invierte un string de forma recursiva
	 * 
	 * @param l, string a invertir
	 * @return string invertido
	 */
	public String invertirStringRec(String l) { // Invierte un string de forma recursiva invertirStringRec("abc")="cba" 
		if (l.length()==1)
			return l;
		else
			return invertirStringRec(l.substring(1)) + l.charAt(0);
	}
	  
	/**
	 * Método que tiene una complejidad temporal lineal
	 * 
	 * @param n, parametro
	 */
	public void linear (int n) { // Algoritmo con una complejidad temporal lineal 
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		for (int i=0; i<=n; i++) {
			doNothing();
			System.out.println("El algoritmo se ha ejecutado: " + i + " vez/veces");
		}
	} 

	/**
	 * Método que tiene una complejidad temporal lineal
	 * 
	 * @param n, parametro
	 */
	public void quadratic(int n) { // Algoritmo con una complejidad temporal cuadrática 
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		for (int i=0; i<=n; i++) {
			for (int j=0; j<=n;j++) {
				doNothing();
				System.out.println("El algoritmo se ha ejecutado: " + j + " vez/veces");
			}
			System.out.println("--------"+i+"---------");
		}
	} 

	  

	public void cubic(int n) { // Algoritmo con una complejidad temporal cúbica 
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		for (int i=0; i<=n; i++) {
			for (int j=0; j<=n;j++) {
				for (int k=0; k<=n;k++) {
					doNothing();
					("El algoritmo se ha ejecutado: " + k + " vez/veces");
				}
				System.out.println("--------"+j+"---------");
			}
			System.out.println("~~~~~~~~"+j+"~~~~~~~~");
		}

	} 

	  

	public void logarithmic(int n) { // Algoritmo con una complejidad temporal logarítmica en cualquier base 

	if (n<0) 

	throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 

	} 	

	/**
	 * Método que comprueba si una matriz cuadrada es simetrica 
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	public boolean esSimetrica(int[][] m) { // Indica si es simétrica una matriz cuadrada de forma recursiva
		if (m.length == 1 && m[0].length == 1) {
			return true;
		} else if (!esCuadrada(m)) {
			return false;
		} else if (esIgualFilaColumna(m)){
			if (esSimetrica(eliminaFila(m))){
				return true;
			}			
		}
		return false;
	}
	
	/**
	 * Método que comprueba que la ultima fila es igual a la ultima columna
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	private boolean esIgualFilaColumna(int[][] m) {
		for (int i=0; i<m.length; i++) {
			if (m[m.length-1][i]!= m[i][m.length-1]) {
				return false;
			}
		}
		return true;
	}

	/**
	 * Método que elimina las filas de la matriz
	 * 
	 * @param m, matriz a la que eliminar las filas
	 * @return nueva matriz con las filas eliminadas
	 */
	private int[][] eliminaFila(int[][] m) {
		int [][] m2 = new int[m.length-1][m.length-1];		
		for (int i=0; i<m.length-1; i++) {
			for (int j=0; j<m.length-1; j++) {
				m2[i][j]=m[i][j];
			}
		}
		return m2;
	}
	
	/**
	 * Método que comprueba que una matriz es cuadrada
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	private boolean esCuadrada(int[][] m) {
		for (int i=0; i<m.length;i++) {
			if (m.length != m[i].length) {
				return false;
			}
		}
		return true;
	}
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-09-19 20:21:38.913
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-09-19 20:21:38.914
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2021-09-19 20:21:40.474
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package p1Algoritmia;

import java.security.InvalidParameterException;
/**
 * Titulo: Clase Algorithms
 * 
 * @author Omar Teixeira
 * @version 10/09/2021
 */
public class Algorithms {
	/**
	 * Constante Sleep Time
	 */
	private static final long SLEEP_TIME = 1;
	
	/**
	 * Método doNothing
	 */
	public static void doNothing() {
		try {
			Thread.sleep(SLEEP_TIME);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}

	/**
	 * Método que calcula el factorial de un numero mayor o igual a cero de forma recursiva
	 * 
	 * @param n, numero a calcular el factorial
	 * @return factorial
	 */
	public long factorial (int n) { // Calcula el factorial de n>=0 de forma recursiva
		doNothing();
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);		
		
		if (n==0)
			return 1;
		else
			return n*factorial(n-1);		
	} 
	
	/**
	 * Método que calcula el numero que ocupa el n introducido en la sucesión de fibonacci
	 * 
	 * @param n, numero a calcular el fibonacci
	 * @return valor fibonacci
	 */
	public int fibonacci (int n) { // Calcula el termino n-esimo teniendo en cuenta que el primer término se considera fib(0)=0; y fib(1)=1		
		if (n<0)
		throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		
		if (n==0)
			return 0;
		else if (n==1)
			return 1;
		else
			return fibonacci(n-1)+fibonacci(n-2);		
	} 
	
	/**
	 * Método que calcula la potencia recursiva 1 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec1(int n) {  // calcula 2 elevado a n de forma recursiva 2^n = 2*2^(n-1)
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		
		if (n==0)
			return 1;
		else 
			return 2*pow2Rec1(n-1);				
	} 
	
	/**
	 * Método que calcula la potencia iterativa de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Iter (int n) {  // calcula 2 elevado a n de forma iterativa 
	    if (n<0)
	    	throw new InvalidParameterException("No permitidos exponentes negativos como "+ n); 
	    
	    long pow=2;
	    for (int i=0; i<=n;i++) {
	    	doNothing();
	    	pow=2*pow;
	    }	    
	    return pow; 
	} 

	/**
	 * Método que calcula la potencia recursiva 2 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec2 (int n) { // calcula 2 elevado a n de forma recursiva 2^n = 2^(n-1)+2^(n-1) 
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		if (n==0)
			return 1;
		else 
			return pow2Rec2(n-1) + pow2Rec2(n-1);
	} 
	
	/**
	 * Método que calcula la potencia recursiva 3 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec3 (int n) { // calcula 2 elevado a n de forma recursiva 2^n = 2^(n/2)*2^(n/2) si n par y *2 si es impar 
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		if (n==0)
			return 1;
		else if (n%2==0)
			return pow2Rec3(n/2)*pow2Rec3(n/2);
		else 
			return pow2Rec3(n/2)*pow2Rec3(n/2)*2; 
	} 
	
	/**
	 * Método que calcula la potencia recursiva 4 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec4 (int n) {  // calcula 2 elevado a n de forma recursiva 2^n = como pow2Rec3 pero sin repetir llamada 
		doNothing();
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		if (n==0) {
			return 1;
		} else { 
			if (n%2==0) {
				long res = pow2Rec4(n/2);
				return res*res;
			}
			else { 
				long res = pow2Rec4(n/2);
				return 2*res*res;
			}
		}	
		} 
	  
	/**
	 * Método que calcula la potencia de un numero a elevado al numero introducido b
	 * 
	 * @param a, base
	 * @param b, exponente
	 * @return potencia de la base elevada al exponente
	 */
	public long potenciaRec(int a, int b) { // Calcula a elevado a b de forma recursiva por potencias sucesivas 
		if (a<0 || b<0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido"); 
		
		if(a==1 || b==0)
			return 1;
		else			
			return a*potenciaRec(a,b-1);
		 
	}
	
	/**
	 * Método que calcula el resto de la división de dos numeros
	 * 
	 * @param a, dividendo
	 * @param b, divisor
	 * @return resto
	 */
	public int restoDivRec (int a, int b) {  // calcula el resto de la división a/b de forma recursiva 
		if (a<0 || b<=0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido");
		
		if (a<b)
			return a;
		else
			return restoDivRec(a-b,b);		
	} 
	
	/**
	 * Método que calcula la división entera de dos numeros
	 * 
	 * @param a, dividendo
	 * @param b, divisor
	 * @return division entera
	 */
	public int divEntRec (int a, int b) {  // calcula la división entera a/b de forma recursiva 
		if (a<0 || b<=0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido");		
		
		if (a<b)
			return 0;
		else
			return 1+divEntRec(a-b,b);		
	} 
	
	/**
	 * Método que invierte un numero entero de forma recursiva
	 * 
	 * @param n, numero a invertir
	 * @return numero invertido
	 */
	public int invertirEnteroRec(int n) {  // Invierte un entero invertirEnteroRec(1234)=4321 de forma recursiva
		if (n<10)
			return n;
		else			
			return (n%10) * (int)Math.pow(10, Integer.toString(n/10).length())+ invertirEnteroRec(n/10);
	} 

	/**
	 * Método que invierte un string de forma recursiva
	 * 
	 * @param l, string a invertir
	 * @return string invertido
	 */
	public String invertirStringRec(String l) { // Invierte un string de forma recursiva invertirStringRec("abc")="cba" 
		if (l.length()==1)
			return l;
		else
			return invertirStringRec(l.substring(1)) + l.charAt(0);
	}
	  
	/**
	 * Método que tiene una complejidad temporal lineal
	 * 
	 * @param n, parametro
	 */
	public void linear (int n) { // Algoritmo con una complejidad temporal lineal 
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		for (int i=0; i<=n; i++) {
			doNothing();
			System.out.println("El algoritmo se ha ejecutado: " + i + " vez/veces");
		}
	} 

	/**
	 * Método que tiene una complejidad temporal lineal
	 * 
	 * @param n, parametro
	 */
	public void quadratic(int n) { // Algoritmo con una complejidad temporal cuadrática 
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		for (int i=0; i<=n; i++) {
			for (int j=0; j<=n;j++) {
				doNothing();
				System.out.println("El algoritmo se ha ejecutado: " + j + " vez/veces");
			}
			System.out.println("--------"+i+"---------");
		}
	} 

	  

	public void cubic(int n) { // Algoritmo con una complejidad temporal cúbica 
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		for (int i=0; i<=n; i++) {
			for (int j=0; j<=n;j++) {
				for (int k=0; k<=n;k++) {
					doNothing();
					("El algoritmo se ha ejecutado: " + k + " vez/veces");
				}
				System.out.println("--------"+j+"---------");
			}
			System.out.println("~~~~~~~~"+j+"~~~~~~~~");
		}

	} 

	  

	public void logarithmic(int n) { // Algoritmo con una complejidad temporal logarítmica en cualquier base 

	if (n<0) 

	throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 

	} 	

	/**
	 * Método que comprueba si una matriz cuadrada es simetrica 
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	public boolean esSimetrica(int[][] m) { // Indica si es simétrica una matriz cuadrada de forma recursiva
		if (m.length == 1 && m[0].length == 1) {
			return true;
		} else if (!esCuadrada(m)) {
			return false;
		} else if (esIgualFilaColumna(m)){
			if (esSimetrica(eliminaFila(m))){
				return true;
			}			
		}
		return false;
	}
	
	/**
	 * Método que comprueba que la ultima fila es igual a la ultima columna
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	private boolean esIgualFilaColumna(int[][] m) {
		for (int i=0; i<m.length; i++) {
			if (m[m.length-1][i]!= m[i][m.length-1]) {
				return false;
			}
		}
		return true;
	}

	/**
	 * Método que elimina las filas de la matriz
	 * 
	 * @param m, matriz a la que eliminar las filas
	 * @return nueva matriz con las filas eliminadas
	 */
	private int[][] eliminaFila(int[][] m) {
		int [][] m2 = new int[m.length-1][m.length-1];		
		for (int i=0; i<m.length-1; i++) {
			for (int j=0; j<m.length-1; j++) {
				m2[i][j]=m[i][j];
			}
		}
		return m2;
	}
	
	/**
	 * Método que comprueba que una matriz es cuadrada
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	private boolean esCuadrada(int[][] m) {
		for (int i=0; i<m.length;i++) {
			if (m.length != m[i].length) {
				return false;
			}
		}
		return true;
	}
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-09-19 20:21:40.475
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-09-19 20:21:40.477
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2021-09-19 20:21:41.148
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package p1Algoritmia;

import java.security.InvalidParameterException;
/**
 * Titulo: Clase Algorithms
 * 
 * @author Omar Teixeira
 * @version 10/09/2021
 */
public class Algorithms {
	/**
	 * Constante Sleep Time
	 */
	private static final long SLEEP_TIME = 1;
	
	/**
	 * Método doNothing
	 */
	public static void doNothing() {
		try {
			Thread.sleep(SLEEP_TIME);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}

	/**
	 * Método que calcula el factorial de un numero mayor o igual a cero de forma recursiva
	 * 
	 * @param n, numero a calcular el factorial
	 * @return factorial
	 */
	public long factorial (int n) { // Calcula el factorial de n>=0 de forma recursiva
		doNothing();
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);		
		
		if (n==0)
			return 1;
		else
			return n*factorial(n-1);		
	} 
	
	/**
	 * Método que calcula el numero que ocupa el n introducido en la sucesión de fibonacci
	 * 
	 * @param n, numero a calcular el fibonacci
	 * @return valor fibonacci
	 */
	public int fibonacci (int n) { // Calcula el termino n-esimo teniendo en cuenta que el primer término se considera fib(0)=0; y fib(1)=1		
		if (n<0)
		throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		
		if (n==0)
			return 0;
		else if (n==1)
			return 1;
		else
			return fibonacci(n-1)+fibonacci(n-2);		
	} 
	
	/**
	 * Método que calcula la potencia recursiva 1 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec1(int n) {  // calcula 2 elevado a n de forma recursiva 2^n = 2*2^(n-1)
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		
		if (n==0)
			return 1;
		else 
			return 2*pow2Rec1(n-1);				
	} 
	
	/**
	 * Método que calcula la potencia iterativa de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Iter (int n) {  // calcula 2 elevado a n de forma iterativa 
	    if (n<0)
	    	throw new InvalidParameterException("No permitidos exponentes negativos como "+ n); 
	    
	    long pow=2;
	    for (int i=0; i<=n;i++) {
	    	doNothing();
	    	pow=2*pow;
	    }	    
	    return pow; 
	} 

	/**
	 * Método que calcula la potencia recursiva 2 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec2 (int n) { // calcula 2 elevado a n de forma recursiva 2^n = 2^(n-1)+2^(n-1) 
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		if (n==0)
			return 1;
		else 
			return pow2Rec2(n-1) + pow2Rec2(n-1);
	} 
	
	/**
	 * Método que calcula la potencia recursiva 3 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec3 (int n) { // calcula 2 elevado a n de forma recursiva 2^n = 2^(n/2)*2^(n/2) si n par y *2 si es impar 
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		if (n==0)
			return 1;
		else if (n%2==0)
			return pow2Rec3(n/2)*pow2Rec3(n/2);
		else 
			return pow2Rec3(n/2)*pow2Rec3(n/2)*2; 
	} 
	
	/**
	 * Método que calcula la potencia recursiva 4 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec4 (int n) {  // calcula 2 elevado a n de forma recursiva 2^n = como pow2Rec3 pero sin repetir llamada 
		doNothing();
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		if (n==0) {
			return 1;
		} else { 
			if (n%2==0) {
				long res = pow2Rec4(n/2);
				return res*res;
			}
			else { 
				long res = pow2Rec4(n/2);
				return 2*res*res;
			}
		}	
		} 
	  
	/**
	 * Método que calcula la potencia de un numero a elevado al numero introducido b
	 * 
	 * @param a, base
	 * @param b, exponente
	 * @return potencia de la base elevada al exponente
	 */
	public long potenciaRec(int a, int b) { // Calcula a elevado a b de forma recursiva por potencias sucesivas 
		if (a<0 || b<0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido"); 
		
		if(a==1 || b==0)
			return 1;
		else			
			return a*potenciaRec(a,b-1);
		 
	}
	
	/**
	 * Método que calcula el resto de la división de dos numeros
	 * 
	 * @param a, dividendo
	 * @param b, divisor
	 * @return resto
	 */
	public int restoDivRec (int a, int b) {  // calcula el resto de la división a/b de forma recursiva 
		if (a<0 || b<=0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido");
		
		if (a<b)
			return a;
		else
			return restoDivRec(a-b,b);		
	} 
	
	/**
	 * Método que calcula la división entera de dos numeros
	 * 
	 * @param a, dividendo
	 * @param b, divisor
	 * @return division entera
	 */
	public int divEntRec (int a, int b) {  // calcula la división entera a/b de forma recursiva 
		if (a<0 || b<=0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido");		
		
		if (a<b)
			return 0;
		else
			return 1+divEntRec(a-b,b);		
	} 
	
	/**
	 * Método que invierte un numero entero de forma recursiva
	 * 
	 * @param n, numero a invertir
	 * @return numero invertido
	 */
	public int invertirEnteroRec(int n) {  // Invierte un entero invertirEnteroRec(1234)=4321 de forma recursiva
		if (n<10)
			return n;
		else			
			return (n%10) * (int)Math.pow(10, Integer.toString(n/10).length())+ invertirEnteroRec(n/10);
	} 

	/**
	 * Método que invierte un string de forma recursiva
	 * 
	 * @param l, string a invertir
	 * @return string invertido
	 */
	public String invertirStringRec(String l) { // Invierte un string de forma recursiva invertirStringRec("abc")="cba" 
		if (l.length()==1)
			return l;
		else
			return invertirStringRec(l.substring(1)) + l.charAt(0);
	}
	  
	/**
	 * Método que tiene una complejidad temporal lineal
	 * 
	 * @param n, parametro
	 */
	public void linear (int n) { // Algoritmo con una complejidad temporal lineal 
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		for (int i=0; i<=n; i++) {
			doNothing();
			System.out.println("El algoritmo se ha ejecutado: " + i + " vez/veces");
		}
	} 

	/**
	 * Método que tiene una complejidad temporal lineal
	 * 
	 * @param n, parametro
	 */
	public void quadratic(int n) { // Algoritmo con una complejidad temporal cuadrática 
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		for (int i=0; i<=n; i++) {
			for (int j=0; j<=n;j++) {
				doNothing();
				System.out.println("El algoritmo se ha ejecutado: " + j + " vez/veces");
			}
			System.out.println("--------"+i+"---------");
		}
	} 

	  

	public void cubic(int n) { // Algoritmo con una complejidad temporal cúbica 
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		for (int i=0; i<=n; i++) {
			for (int j=0; j<=n;j++) {
				for (int k=0; k<=n;k++) {
					doNothing();
					("El algoritmo se ha ejecutado: " + k + " vez/veces");
				}
				System.out.println("--------"+j+"---------");
			}
			System.out.println("~~~~~~~~~"+j+"~~~~~~~~");
		}

	} 

	  

	public void logarithmic(int n) { // Algoritmo con una complejidad temporal logarítmica en cualquier base 

	if (n<0) 

	throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 

	} 	

	/**
	 * Método que comprueba si una matriz cuadrada es simetrica 
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	public boolean esSimetrica(int[][] m) { // Indica si es simétrica una matriz cuadrada de forma recursiva
		if (m.length == 1 && m[0].length == 1) {
			return true;
		} else if (!esCuadrada(m)) {
			return false;
		} else if (esIgualFilaColumna(m)){
			if (esSimetrica(eliminaFila(m))){
				return true;
			}			
		}
		return false;
	}
	
	/**
	 * Método que comprueba que la ultima fila es igual a la ultima columna
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	private boolean esIgualFilaColumna(int[][] m) {
		for (int i=0; i<m.length; i++) {
			if (m[m.length-1][i]!= m[i][m.length-1]) {
				return false;
			}
		}
		return true;
	}

	/**
	 * Método que elimina las filas de la matriz
	 * 
	 * @param m, matriz a la que eliminar las filas
	 * @return nueva matriz con las filas eliminadas
	 */
	private int[][] eliminaFila(int[][] m) {
		int [][] m2 = new int[m.length-1][m.length-1];		
		for (int i=0; i<m.length-1; i++) {
			for (int j=0; j<m.length-1; j++) {
				m2[i][j]=m[i][j];
			}
		}
		return m2;
	}
	
	/**
	 * Método que comprueba que una matriz es cuadrada
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	private boolean esCuadrada(int[][] m) {
		for (int i=0; i<m.length;i++) {
			if (m.length != m[i].length) {
				return false;
			}
		}
		return true;
	}
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-09-19 20:21:41.150
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-09-19 20:21:41.151
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-09-19 20:21:41.526
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package p1Algoritmia;

import java.security.InvalidParameterException;
/**
 * Titulo: Clase Algorithms
 * 
 * @author Omar Teixeira
 * @version 10/09/2021
 */
public class Algorithms {
	/**
	 * Constante Sleep Time
	 */
	private static final long SLEEP_TIME = 1;
	
	/**
	 * Método doNothing
	 */
	public static void doNothing() {
		try {
			Thread.sleep(SLEEP_TIME);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}

	/**
	 * Método que calcula el factorial de un numero mayor o igual a cero de forma recursiva
	 * 
	 * @param n, numero a calcular el factorial
	 * @return factorial
	 */
	public long factorial (int n) { // Calcula el factorial de n>=0 de forma recursiva
		doNothing();
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);		
		
		if (n==0)
			return 1;
		else
			return n*factorial(n-1);		
	} 
	
	/**
	 * Método que calcula el numero que ocupa el n introducido en la sucesión de fibonacci
	 * 
	 * @param n, numero a calcular el fibonacci
	 * @return valor fibonacci
	 */
	public int fibonacci (int n) { // Calcula el termino n-esimo teniendo en cuenta que el primer término se considera fib(0)=0; y fib(1)=1		
		if (n<0)
		throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		
		if (n==0)
			return 0;
		else if (n==1)
			return 1;
		else
			return fibonacci(n-1)+fibonacci(n-2);		
	} 
	
	/**
	 * Método que calcula la potencia recursiva 1 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec1(int n) {  // calcula 2 elevado a n de forma recursiva 2^n = 2*2^(n-1)
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		
		if (n==0)
			return 1;
		else 
			return 2*pow2Rec1(n-1);				
	} 
	
	/**
	 * Método que calcula la potencia iterativa de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Iter (int n) {  // calcula 2 elevado a n de forma iterativa 
	    if (n<0)
	    	throw new InvalidParameterException("No permitidos exponentes negativos como "+ n); 
	    
	    long pow=2;
	    for (int i=0; i<=n;i++) {
	    	doNothing();
	    	pow=2*pow;
	    }	    
	    return pow; 
	} 

	/**
	 * Método que calcula la potencia recursiva 2 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec2 (int n) { // calcula 2 elevado a n de forma recursiva 2^n = 2^(n-1)+2^(n-1) 
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		if (n==0)
			return 1;
		else 
			return pow2Rec2(n-1) + pow2Rec2(n-1);
	} 
	
	/**
	 * Método que calcula la potencia recursiva 3 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec3 (int n) { // calcula 2 elevado a n de forma recursiva 2^n = 2^(n/2)*2^(n/2) si n par y *2 si es impar 
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		if (n==0)
			return 1;
		else if (n%2==0)
			return pow2Rec3(n/2)*pow2Rec3(n/2);
		else 
			return pow2Rec3(n/2)*pow2Rec3(n/2)*2; 
	} 
	
	/**
	 * Método que calcula la potencia recursiva 4 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec4 (int n) {  // calcula 2 elevado a n de forma recursiva 2^n = como pow2Rec3 pero sin repetir llamada 
		doNothing();
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		if (n==0) {
			return 1;
		} else { 
			if (n%2==0) {
				long res = pow2Rec4(n/2);
				return res*res;
			}
			else { 
				long res = pow2Rec4(n/2);
				return 2*res*res;
			}
		}	
		} 
	  
	/**
	 * Método que calcula la potencia de un numero a elevado al numero introducido b
	 * 
	 * @param a, base
	 * @param b, exponente
	 * @return potencia de la base elevada al exponente
	 */
	public long potenciaRec(int a, int b) { // Calcula a elevado a b de forma recursiva por potencias sucesivas 
		if (a<0 || b<0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido"); 
		
		if(a==1 || b==0)
			return 1;
		else			
			return a*potenciaRec(a,b-1);
		 
	}
	
	/**
	 * Método que calcula el resto de la división de dos numeros
	 * 
	 * @param a, dividendo
	 * @param b, divisor
	 * @return resto
	 */
	public int restoDivRec (int a, int b) {  // calcula el resto de la división a/b de forma recursiva 
		if (a<0 || b<=0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido");
		
		if (a<b)
			return a;
		else
			return restoDivRec(a-b,b);		
	} 
	
	/**
	 * Método que calcula la división entera de dos numeros
	 * 
	 * @param a, dividendo
	 * @param b, divisor
	 * @return division entera
	 */
	public int divEntRec (int a, int b) {  // calcula la división entera a/b de forma recursiva 
		if (a<0 || b<=0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido");		
		
		if (a<b)
			return 0;
		else
			return 1+divEntRec(a-b,b);		
	} 
	
	/**
	 * Método que invierte un numero entero de forma recursiva
	 * 
	 * @param n, numero a invertir
	 * @return numero invertido
	 */
	public int invertirEnteroRec(int n) {  // Invierte un entero invertirEnteroRec(1234)=4321 de forma recursiva
		if (n<10)
			return n;
		else			
			return (n%10) * (int)Math.pow(10, Integer.toString(n/10).length())+ invertirEnteroRec(n/10);
	} 

	/**
	 * Método que invierte un string de forma recursiva
	 * 
	 * @param l, string a invertir
	 * @return string invertido
	 */
	public String invertirStringRec(String l) { // Invierte un string de forma recursiva invertirStringRec("abc")="cba" 
		if (l.length()==1)
			return l;
		else
			return invertirStringRec(l.substring(1)) + l.charAt(0);
	}
	  
	/**
	 * Método que tiene una complejidad temporal lineal
	 * 
	 * @param n, parametro
	 */
	public void linear (int n) { // Algoritmo con una complejidad temporal lineal 
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		for (int i=0; i<=n; i++) {
			doNothing();
			System.out.println("El algoritmo se ha ejecutado: " + i + " vez/veces");
		}
	} 

	/**
	 * Método que tiene una complejidad temporal lineal
	 * 
	 * @param n, parametro
	 */
	public void quadratic(int n) { // Algoritmo con una complejidad temporal cuadrática 
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		for (int i=0; i<=n; i++) {
			for (int j=0; j<=n;j++) {
				doNothing();
				System.out.println("El algoritmo se ha ejecutado: " + j + " vez/veces");
			}
			System.out.println("--------"+i+"---------");
		}
	} 

	  

	public void cubic(int n) { // Algoritmo con una complejidad temporal cúbica 
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		for (int i=0; i<=n; i++) {
			for (int j=0; j<=n;j++) {
				for (int k=0; k<=n;k++) {
					doNothing();
					("El algoritmo se ha ejecutado: " + k + " vez/veces");
				}
				System.out.println("--------"+j+"---------");
			}
			System.out.println("~~~~~~~~~"+j+"~~~~~~~~");
		}

	} 

	  

	public void logarithmic(int n) { // Algoritmo con una complejidad temporal logarítmica en cualquier base 

	if (n<0) 

	throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 

	} 	

	/**
	 * Método que comprueba si una matriz cuadrada es simetrica 
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	public boolean esSimetrica(int[][] m) { // Indica si es simétrica una matriz cuadrada de forma recursiva
		if (m.length == 1 && m[0].length == 1) {
			return true;
		} else if (!esCuadrada(m)) {
			return false;
		} else if (esIgualFilaColumna(m)){
			if (esSimetrica(eliminaFila(m))){
				return true;
			}			
		}
		return false;
	}
	
	/**
	 * Método que comprueba que la ultima fila es igual a la ultima columna
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	private boolean esIgualFilaColumna(int[][] m) {
		for (int i=0; i<m.length; i++) {
			if (m[m.length-1][i]!= m[i][m.length-1]) {
				return false;
			}
		}
		return true;
	}

	/**
	 * Método que elimina las filas de la matriz
	 * 
	 * @param m, matriz a la que eliminar las filas
	 * @return nueva matriz con las filas eliminadas
	 */
	private int[][] eliminaFila(int[][] m) {
		int [][] m2 = new int[m.length-1][m.length-1];		
		for (int i=0; i<m.length-1; i++) {
			for (int j=0; j<m.length-1; j++) {
				m2[i][j]=m[i][j];
			}
		}
		return m2;
	}
	
	/**
	 * Método que comprueba que una matriz es cuadrada
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	private boolean esCuadrada(int[][] m) {
		for (int i=0; i<m.length;i++) {
			if (m.length != m[i].length) {
				return false;
			}
		}
		return true;
	}
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-09-19 20:21:41.528
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-09-19 20:21:41.529
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-09-19 20:21:42.556
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package p1Algoritmia;

import java.security.InvalidParameterException;
/**
 * Titulo: Clase Algorithms
 * 
 * @author Omar Teixeira
 * @version 10/09/2021
 */
public class Algorithms {
	/**
	 * Constante Sleep Time
	 */
	private static final long SLEEP_TIME = 1;
	
	/**
	 * Método doNothing
	 */
	public static void doNothing() {
		try {
			Thread.sleep(SLEEP_TIME);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}

	/**
	 * Método que calcula el factorial de un numero mayor o igual a cero de forma recursiva
	 * 
	 * @param n, numero a calcular el factorial
	 * @return factorial
	 */
	public long factorial (int n) { // Calcula el factorial de n>=0 de forma recursiva
		doNothing();
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);		
		
		if (n==0)
			return 1;
		else
			return n*factorial(n-1);		
	} 
	
	/**
	 * Método que calcula el numero que ocupa el n introducido en la sucesión de fibonacci
	 * 
	 * @param n, numero a calcular el fibonacci
	 * @return valor fibonacci
	 */
	public int fibonacci (int n) { // Calcula el termino n-esimo teniendo en cuenta que el primer término se considera fib(0)=0; y fib(1)=1		
		if (n<0)
		throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		
		if (n==0)
			return 0;
		else if (n==1)
			return 1;
		else
			return fibonacci(n-1)+fibonacci(n-2);		
	} 
	
	/**
	 * Método que calcula la potencia recursiva 1 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec1(int n) {  // calcula 2 elevado a n de forma recursiva 2^n = 2*2^(n-1)
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		
		if (n==0)
			return 1;
		else 
			return 2*pow2Rec1(n-1);				
	} 
	
	/**
	 * Método que calcula la potencia iterativa de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Iter (int n) {  // calcula 2 elevado a n de forma iterativa 
	    if (n<0)
	    	throw new InvalidParameterException("No permitidos exponentes negativos como "+ n); 
	    
	    long pow=2;
	    for (int i=0; i<=n;i++) {
	    	doNothing();
	    	pow=2*pow;
	    }	    
	    return pow; 
	} 

	/**
	 * Método que calcula la potencia recursiva 2 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec2 (int n) { // calcula 2 elevado a n de forma recursiva 2^n = 2^(n-1)+2^(n-1) 
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		if (n==0)
			return 1;
		else 
			return pow2Rec2(n-1) + pow2Rec2(n-1);
	} 
	
	/**
	 * Método que calcula la potencia recursiva 3 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec3 (int n) { // calcula 2 elevado a n de forma recursiva 2^n = 2^(n/2)*2^(n/2) si n par y *2 si es impar 
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		if (n==0)
			return 1;
		else if (n%2==0)
			return pow2Rec3(n/2)*pow2Rec3(n/2);
		else 
			return pow2Rec3(n/2)*pow2Rec3(n/2)*2; 
	} 
	
	/**
	 * Método que calcula la potencia recursiva 4 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec4 (int n) {  // calcula 2 elevado a n de forma recursiva 2^n = como pow2Rec3 pero sin repetir llamada 
		doNothing();
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		if (n==0) {
			return 1;
		} else { 
			if (n%2==0) {
				long res = pow2Rec4(n/2);
				return res*res;
			}
			else { 
				long res = pow2Rec4(n/2);
				return 2*res*res;
			}
		}	
		} 
	  
	/**
	 * Método que calcula la potencia de un numero a elevado al numero introducido b
	 * 
	 * @param a, base
	 * @param b, exponente
	 * @return potencia de la base elevada al exponente
	 */
	public long potenciaRec(int a, int b) { // Calcula a elevado a b de forma recursiva por potencias sucesivas 
		if (a<0 || b<0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido"); 
		
		if(a==1 || b==0)
			return 1;
		else			
			return a*potenciaRec(a,b-1);
		 
	}
	
	/**
	 * Método que calcula el resto de la división de dos numeros
	 * 
	 * @param a, dividendo
	 * @param b, divisor
	 * @return resto
	 */
	public int restoDivRec (int a, int b) {  // calcula el resto de la división a/b de forma recursiva 
		if (a<0 || b<=0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido");
		
		if (a<b)
			return a;
		else
			return restoDivRec(a-b,b);		
	} 
	
	/**
	 * Método que calcula la división entera de dos numeros
	 * 
	 * @param a, dividendo
	 * @param b, divisor
	 * @return division entera
	 */
	public int divEntRec (int a, int b) {  // calcula la división entera a/b de forma recursiva 
		if (a<0 || b<=0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido");		
		
		if (a<b)
			return 0;
		else
			return 1+divEntRec(a-b,b);		
	} 
	
	/**
	 * Método que invierte un numero entero de forma recursiva
	 * 
	 * @param n, numero a invertir
	 * @return numero invertido
	 */
	public int invertirEnteroRec(int n) {  // Invierte un entero invertirEnteroRec(1234)=4321 de forma recursiva
		if (n<10)
			return n;
		else			
			return (n%10) * (int)Math.pow(10, Integer.toString(n/10).length())+ invertirEnteroRec(n/10);
	} 

	/**
	 * Método que invierte un string de forma recursiva
	 * 
	 * @param l, string a invertir
	 * @return string invertido
	 */
	public String invertirStringRec(String l) { // Invierte un string de forma recursiva invertirStringRec("abc")="cba" 
		if (l.length()==1)
			return l;
		else
			return invertirStringRec(l.substring(1)) + l.charAt(0);
	}
	  
	/**
	 * Método que tiene una complejidad temporal lineal
	 * 
	 * @param n, parametro
	 */
	public void linear (int n) { // Algoritmo con una complejidad temporal lineal 
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		for (int i=0; i<=n; i++) {
			doNothing();
			System.out.println("El algoritmo se ha ejecutado: " + i + " vez/veces");
		}
	} 

	/**
	 * Método que tiene una complejidad temporal lineal
	 * 
	 * @param n, parametro
	 */
	public void quadratic(int n) { // Algoritmo con una complejidad temporal cuadrática 
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		for (int i=0; i<=n; i++) {
			for (int j=0; j<=n;j++) {
				doNothing();
				System.out.println("El algoritmo se ha ejecutado: " + j + " vez/veces");
			}
			System.out.println("--------"+i+"---------");
		}
	} 

	  

	public void cubic(int n) { // Algoritmo con una complejidad temporal cúbica 
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		for (int i=0; i<=n; i++) {
			for (int j=0; j<=n;j++) {
				for (int k=0; k<=n;k++) {
					doNothing();
					("El algoritmo se ha ejecutado: " + k + " vez/veces");
				}
				System.out.println("--------"+j+"---------");
			}
			System.out.println("~~~~~~~~~"+j+"~~~~~~~~");
		}

	} 

	  

	public void logarithmic(int n) { // Algoritmo con una complejidad temporal logarítmica en cualquier base 

	if (n<0) 

	throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 

	} 	

	/**
	 * Método que comprueba si una matriz cuadrada es simetrica 
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	public boolean esSimetrica(int[][] m) { // Indica si es simétrica una matriz cuadrada de forma recursiva
		if (m.length == 1 && m[0].length == 1) {
			return true;
		} else if (!esCuadrada(m)) {
			return false;
		} else if (esIgualFilaColumna(m)){
			if (esSimetrica(eliminaFila(m))){
				return true;
			}			
		}
		return false;
	}
	
	/**
	 * Método que comprueba que la ultima fila es igual a la ultima columna
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	private boolean esIgualFilaColumna(int[][] m) {
		for (int i=0; i<m.length; i++) {
			if (m[m.length-1][i]!= m[i][m.length-1]) {
				return false;
			}
		}
		return true;
	}

	/**
	 * Método que elimina las filas de la matriz
	 * 
	 * @param m, matriz a la que eliminar las filas
	 * @return nueva matriz con las filas eliminadas
	 */
	private int[][] eliminaFila(int[][] m) {
		int [][] m2 = new int[m.length-1][m.length-1];		
		for (int i=0; i<m.length-1; i++) {
			for (int j=0; j<m.length-1; j++) {
				m2[i][j]=m[i][j];
			}
		}
		return m2;
	}
	
	/**
	 * Método que comprueba que una matriz es cuadrada
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	private boolean esCuadrada(int[][] m) {
		for (int i=0; i<m.length;i++) {
			if (m.length != m[i].length) {
				return false;
			}
		}
		return true;
	}
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-09-19 20:21:42.558
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-09-19 20:21:42.560
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-09-19 20:21:42.660
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package p1Algoritmia;

import java.security.InvalidParameterException;
/**
 * Titulo: Clase Algorithms
 * 
 * @author Omar Teixeira
 * @version 10/09/2021
 */
public class Algorithms {
	/**
	 * Constante Sleep Time
	 */
	private static final long SLEEP_TIME = 1;
	
	/**
	 * Método doNothing
	 */
	public static void doNothing() {
		try {
			Thread.sleep(SLEEP_TIME);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}

	/**
	 * Método que calcula el factorial de un numero mayor o igual a cero de forma recursiva
	 * 
	 * @param n, numero a calcular el factorial
	 * @return factorial
	 */
	public long factorial (int n) { // Calcula el factorial de n>=0 de forma recursiva
		doNothing();
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);		
		
		if (n==0)
			return 1;
		else
			return n*factorial(n-1);		
	} 
	
	/**
	 * Método que calcula el numero que ocupa el n introducido en la sucesión de fibonacci
	 * 
	 * @param n, numero a calcular el fibonacci
	 * @return valor fibonacci
	 */
	public int fibonacci (int n) { // Calcula el termino n-esimo teniendo en cuenta que el primer término se considera fib(0)=0; y fib(1)=1		
		if (n<0)
		throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		
		if (n==0)
			return 0;
		else if (n==1)
			return 1;
		else
			return fibonacci(n-1)+fibonacci(n-2);		
	} 
	
	/**
	 * Método que calcula la potencia recursiva 1 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec1(int n) {  // calcula 2 elevado a n de forma recursiva 2^n = 2*2^(n-1)
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		
		if (n==0)
			return 1;
		else 
			return 2*pow2Rec1(n-1);				
	} 
	
	/**
	 * Método que calcula la potencia iterativa de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Iter (int n) {  // calcula 2 elevado a n de forma iterativa 
	    if (n<0)
	    	throw new InvalidParameterException("No permitidos exponentes negativos como "+ n); 
	    
	    long pow=2;
	    for (int i=0; i<=n;i++) {
	    	doNothing();
	    	pow=2*pow;
	    }	    
	    return pow; 
	} 

	/**
	 * Método que calcula la potencia recursiva 2 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec2 (int n) { // calcula 2 elevado a n de forma recursiva 2^n = 2^(n-1)+2^(n-1) 
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		if (n==0)
			return 1;
		else 
			return pow2Rec2(n-1) + pow2Rec2(n-1);
	} 
	
	/**
	 * Método que calcula la potencia recursiva 3 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec3 (int n) { // calcula 2 elevado a n de forma recursiva 2^n = 2^(n/2)*2^(n/2) si n par y *2 si es impar 
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		if (n==0)
			return 1;
		else if (n%2==0)
			return pow2Rec3(n/2)*pow2Rec3(n/2);
		else 
			return pow2Rec3(n/2)*pow2Rec3(n/2)*2; 
	} 
	
	/**
	 * Método que calcula la potencia recursiva 4 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec4 (int n) {  // calcula 2 elevado a n de forma recursiva 2^n = como pow2Rec3 pero sin repetir llamada 
		doNothing();
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		if (n==0) {
			return 1;
		} else { 
			if (n%2==0) {
				long res = pow2Rec4(n/2);
				return res*res;
			}
			else { 
				long res = pow2Rec4(n/2);
				return 2*res*res;
			}
		}	
		} 
	  
	/**
	 * Método que calcula la potencia de un numero a elevado al numero introducido b
	 * 
	 * @param a, base
	 * @param b, exponente
	 * @return potencia de la base elevada al exponente
	 */
	public long potenciaRec(int a, int b) { // Calcula a elevado a b de forma recursiva por potencias sucesivas 
		if (a<0 || b<0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido"); 
		
		if(a==1 || b==0)
			return 1;
		else			
			return a*potenciaRec(a,b-1);
		 
	}
	
	/**
	 * Método que calcula el resto de la división de dos numeros
	 * 
	 * @param a, dividendo
	 * @param b, divisor
	 * @return resto
	 */
	public int restoDivRec (int a, int b) {  // calcula el resto de la división a/b de forma recursiva 
		if (a<0 || b<=0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido");
		
		if (a<b)
			return a;
		else
			return restoDivRec(a-b,b);		
	} 
	
	/**
	 * Método que calcula la división entera de dos numeros
	 * 
	 * @param a, dividendo
	 * @param b, divisor
	 * @return division entera
	 */
	public int divEntRec (int a, int b) {  // calcula la división entera a/b de forma recursiva 
		if (a<0 || b<=0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido");		
		
		if (a<b)
			return 0;
		else
			return 1+divEntRec(a-b,b);		
	} 
	
	/**
	 * Método que invierte un numero entero de forma recursiva
	 * 
	 * @param n, numero a invertir
	 * @return numero invertido
	 */
	public int invertirEnteroRec(int n) {  // Invierte un entero invertirEnteroRec(1234)=4321 de forma recursiva
		if (n<10)
			return n;
		else			
			return (n%10) * (int)Math.pow(10, Integer.toString(n/10).length())+ invertirEnteroRec(n/10);
	} 

	/**
	 * Método que invierte un string de forma recursiva
	 * 
	 * @param l, string a invertir
	 * @return string invertido
	 */
	public String invertirStringRec(String l) { // Invierte un string de forma recursiva invertirStringRec("abc")="cba" 
		if (l.length()==1)
			return l;
		else
			return invertirStringRec(l.substring(1)) + l.charAt(0);
	}
	  
	/**
	 * Método que tiene una complejidad temporal lineal
	 * 
	 * @param n, parametro
	 */
	public void linear (int n) { // Algoritmo con una complejidad temporal lineal 
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		for (int i=0; i<=n; i++) {
			doNothing();
			System.out.println("El algoritmo se ha ejecutado: " + i + " vez/veces");
		}
	} 

	/**
	 * Método que tiene una complejidad temporal lineal
	 * 
	 * @param n, parametro
	 */
	public void quadratic(int n) { // Algoritmo con una complejidad temporal cuadrática 
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		for (int i=0; i<=n; i++) {
			for (int j=0; j<=n;j++) {
				doNothing();
				System.out.println("El algoritmo se ha ejecutado: " + j + " vez/veces");
			}
			System.out.println("--------"+i+"---------");
		}
	} 

	  

	public void cubic(int n) { // Algoritmo con una complejidad temporal cúbica 
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		for (int i=0; i<=n; i++) {
			for (int j=0; j<=n;j++) {
				for (int k=0; k<=n;k++) {
					doNothing();
					("El algoritmo se ha ejecutado: " + k + " vez/veces");
				}
				System.out.println("--------"+j+"---------");
			}
			System.out.println("~~~~~~~~~"+j+"~~~~~~~~");
		}

	} 

	  

	public void logarithmic(int n) { // Algoritmo con una complejidad temporal logarítmica en cualquier base 

	if (n<0) 

	throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 

	} 	

	/**
	 * Método que comprueba si una matriz cuadrada es simetrica 
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	public boolean esSimetrica(int[][] m) { // Indica si es simétrica una matriz cuadrada de forma recursiva
		if (m.length == 1 && m[0].length == 1) {
			return true;
		} else if (!esCuadrada(m)) {
			return false;
		} else if (esIgualFilaColumna(m)){
			if (esSimetrica(eliminaFila(m))){
				return true;
			}			
		}
		return false;
	}
	
	/**
	 * Método que comprueba que la ultima fila es igual a la ultima columna
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	private boolean esIgualFilaColumna(int[][] m) {
		for (int i=0; i<m.length; i++) {
			if (m[m.length-1][i]!= m[i][m.length-1]) {
				return false;
			}
		}
		return true;
	}

	/**
	 * Método que elimina las filas de la matriz
	 * 
	 * @param m, matriz a la que eliminar las filas
	 * @return nueva matriz con las filas eliminadas
	 */
	private int[][] eliminaFila(int[][] m) {
		int [][] m2 = new int[m.length-1][m.length-1];		
		for (int i=0; i<m.length-1; i++) {
			for (int j=0; j<m.length-1; j++) {
				m2[i][j]=m[i][j];
			}
		}
		return m2;
	}
	
	/**
	 * Método que comprueba que una matriz es cuadrada
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	private boolean esCuadrada(int[][] m) {
		for (int i=0; i<m.length;i++) {
			if (m.length != m[i].length) {
				return false;
			}
		}
		return true;
	}
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-09-19 20:21:42.662
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-09-19 20:21:42.663
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2021-09-19 20:21:44.157
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package p1Algoritmia;

import java.security.InvalidParameterException;
/**
 * Titulo: Clase Algorithms
 * 
 * @author Omar Teixeira
 * @version 10/09/2021
 */
public class Algorithms {
	/**
	 * Constante Sleep Time
	 */
	private static final long SLEEP_TIME = 1;
	
	/**
	 * Método doNothing
	 */
	public static void doNothing() {
		try {
			Thread.sleep(SLEEP_TIME);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}

	/**
	 * Método que calcula el factorial de un numero mayor o igual a cero de forma recursiva
	 * 
	 * @param n, numero a calcular el factorial
	 * @return factorial
	 */
	public long factorial (int n) { // Calcula el factorial de n>=0 de forma recursiva
		doNothing();
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);		
		
		if (n==0)
			return 1;
		else
			return n*factorial(n-1);		
	} 
	
	/**
	 * Método que calcula el numero que ocupa el n introducido en la sucesión de fibonacci
	 * 
	 * @param n, numero a calcular el fibonacci
	 * @return valor fibonacci
	 */
	public int fibonacci (int n) { // Calcula el termino n-esimo teniendo en cuenta que el primer término se considera fib(0)=0; y fib(1)=1		
		if (n<0)
		throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		
		if (n==0)
			return 0;
		else if (n==1)
			return 1;
		else
			return fibonacci(n-1)+fibonacci(n-2);		
	} 
	
	/**
	 * Método que calcula la potencia recursiva 1 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec1(int n) {  // calcula 2 elevado a n de forma recursiva 2^n = 2*2^(n-1)
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		
		if (n==0)
			return 1;
		else 
			return 2*pow2Rec1(n-1);				
	} 
	
	/**
	 * Método que calcula la potencia iterativa de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Iter (int n) {  // calcula 2 elevado a n de forma iterativa 
	    if (n<0)
	    	throw new InvalidParameterException("No permitidos exponentes negativos como "+ n); 
	    
	    long pow=2;
	    for (int i=0; i<=n;i++) {
	    	doNothing();
	    	pow=2*pow;
	    }	    
	    return pow; 
	} 

	/**
	 * Método que calcula la potencia recursiva 2 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec2 (int n) { // calcula 2 elevado a n de forma recursiva 2^n = 2^(n-1)+2^(n-1) 
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		if (n==0)
			return 1;
		else 
			return pow2Rec2(n-1) + pow2Rec2(n-1);
	} 
	
	/**
	 * Método que calcula la potencia recursiva 3 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec3 (int n) { // calcula 2 elevado a n de forma recursiva 2^n = 2^(n/2)*2^(n/2) si n par y *2 si es impar 
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		if (n==0)
			return 1;
		else if (n%2==0)
			return pow2Rec3(n/2)*pow2Rec3(n/2);
		else 
			return pow2Rec3(n/2)*pow2Rec3(n/2)*2; 
	} 
	
	/**
	 * Método que calcula la potencia recursiva 4 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec4 (int n) {  // calcula 2 elevado a n de forma recursiva 2^n = como pow2Rec3 pero sin repetir llamada 
		doNothing();
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		if (n==0) {
			return 1;
		} else { 
			if (n%2==0) {
				long res = pow2Rec4(n/2);
				return res*res;
			}
			else { 
				long res = pow2Rec4(n/2);
				return 2*res*res;
			}
		}	
		} 
	  
	/**
	 * Método que calcula la potencia de un numero a elevado al numero introducido b
	 * 
	 * @param a, base
	 * @param b, exponente
	 * @return potencia de la base elevada al exponente
	 */
	public long potenciaRec(int a, int b) { // Calcula a elevado a b de forma recursiva por potencias sucesivas 
		if (a<0 || b<0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido"); 
		
		if(a==1 || b==0)
			return 1;
		else			
			return a*potenciaRec(a,b-1);
		 
	}
	
	/**
	 * Método que calcula el resto de la división de dos numeros
	 * 
	 * @param a, dividendo
	 * @param b, divisor
	 * @return resto
	 */
	public int restoDivRec (int a, int b) {  // calcula el resto de la división a/b de forma recursiva 
		if (a<0 || b<=0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido");
		
		if (a<b)
			return a;
		else
			return restoDivRec(a-b,b);		
	} 
	
	/**
	 * Método que calcula la división entera de dos numeros
	 * 
	 * @param a, dividendo
	 * @param b, divisor
	 * @return division entera
	 */
	public int divEntRec (int a, int b) {  // calcula la división entera a/b de forma recursiva 
		if (a<0 || b<=0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido");		
		
		if (a<b)
			return 0;
		else
			return 1+divEntRec(a-b,b);		
	} 
	
	/**
	 * Método que invierte un numero entero de forma recursiva
	 * 
	 * @param n, numero a invertir
	 * @return numero invertido
	 */
	public int invertirEnteroRec(int n) {  // Invierte un entero invertirEnteroRec(1234)=4321 de forma recursiva
		if (n<10)
			return n;
		else			
			return (n%10) * (int)Math.pow(10, Integer.toString(n/10).length())+ invertirEnteroRec(n/10);
	} 

	/**
	 * Método que invierte un string de forma recursiva
	 * 
	 * @param l, string a invertir
	 * @return string invertido
	 */
	public String invertirStringRec(String l) { // Invierte un string de forma recursiva invertirStringRec("abc")="cba" 
		if (l.length()==1)
			return l;
		else
			return invertirStringRec(l.substring(1)) + l.charAt(0);
	}
	  
	/**
	 * Método que tiene una complejidad temporal lineal
	 * 
	 * @param n, parametro
	 */
	public void linear (int n) { // Algoritmo con una complejidad temporal lineal 
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		for (int i=0; i<=n; i++) {
			doNothing();
			System.out.println("El algoritmo se ha ejecutado: " + i + " vez/veces");
		}
	} 

	/**
	 * Método que tiene una complejidad temporal lineal
	 * 
	 * @param n, parametro
	 */
	public void quadratic(int n) { // Algoritmo con una complejidad temporal cuadrática 
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		for (int i=0; i<=n; i++) {
			for (int j=0; j<=n;j++) {
				doNothing();
				System.out.println("El algoritmo se ha ejecutado: " + j + " vez/veces");
			}
			System.out.println("--------"+i+"---------");
		}
	} 

	  

	public void cubic(int n) { // Algoritmo con una complejidad temporal cúbica 
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		for (int i=0; i<=n; i++) {
			for (int j=0; j<=n;j++) {
				for (int k=0; k<=n;k++) {
					doNothing();
					("El algoritmo se ha ejecutado: " + k + " vez/veces");
				}
				System.out.println("--------"+j+"---------");
			}
			System.out.println("~~~~~~~~~"+j+"~~~~~~~~~");
		}

	} 

	  

	public void logarithmic(int n) { // Algoritmo con una complejidad temporal logarítmica en cualquier base 

	if (n<0) 

	throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 

	} 	

	/**
	 * Método que comprueba si una matriz cuadrada es simetrica 
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	public boolean esSimetrica(int[][] m) { // Indica si es simétrica una matriz cuadrada de forma recursiva
		if (m.length == 1 && m[0].length == 1) {
			return true;
		} else if (!esCuadrada(m)) {
			return false;
		} else if (esIgualFilaColumna(m)){
			if (esSimetrica(eliminaFila(m))){
				return true;
			}			
		}
		return false;
	}
	
	/**
	 * Método que comprueba que la ultima fila es igual a la ultima columna
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	private boolean esIgualFilaColumna(int[][] m) {
		for (int i=0; i<m.length; i++) {
			if (m[m.length-1][i]!= m[i][m.length-1]) {
				return false;
			}
		}
		return true;
	}

	/**
	 * Método que elimina las filas de la matriz
	 * 
	 * @param m, matriz a la que eliminar las filas
	 * @return nueva matriz con las filas eliminadas
	 */
	private int[][] eliminaFila(int[][] m) {
		int [][] m2 = new int[m.length-1][m.length-1];		
		for (int i=0; i<m.length-1; i++) {
			for (int j=0; j<m.length-1; j++) {
				m2[i][j]=m[i][j];
			}
		}
		return m2;
	}
	
	/**
	 * Método que comprueba que una matriz es cuadrada
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	private boolean esCuadrada(int[][] m) {
		for (int i=0; i<m.length;i++) {
			if (m.length != m[i].length) {
				return false;
			}
		}
		return true;
	}
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-09-19 20:21:44.158
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-09-19 20:21:44.160
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-09-19 20:21:44.591
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package p1Algoritmia;

import java.security.InvalidParameterException;
/**
 * Titulo: Clase Algorithms
 * 
 * @author Omar Teixeira
 * @version 10/09/2021
 */
public class Algorithms {
	/**
	 * Constante Sleep Time
	 */
	private static final long SLEEP_TIME = 1;
	
	/**
	 * Método doNothing
	 */
	public static void doNothing() {
		try {
			Thread.sleep(SLEEP_TIME);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}

	/**
	 * Método que calcula el factorial de un numero mayor o igual a cero de forma recursiva
	 * 
	 * @param n, numero a calcular el factorial
	 * @return factorial
	 */
	public long factorial (int n) { // Calcula el factorial de n>=0 de forma recursiva
		doNothing();
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);		
		
		if (n==0)
			return 1;
		else
			return n*factorial(n-1);		
	} 
	
	/**
	 * Método que calcula el numero que ocupa el n introducido en la sucesión de fibonacci
	 * 
	 * @param n, numero a calcular el fibonacci
	 * @return valor fibonacci
	 */
	public int fibonacci (int n) { // Calcula el termino n-esimo teniendo en cuenta que el primer término se considera fib(0)=0; y fib(1)=1		
		if (n<0)
		throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		
		if (n==0)
			return 0;
		else if (n==1)
			return 1;
		else
			return fibonacci(n-1)+fibonacci(n-2);		
	} 
	
	/**
	 * Método que calcula la potencia recursiva 1 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec1(int n) {  // calcula 2 elevado a n de forma recursiva 2^n = 2*2^(n-1)
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		
		if (n==0)
			return 1;
		else 
			return 2*pow2Rec1(n-1);				
	} 
	
	/**
	 * Método que calcula la potencia iterativa de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Iter (int n) {  // calcula 2 elevado a n de forma iterativa 
	    if (n<0)
	    	throw new InvalidParameterException("No permitidos exponentes negativos como "+ n); 
	    
	    long pow=2;
	    for (int i=0; i<=n;i++) {
	    	doNothing();
	    	pow=2*pow;
	    }	    
	    return pow; 
	} 

	/**
	 * Método que calcula la potencia recursiva 2 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec2 (int n) { // calcula 2 elevado a n de forma recursiva 2^n = 2^(n-1)+2^(n-1) 
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		if (n==0)
			return 1;
		else 
			return pow2Rec2(n-1) + pow2Rec2(n-1);
	} 
	
	/**
	 * Método que calcula la potencia recursiva 3 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec3 (int n) { // calcula 2 elevado a n de forma recursiva 2^n = 2^(n/2)*2^(n/2) si n par y *2 si es impar 
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		if (n==0)
			return 1;
		else if (n%2==0)
			return pow2Rec3(n/2)*pow2Rec3(n/2);
		else 
			return pow2Rec3(n/2)*pow2Rec3(n/2)*2; 
	} 
	
	/**
	 * Método que calcula la potencia recursiva 4 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec4 (int n) {  // calcula 2 elevado a n de forma recursiva 2^n = como pow2Rec3 pero sin repetir llamada 
		doNothing();
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		if (n==0) {
			return 1;
		} else { 
			if (n%2==0) {
				long res = pow2Rec4(n/2);
				return res*res;
			}
			else { 
				long res = pow2Rec4(n/2);
				return 2*res*res;
			}
		}	
		} 
	  
	/**
	 * Método que calcula la potencia de un numero a elevado al numero introducido b
	 * 
	 * @param a, base
	 * @param b, exponente
	 * @return potencia de la base elevada al exponente
	 */
	public long potenciaRec(int a, int b) { // Calcula a elevado a b de forma recursiva por potencias sucesivas 
		if (a<0 || b<0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido"); 
		
		if(a==1 || b==0)
			return 1;
		else			
			return a*potenciaRec(a,b-1);
		 
	}
	
	/**
	 * Método que calcula el resto de la división de dos numeros
	 * 
	 * @param a, dividendo
	 * @param b, divisor
	 * @return resto
	 */
	public int restoDivRec (int a, int b) {  // calcula el resto de la división a/b de forma recursiva 
		if (a<0 || b<=0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido");
		
		if (a<b)
			return a;
		else
			return restoDivRec(a-b,b);		
	} 
	
	/**
	 * Método que calcula la división entera de dos numeros
	 * 
	 * @param a, dividendo
	 * @param b, divisor
	 * @return division entera
	 */
	public int divEntRec (int a, int b) {  // calcula la división entera a/b de forma recursiva 
		if (a<0 || b<=0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido");		
		
		if (a<b)
			return 0;
		else
			return 1+divEntRec(a-b,b);		
	} 
	
	/**
	 * Método que invierte un numero entero de forma recursiva
	 * 
	 * @param n, numero a invertir
	 * @return numero invertido
	 */
	public int invertirEnteroRec(int n) {  // Invierte un entero invertirEnteroRec(1234)=4321 de forma recursiva
		if (n<10)
			return n;
		else			
			return (n%10) * (int)Math.pow(10, Integer.toString(n/10).length())+ invertirEnteroRec(n/10);
	} 

	/**
	 * Método que invierte un string de forma recursiva
	 * 
	 * @param l, string a invertir
	 * @return string invertido
	 */
	public String invertirStringRec(String l) { // Invierte un string de forma recursiva invertirStringRec("abc")="cba" 
		if (l.length()==1)
			return l;
		else
			return invertirStringRec(l.substring(1)) + l.charAt(0);
	}
	  
	/**
	 * Método que tiene una complejidad temporal lineal
	 * 
	 * @param n, parametro
	 */
	public void linear (int n) { // Algoritmo con una complejidad temporal lineal 
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		for (int i=0; i<=n; i++) {
			doNothing();
			System.out.println("El algoritmo se ha ejecutado: " + i + " vez/veces");
		}
	} 

	/**
	 * Método que tiene una complejidad temporal lineal
	 * 
	 * @param n, parametro
	 */
	public void quadratic(int n) { // Algoritmo con una complejidad temporal cuadrática 
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		for (int i=0; i<=n; i++) {
			for (int j=0; j<=n;j++) {
				doNothing();
				System.out.println("El algoritmo se ha ejecutado: " + j + " vez/veces");
			}
			System.out.println("--------"+i+"---------");
		}
	} 

	  

	public void cubic(int n) { // Algoritmo con una complejidad temporal cúbica 
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		for (int i=0; i<=n; i++) {
			for (int j=0; j<=n;j++) {
				for (int k=0; k<=n;k++) {
					doNothing();
					("El algoritmo se ha ejecutado: " + k + " vez/veces");
				}
				System.out.println("--------"+j+"---------");
			}
			System.out.println("~~~~~~~~~"+j+"~~~~~~~~~");
		}

	} 

	  

	public void logarithmic(int n) { // Algoritmo con una complejidad temporal logarítmica en cualquier base 

	if (n<0) 

	throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 

	} 	

	/**
	 * Método que comprueba si una matriz cuadrada es simetrica 
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	public boolean esSimetrica(int[][] m) { // Indica si es simétrica una matriz cuadrada de forma recursiva
		if (m.length == 1 && m[0].length == 1) {
			return true;
		} else if (!esCuadrada(m)) {
			return false;
		} else if (esIgualFilaColumna(m)){
			if (esSimetrica(eliminaFila(m))){
				return true;
			}			
		}
		return false;
	}
	
	/**
	 * Método que comprueba que la ultima fila es igual a la ultima columna
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	private boolean esIgualFilaColumna(int[][] m) {
		for (int i=0; i<m.length; i++) {
			if (m[m.length-1][i]!= m[i][m.length-1]) {
				return false;
			}
		}
		return true;
	}

	/**
	 * Método que elimina las filas de la matriz
	 * 
	 * @param m, matriz a la que eliminar las filas
	 * @return nueva matriz con las filas eliminadas
	 */
	private int[][] eliminaFila(int[][] m) {
		int [][] m2 = new int[m.length-1][m.length-1];		
		for (int i=0; i<m.length-1; i++) {
			for (int j=0; j<m.length-1; j++) {
				m2[i][j]=m[i][j];
			}
		}
		return m2;
	}
	
	/**
	 * Método que comprueba que una matriz es cuadrada
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	private boolean esCuadrada(int[][] m) {
		for (int i=0; i<m.length;i++) {
			if (m.length != m[i].length) {
				return false;
			}
		}
		return true;
	}
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-09-19 20:21:44.592
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-09-19 20:21:44.594
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-09-19 20:21:45.759
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package p1Algoritmia;

import java.security.InvalidParameterException;
/**
 * Titulo: Clase Algorithms
 * 
 * @author Omar Teixeira
 * @version 10/09/2021
 */
public class Algorithms {
	/**
	 * Constante Sleep Time
	 */
	private static final long SLEEP_TIME = 1;
	
	/**
	 * Método doNothing
	 */
	public static void doNothing() {
		try {
			Thread.sleep(SLEEP_TIME);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}

	/**
	 * Método que calcula el factorial de un numero mayor o igual a cero de forma recursiva
	 * 
	 * @param n, numero a calcular el factorial
	 * @return factorial
	 */
	public long factorial (int n) { // Calcula el factorial de n>=0 de forma recursiva
		doNothing();
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);		
		
		if (n==0)
			return 1;
		else
			return n*factorial(n-1);		
	} 
	
	/**
	 * Método que calcula el numero que ocupa el n introducido en la sucesión de fibonacci
	 * 
	 * @param n, numero a calcular el fibonacci
	 * @return valor fibonacci
	 */
	public int fibonacci (int n) { // Calcula el termino n-esimo teniendo en cuenta que el primer término se considera fib(0)=0; y fib(1)=1		
		if (n<0)
		throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		
		if (n==0)
			return 0;
		else if (n==1)
			return 1;
		else
			return fibonacci(n-1)+fibonacci(n-2);		
	} 
	
	/**
	 * Método que calcula la potencia recursiva 1 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec1(int n) {  // calcula 2 elevado a n de forma recursiva 2^n = 2*2^(n-1)
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		
		if (n==0)
			return 1;
		else 
			return 2*pow2Rec1(n-1);				
	} 
	
	/**
	 * Método que calcula la potencia iterativa de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Iter (int n) {  // calcula 2 elevado a n de forma iterativa 
	    if (n<0)
	    	throw new InvalidParameterException("No permitidos exponentes negativos como "+ n); 
	    
	    long pow=2;
	    for (int i=0; i<=n;i++) {
	    	doNothing();
	    	pow=2*pow;
	    }	    
	    return pow; 
	} 

	/**
	 * Método que calcula la potencia recursiva 2 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec2 (int n) { // calcula 2 elevado a n de forma recursiva 2^n = 2^(n-1)+2^(n-1) 
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		if (n==0)
			return 1;
		else 
			return pow2Rec2(n-1) + pow2Rec2(n-1);
	} 
	
	/**
	 * Método que calcula la potencia recursiva 3 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec3 (int n) { // calcula 2 elevado a n de forma recursiva 2^n = 2^(n/2)*2^(n/2) si n par y *2 si es impar 
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		if (n==0)
			return 1;
		else if (n%2==0)
			return pow2Rec3(n/2)*pow2Rec3(n/2);
		else 
			return pow2Rec3(n/2)*pow2Rec3(n/2)*2; 
	} 
	
	/**
	 * Método que calcula la potencia recursiva 4 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec4 (int n) {  // calcula 2 elevado a n de forma recursiva 2^n = como pow2Rec3 pero sin repetir llamada 
		doNothing();
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		if (n==0) {
			return 1;
		} else { 
			if (n%2==0) {
				long res = pow2Rec4(n/2);
				return res*res;
			}
			else { 
				long res = pow2Rec4(n/2);
				return 2*res*res;
			}
		}	
		} 
	  
	/**
	 * Método que calcula la potencia de un numero a elevado al numero introducido b
	 * 
	 * @param a, base
	 * @param b, exponente
	 * @return potencia de la base elevada al exponente
	 */
	public long potenciaRec(int a, int b) { // Calcula a elevado a b de forma recursiva por potencias sucesivas 
		if (a<0 || b<0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido"); 
		
		if(a==1 || b==0)
			return 1;
		else			
			return a*potenciaRec(a,b-1);
		 
	}
	
	/**
	 * Método que calcula el resto de la división de dos numeros
	 * 
	 * @param a, dividendo
	 * @param b, divisor
	 * @return resto
	 */
	public int restoDivRec (int a, int b) {  // calcula el resto de la división a/b de forma recursiva 
		if (a<0 || b<=0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido");
		
		if (a<b)
			return a;
		else
			return restoDivRec(a-b,b);		
	} 
	
	/**
	 * Método que calcula la división entera de dos numeros
	 * 
	 * @param a, dividendo
	 * @param b, divisor
	 * @return division entera
	 */
	public int divEntRec (int a, int b) {  // calcula la división entera a/b de forma recursiva 
		if (a<0 || b<=0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido");		
		
		if (a<b)
			return 0;
		else
			return 1+divEntRec(a-b,b);		
	} 
	
	/**
	 * Método que invierte un numero entero de forma recursiva
	 * 
	 * @param n, numero a invertir
	 * @return numero invertido
	 */
	public int invertirEnteroRec(int n) {  // Invierte un entero invertirEnteroRec(1234)=4321 de forma recursiva
		if (n<10)
			return n;
		else			
			return (n%10) * (int)Math.pow(10, Integer.toString(n/10).length())+ invertirEnteroRec(n/10);
	} 

	/**
	 * Método que invierte un string de forma recursiva
	 * 
	 * @param l, string a invertir
	 * @return string invertido
	 */
	public String invertirStringRec(String l) { // Invierte un string de forma recursiva invertirStringRec("abc")="cba" 
		if (l.length()==1)
			return l;
		else
			return invertirStringRec(l.substring(1)) + l.charAt(0);
	}
	  
	/**
	 * Método que tiene una complejidad temporal lineal
	 * 
	 * @param n, parametro
	 */
	public void linear (int n) { // Algoritmo con una complejidad temporal lineal 
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		for (int i=0; i<=n; i++) {
			doNothing();
			System.out.println("El algoritmo se ha ejecutado: " + i + " vez/veces");
		}
	} 

	/**
	 * Método que tiene una complejidad temporal lineal
	 * 
	 * @param n, parametro
	 */
	public void quadratic(int n) { // Algoritmo con una complejidad temporal cuadrática 
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		for (int i=0; i<=n; i++) {
			for (int j=0; j<=n;j++) {
				doNothing();
				System.out.println("El algoritmo se ha ejecutado: " + j + " vez/veces");
			}
			System.out.println("--------"+i+"---------");
		}
	} 

	  

	public void cubic(int n) { // Algoritmo con una complejidad temporal cúbica 
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		for (int i=0; i<=n; i++) {
			for (int j=0; j<=n;j++) {
				for (int k=0; k<=n;k++) {
					doNothing();
					("El algoritmo se ha ejecutado: " + k + " vez/veces");
				}
				System.out.println("--------"+j+"---------");
			}
			System.out.println("~~~~~~~~~"+j+"~~~~~~~~~");
		}

	} 

	  

	public void logarithmic(int n) { // Algoritmo con una complejidad temporal logarítmica en cualquier base 

	if (n<0) 

	throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 

	} 	

	/**
	 * Método que comprueba si una matriz cuadrada es simetrica 
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	public boolean esSimetrica(int[][] m) { // Indica si es simétrica una matriz cuadrada de forma recursiva
		if (m.length == 1 && m[0].length == 1) {
			return true;
		} else if (!esCuadrada(m)) {
			return false;
		} else if (esIgualFilaColumna(m)){
			if (esSimetrica(eliminaFila(m))){
				return true;
			}			
		}
		return false;
	}
	
	/**
	 * Método que comprueba que la ultima fila es igual a la ultima columna
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	private boolean esIgualFilaColumna(int[][] m) {
		for (int i=0; i<m.length; i++) {
			if (m[m.length-1][i]!= m[i][m.length-1]) {
				return false;
			}
		}
		return true;
	}

	/**
	 * Método que elimina las filas de la matriz
	 * 
	 * @param m, matriz a la que eliminar las filas
	 * @return nueva matriz con las filas eliminadas
	 */
	private int[][] eliminaFila(int[][] m) {
		int [][] m2 = new int[m.length-1][m.length-1];		
		for (int i=0; i<m.length-1; i++) {
			for (int j=0; j<m.length-1; j++) {
				m2[i][j]=m[i][j];
			}
		}
		return m2;
	}
	
	/**
	 * Método que comprueba que una matriz es cuadrada
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	private boolean esCuadrada(int[][] m) {
		for (int i=0; i<m.length;i++) {
			if (m.length != m[i].length) {
				return false;
			}
		}
		return true;
	}
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-09-19 20:21:45.761
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-09-19 20:21:45.762
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-09-19 20:21:47.819
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package p1Algoritmia;

import java.security.InvalidParameterException;
/**
 * Titulo: Clase Algorithms
 * 
 * @author Omar Teixeira
 * @version 10/09/2021
 */
public class Algorithms {
	/**
	 * Constante Sleep Time
	 */
	private static final long SLEEP_TIME = 1;
	
	/**
	 * Método doNothing
	 */
	public static void doNothing() {
		try {
			Thread.sleep(SLEEP_TIME);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}

	/**
	 * Método que calcula el factorial de un numero mayor o igual a cero de forma recursiva
	 * 
	 * @param n, numero a calcular el factorial
	 * @return factorial
	 */
	public long factorial (int n) { // Calcula el factorial de n>=0 de forma recursiva
		doNothing();
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);		
		
		if (n==0)
			return 1;
		else
			return n*factorial(n-1);		
	} 
	
	/**
	 * Método que calcula el numero que ocupa el n introducido en la sucesión de fibonacci
	 * 
	 * @param n, numero a calcular el fibonacci
	 * @return valor fibonacci
	 */
	public int fibonacci (int n) { // Calcula el termino n-esimo teniendo en cuenta que el primer término se considera fib(0)=0; y fib(1)=1		
		if (n<0)
		throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		
		if (n==0)
			return 0;
		else if (n==1)
			return 1;
		else
			return fibonacci(n-1)+fibonacci(n-2);		
	} 
	
	/**
	 * Método que calcula la potencia recursiva 1 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec1(int n) {  // calcula 2 elevado a n de forma recursiva 2^n = 2*2^(n-1)
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		
		if (n==0)
			return 1;
		else 
			return 2*pow2Rec1(n-1);				
	} 
	
	/**
	 * Método que calcula la potencia iterativa de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Iter (int n) {  // calcula 2 elevado a n de forma iterativa 
	    if (n<0)
	    	throw new InvalidParameterException("No permitidos exponentes negativos como "+ n); 
	    
	    long pow=2;
	    for (int i=0; i<=n;i++) {
	    	doNothing();
	    	pow=2*pow;
	    }	    
	    return pow; 
	} 

	/**
	 * Método que calcula la potencia recursiva 2 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec2 (int n) { // calcula 2 elevado a n de forma recursiva 2^n = 2^(n-1)+2^(n-1) 
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		if (n==0)
			return 1;
		else 
			return pow2Rec2(n-1) + pow2Rec2(n-1);
	} 
	
	/**
	 * Método que calcula la potencia recursiva 3 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec3 (int n) { // calcula 2 elevado a n de forma recursiva 2^n = 2^(n/2)*2^(n/2) si n par y *2 si es impar 
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		if (n==0)
			return 1;
		else if (n%2==0)
			return pow2Rec3(n/2)*pow2Rec3(n/2);
		else 
			return pow2Rec3(n/2)*pow2Rec3(n/2)*2; 
	} 
	
	/**
	 * Método que calcula la potencia recursiva 4 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec4 (int n) {  // calcula 2 elevado a n de forma recursiva 2^n = como pow2Rec3 pero sin repetir llamada 
		doNothing();
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		if (n==0) {
			return 1;
		} else { 
			if (n%2==0) {
				long res = pow2Rec4(n/2);
				return res*res;
			}
			else { 
				long res = pow2Rec4(n/2);
				return 2*res*res;
			}
		}	
		} 
	  
	/**
	 * Método que calcula la potencia de un numero a elevado al numero introducido b
	 * 
	 * @param a, base
	 * @param b, exponente
	 * @return potencia de la base elevada al exponente
	 */
	public long potenciaRec(int a, int b) { // Calcula a elevado a b de forma recursiva por potencias sucesivas 
		if (a<0 || b<0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido"); 
		
		if(a==1 || b==0)
			return 1;
		else			
			return a*potenciaRec(a,b-1);
		 
	}
	
	/**
	 * Método que calcula el resto de la división de dos numeros
	 * 
	 * @param a, dividendo
	 * @param b, divisor
	 * @return resto
	 */
	public int restoDivRec (int a, int b) {  // calcula el resto de la división a/b de forma recursiva 
		if (a<0 || b<=0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido");
		
		if (a<b)
			return a;
		else
			return restoDivRec(a-b,b);		
	} 
	
	/**
	 * Método que calcula la división entera de dos numeros
	 * 
	 * @param a, dividendo
	 * @param b, divisor
	 * @return division entera
	 */
	public int divEntRec (int a, int b) {  // calcula la división entera a/b de forma recursiva 
		if (a<0 || b<=0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido");		
		
		if (a<b)
			return 0;
		else
			return 1+divEntRec(a-b,b);		
	} 
	
	/**
	 * Método que invierte un numero entero de forma recursiva
	 * 
	 * @param n, numero a invertir
	 * @return numero invertido
	 */
	public int invertirEnteroRec(int n) {  // Invierte un entero invertirEnteroRec(1234)=4321 de forma recursiva
		if (n<10)
			return n;
		else			
			return (n%10) * (int)Math.pow(10, Integer.toString(n/10).length())+ invertirEnteroRec(n/10);
	} 

	/**
	 * Método que invierte un string de forma recursiva
	 * 
	 * @param l, string a invertir
	 * @return string invertido
	 */
	public String invertirStringRec(String l) { // Invierte un string de forma recursiva invertirStringRec("abc")="cba" 
		if (l.length()==1)
			return l;
		else
			return invertirStringRec(l.substring(1)) + l.charAt(0);
	}
	  
	/**
	 * Método que tiene una complejidad temporal lineal
	 * 
	 * @param n, parametro
	 */
	public void linear (int n) { // Algoritmo con una complejidad temporal lineal 
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		for (int i=0; i<=n; i++) {
			doNothing();
			System.out.println("El algoritmo se ha ejecutado: " + i + " vez/veces");
		}
	} 

	/**
	 * Método que tiene una complejidad temporal lineal
	 * 
	 * @param n, parametro
	 */
	public void quadratic(int n) { // Algoritmo con una complejidad temporal cuadrática 
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		for (int i=0; i<=n; i++) {
			for (int j=0; j<=n;j++) {
				doNothing();
				System.out.println("El algoritmo se ha ejecutado: " + j + " vez/veces");
			}
			System.out.println("--------"+i+"---------");
		}
	} 

	  

	public void cubic(int n) { // Algoritmo con una complejidad temporal cúbica 
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		for (int i=0; i<=n; i++) {
			for (int j=0; j<=n;j++) {
				for (int k=0; k<=n;k++) {
					doNothing();
					("El algoritmo se ha ejecutado: " + k + " vez/veces");
				}
				System.out.println("--------"+j+"---------");
			}
			System.out.println("~~~~~~~~~"+j+"~~~~~~~~~");
		}

	} 

	  

	public void logarithmic(int n) { // Algoritmo con una complejidad temporal logarítmica en cualquier base 

	if (n<0) 

	throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 

	} 	

	/**
	 * Método que comprueba si una matriz cuadrada es simetrica 
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	public boolean esSimetrica(int[][] m) { // Indica si es simétrica una matriz cuadrada de forma recursiva
		if (m.length == 1 && m[0].length == 1) {
			return true;
		} else if (!esCuadrada(m)) {
			return false;
		} else if (esIgualFilaColumna(m)){
			if (esSimetrica(eliminaFila(m))){
				return true;
			}			
		}
		return false;
	}
	
	/**
	 * Método que comprueba que la ultima fila es igual a la ultima columna
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	private boolean esIgualFilaColumna(int[][] m) {
		for (int i=0; i<m.length; i++) {
			if (m[m.length-1][i]!= m[i][m.length-1]) {
				return false;
			}
		}
		return true;
	}

	/**
	 * Método que elimina las filas de la matriz
	 * 
	 * @param m, matriz a la que eliminar las filas
	 * @return nueva matriz con las filas eliminadas
	 */
	private int[][] eliminaFila(int[][] m) {
		int [][] m2 = new int[m.length-1][m.length-1];		
		for (int i=0; i<m.length-1; i++) {
			for (int j=0; j<m.length-1; j++) {
				m2[i][j]=m[i][j];
			}
		}
		return m2;
	}
	
	/**
	 * Método que comprueba que una matriz es cuadrada
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	private boolean esCuadrada(int[][] m) {
		for (int i=0; i<m.length;i++) {
			if (m.length != m[i].length) {
				return false;
			}
		}
		return true;
	}
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-09-19 20:21:47.821
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-09-19 20:21:47.822
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-09-19 20:21:49.730
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package p1Algoritmia;

import java.security.InvalidParameterException;
/**
 * Titulo: Clase Algorithms
 * 
 * @author Omar Teixeira
 * @version 10/09/2021
 */
public class Algorithms {
	/**
	 * Constante Sleep Time
	 */
	private static final long SLEEP_TIME = 1;
	
	/**
	 * Método doNothing
	 */
	public static void doNothing() {
		try {
			Thread.sleep(SLEEP_TIME);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}

	/**
	 * Método que calcula el factorial de un numero mayor o igual a cero de forma recursiva
	 * 
	 * @param n, numero a calcular el factorial
	 * @return factorial
	 */
	public long factorial (int n) { // Calcula el factorial de n>=0 de forma recursiva
		doNothing();
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);		
		
		if (n==0)
			return 1;
		else
			return n*factorial(n-1);		
	} 
	
	/**
	 * Método que calcula el numero que ocupa el n introducido en la sucesión de fibonacci
	 * 
	 * @param n, numero a calcular el fibonacci
	 * @return valor fibonacci
	 */
	public int fibonacci (int n) { // Calcula el termino n-esimo teniendo en cuenta que el primer término se considera fib(0)=0; y fib(1)=1		
		if (n<0)
		throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		
		if (n==0)
			return 0;
		else if (n==1)
			return 1;
		else
			return fibonacci(n-1)+fibonacci(n-2);		
	} 
	
	/**
	 * Método que calcula la potencia recursiva 1 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec1(int n) {  // calcula 2 elevado a n de forma recursiva 2^n = 2*2^(n-1)
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		
		if (n==0)
			return 1;
		else 
			return 2*pow2Rec1(n-1);				
	} 
	
	/**
	 * Método que calcula la potencia iterativa de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Iter (int n) {  // calcula 2 elevado a n de forma iterativa 
	    if (n<0)
	    	throw new InvalidParameterException("No permitidos exponentes negativos como "+ n); 
	    
	    long pow=2;
	    for (int i=0; i<=n;i++) {
	    	doNothing();
	    	pow=2*pow;
	    }	    
	    return pow; 
	} 

	/**
	 * Método que calcula la potencia recursiva 2 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec2 (int n) { // calcula 2 elevado a n de forma recursiva 2^n = 2^(n-1)+2^(n-1) 
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		if (n==0)
			return 1;
		else 
			return pow2Rec2(n-1) + pow2Rec2(n-1);
	} 
	
	/**
	 * Método que calcula la potencia recursiva 3 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec3 (int n) { // calcula 2 elevado a n de forma recursiva 2^n = 2^(n/2)*2^(n/2) si n par y *2 si es impar 
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		if (n==0)
			return 1;
		else if (n%2==0)
			return pow2Rec3(n/2)*pow2Rec3(n/2);
		else 
			return pow2Rec3(n/2)*pow2Rec3(n/2)*2; 
	} 
	
	/**
	 * Método que calcula la potencia recursiva 4 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec4 (int n) {  // calcula 2 elevado a n de forma recursiva 2^n = como pow2Rec3 pero sin repetir llamada 
		doNothing();
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		if (n==0) {
			return 1;
		} else { 
			if (n%2==0) {
				long res = pow2Rec4(n/2);
				return res*res;
			}
			else { 
				long res = pow2Rec4(n/2);
				return 2*res*res;
			}
		}	
		} 
	  
	/**
	 * Método que calcula la potencia de un numero a elevado al numero introducido b
	 * 
	 * @param a, base
	 * @param b, exponente
	 * @return potencia de la base elevada al exponente
	 */
	public long potenciaRec(int a, int b) { // Calcula a elevado a b de forma recursiva por potencias sucesivas 
		if (a<0 || b<0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido"); 
		
		if(a==1 || b==0)
			return 1;
		else			
			return a*potenciaRec(a,b-1);
		 
	}
	
	/**
	 * Método que calcula el resto de la división de dos numeros
	 * 
	 * @param a, dividendo
	 * @param b, divisor
	 * @return resto
	 */
	public int restoDivRec (int a, int b) {  // calcula el resto de la división a/b de forma recursiva 
		if (a<0 || b<=0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido");
		
		if (a<b)
			return a;
		else
			return restoDivRec(a-b,b);		
	} 
	
	/**
	 * Método que calcula la división entera de dos numeros
	 * 
	 * @param a, dividendo
	 * @param b, divisor
	 * @return division entera
	 */
	public int divEntRec (int a, int b) {  // calcula la división entera a/b de forma recursiva 
		if (a<0 || b<=0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido");		
		
		if (a<b)
			return 0;
		else
			return 1+divEntRec(a-b,b);		
	} 
	
	/**
	 * Método que invierte un numero entero de forma recursiva
	 * 
	 * @param n, numero a invertir
	 * @return numero invertido
	 */
	public int invertirEnteroRec(int n) {  // Invierte un entero invertirEnteroRec(1234)=4321 de forma recursiva
		if (n<10)
			return n;
		else			
			return (n%10) * (int)Math.pow(10, Integer.toString(n/10).length())+ invertirEnteroRec(n/10);
	} 

	/**
	 * Método que invierte un string de forma recursiva
	 * 
	 * @param l, string a invertir
	 * @return string invertido
	 */
	public String invertirStringRec(String l) { // Invierte un string de forma recursiva invertirStringRec("abc")="cba" 
		if (l.length()==1)
			return l;
		else
			return invertirStringRec(l.substring(1)) + l.charAt(0);
	}
	  
	/**
	 * Método que tiene una complejidad temporal lineal
	 * 
	 * @param n, parametro
	 */
	public void linear (int n) { // Algoritmo con una complejidad temporal lineal 
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		for (int i=0; i<=n; i++) {
			doNothing();
			System.out.println("El algoritmo se ha ejecutado: " + i + " vez/veces");
		}
	} 

	/**
	 * Método que tiene una complejidad temporal lineal
	 * 
	 * @param n, parametro
	 */
	public void quadratic(int n) { // Algoritmo con una complejidad temporal cuadrática 
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		for (int i=0; i<=n; i++) {
			for (int j=0; j<=n;j++) {
				doNothing();
				System.out.println("El algoritmo se ha ejecutado: " + j + " vez/veces");
			}
			System.out.println("--------"+i+"---------");
		}
	} 

	  

	public void cubic(int n) { // Algoritmo con una complejidad temporal cúbica 
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		for (int i=0; i<=n; i++) {
			for (int j=0; j<=n;j++) {
				for (int k=0; k<=n;k++) {
					doNothing();
					("El algoritmo se ha ejecutado: " + k + " vez/veces");
				}
				System.out.println("--------"+j+"---------");
			}
			System.out.println("~~~~~~~~~"+j+"~~~~~~~~~");
		}

	} 

	  

	public void logarithmic(int n) { // Algoritmo con una complejidad temporal logarítmica en cualquier base 

	if (n<0) 

	throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 

	} 	

	/**
	 * Método que comprueba si una matriz cuadrada es simetrica 
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	public boolean esSimetrica(int[][] m) { // Indica si es simétrica una matriz cuadrada de forma recursiva
		if (m.length == 1 && m[0].length == 1) {
			return true;
		} else if (!esCuadrada(m)) {
			return false;
		} else if (esIgualFilaColumna(m)){
			if (esSimetrica(eliminaFila(m))){
				return true;
			}			
		}
		return false;
	}
	
	/**
	 * Método que comprueba que la ultima fila es igual a la ultima columna
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	private boolean esIgualFilaColumna(int[][] m) {
		for (int i=0; i<m.length; i++) {
			if (m[m.length-1][i]!= m[i][m.length-1]) {
				return false;
			}
		}
		return true;
	}

	/**
	 * Método que elimina las filas de la matriz
	 * 
	 * @param m, matriz a la que eliminar las filas
	 * @return nueva matriz con las filas eliminadas
	 */
	private int[][] eliminaFila(int[][] m) {
		int [][] m2 = new int[m.length-1][m.length-1];		
		for (int i=0; i<m.length-1; i++) {
			for (int j=0; j<m.length-1; j++) {
				m2[i][j]=m[i][j];
			}
		}
		return m2;
	}
	
	/**
	 * Método que comprueba que una matriz es cuadrada
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	private boolean esCuadrada(int[][] m) {
		for (int i=0; i<m.length;i++) {
			if (m.length != m[i].length) {
				return false;
			}
		}
		return true;
	}
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-09-19 20:21:49.732
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-09-19 20:21:49.733
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.jdt.core 4 4 2021-09-19 20:21:49.737
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package p1Algoritmia;

import java.security.InvalidParameterException;
/**
 * Titulo: Clase Algorithms
 * 
 * @author Omar Teixeira
 * @version 10/09/2021
 */
public class Algorithms {
	/**
	 * Constante Sleep Time
	 */
	private static final long SLEEP_TIME = 1;
	
	/**
	 * Método doNothing
	 */
	public static void doNothing() {
		try {
			Thread.sleep(SLEEP_TIME);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}

	/**
	 * Método que calcula el factorial de un numero mayor o igual a cero de forma recursiva
	 * 
	 * @param n, numero a calcular el factorial
	 * @return factorial
	 */
	public long factorial (int n) { // Calcula el factorial de n>=0 de forma recursiva
		doNothing();
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);		
		
		if (n==0)
			return 1;
		else
			return n*factorial(n-1);		
	} 
	
	/**
	 * Método que calcula el numero que ocupa el n introducido en la sucesión de fibonacci
	 * 
	 * @param n, numero a calcular el fibonacci
	 * @return valor fibonacci
	 */
	public int fibonacci (int n) { // Calcula el termino n-esimo teniendo en cuenta que el primer término se considera fib(0)=0; y fib(1)=1		
		if (n<0)
		throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		
		if (n==0)
			return 0;
		else if (n==1)
			return 1;
		else
			return fibonacci(n-1)+fibonacci(n-2);		
	} 
	
	/**
	 * Método que calcula la potencia recursiva 1 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec1(int n) {  // calcula 2 elevado a n de forma recursiva 2^n = 2*2^(n-1)
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		
		if (n==0)
			return 1;
		else 
			return 2*pow2Rec1(n-1);				
	} 
	
	/**
	 * Método que calcula la potencia iterativa de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Iter (int n) {  // calcula 2 elevado a n de forma iterativa 
	    if (n<0)
	    	throw new InvalidParameterException("No permitidos exponentes negativos como "+ n); 
	    
	    long pow=2;
	    for (int i=0; i<=n;i++) {
	    	doNothing();
	    	pow=2*pow;
	    }	    
	    return pow; 
	} 

	/**
	 * Método que calcula la potencia recursiva 2 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec2 (int n) { // calcula 2 elevado a n de forma recursiva 2^n = 2^(n-1)+2^(n-1) 
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		if (n==0)
			return 1;
		else 
			return pow2Rec2(n-1) + pow2Rec2(n-1);
	} 
	
	/**
	 * Método que calcula la potencia recursiva 3 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec3 (int n) { // calcula 2 elevado a n de forma recursiva 2^n = 2^(n/2)*2^(n/2) si n par y *2 si es impar 
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		if (n==0)
			return 1;
		else if (n%2==0)
			return pow2Rec3(n/2)*pow2Rec3(n/2);
		else 
			return pow2Rec3(n/2)*pow2Rec3(n/2)*2; 
	} 
	
	/**
	 * Método que calcula la potencia recursiva 4 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec4 (int n) {  // calcula 2 elevado a n de forma recursiva 2^n = como pow2Rec3 pero sin repetir llamada 
		doNothing();
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		if (n==0) {
			return 1;
		} else { 
			if (n%2==0) {
				long res = pow2Rec4(n/2);
				return res*res;
			}
			else { 
				long res = pow2Rec4(n/2);
				return 2*res*res;
			}
		}	
		} 
	  
	/**
	 * Método que calcula la potencia de un numero a elevado al numero introducido b
	 * 
	 * @param a, base
	 * @param b, exponente
	 * @return potencia de la base elevada al exponente
	 */
	public long potenciaRec(int a, int b) { // Calcula a elevado a b de forma recursiva por potencias sucesivas 
		if (a<0 || b<0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido"); 
		
		if(a==1 || b==0)
			return 1;
		else			
			return a*potenciaRec(a,b-1);
		 
	}
	
	/**
	 * Método que calcula el resto de la división de dos numeros
	 * 
	 * @param a, dividendo
	 * @param b, divisor
	 * @return resto
	 */
	public int restoDivRec (int a, int b) {  // calcula el resto de la división a/b de forma recursiva 
		if (a<0 || b<=0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido");
		
		if (a<b)
			return a;
		else
			return restoDivRec(a-b,b);		
	} 
	
	/**
	 * Método que calcula la división entera de dos numeros
	 * 
	 * @param a, dividendo
	 * @param b, divisor
	 * @return division entera
	 */
	public int divEntRec (int a, int b) {  // calcula la división entera a/b de forma recursiva 
		if (a<0 || b<=0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido");		
		
		if (a<b)
			return 0;
		else
			return 1+divEntRec(a-b,b);		
	} 
	
	/**
	 * Método que invierte un numero entero de forma recursiva
	 * 
	 * @param n, numero a invertir
	 * @return numero invertido
	 */
	public int invertirEnteroRec(int n) {  // Invierte un entero invertirEnteroRec(1234)=4321 de forma recursiva
		if (n<10)
			return n;
		else			
			return (n%10) * (int)Math.pow(10, Integer.toString(n/10).length())+ invertirEnteroRec(n/10);
	} 

	/**
	 * Método que invierte un string de forma recursiva
	 * 
	 * @param l, string a invertir
	 * @return string invertido
	 */
	public String invertirStringRec(String l) { // Invierte un string de forma recursiva invertirStringRec("abc")="cba" 
		if (l.length()==1)
			return l;
		else
			return invertirStringRec(l.substring(1)) + l.charAt(0);
	}
	  
	/**
	 * Método que tiene una complejidad temporal lineal
	 * 
	 * @param n, parametro
	 */
	public void linear (int n) { // Algoritmo con una complejidad temporal lineal 
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		for (int i=0; i<=n; i++) {
			doNothing();
			System.out.println("El algoritmo se ha ejecutado: " + i + " vez/veces");
		}
	} 

	/**
	 * Método que tiene una complejidad temporal lineal
	 * 
	 * @param n, parametro
	 */
	public void quadratic(int n) { // Algoritmo con una complejidad temporal cuadrática 
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		for (int i=0; i<=n; i++) {
			for (int j=0; j<=n;j++) {
				doNothing();
				System.out.println("El algoritmo se ha ejecutado: " + j + " vez/veces");
			}
			System.out.println("--------"+i+"---------");
		}
	} 

	  

	public void cubic(int n) { // Algoritmo con una complejidad temporal cúbica 
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		for (int i=0; i<=n; i++) {
			for (int j=0; j<=n;j++) {
				for (int k=0; k<=n;k++) {
					doNothing();
					("El algoritmo se ha ejecutado: " + k + " vez/veces");
				}
				System.out.println("--------"+j+"---------");
			}
			System.out.println("~~~~~~~~~"+j+"~~~~~~~~~");
		}

	} 

	  

	public void logarithmic(int n) { // Algoritmo con una complejidad temporal logarítmica en cualquier base 

	if (n<0) 

	throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 

	} 	

	/**
	 * Método que comprueba si una matriz cuadrada es simetrica 
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	public boolean esSimetrica(int[][] m) { // Indica si es simétrica una matriz cuadrada de forma recursiva
		if (m.length == 1 && m[0].length == 1) {
			return true;
		} else if (!esCuadrada(m)) {
			return false;
		} else if (esIgualFilaColumna(m)){
			if (esSimetrica(eliminaFila(m))){
				return true;
			}			
		}
		return false;
	}
	
	/**
	 * Método que comprueba que la ultima fila es igual a la ultima columna
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	private boolean esIgualFilaColumna(int[][] m) {
		for (int i=0; i<m.length; i++) {
			if (m[m.length-1][i]!= m[i][m.length-1]) {
				return false;
			}
		}
		return true;
	}

	/**
	 * Método que elimina las filas de la matriz
	 * 
	 * @param m, matriz a la que eliminar las filas
	 * @return nueva matriz con las filas eliminadas
	 */
	private int[][] eliminaFila(int[][] m) {
		int [][] m2 = new int[m.length-1][m.length-1];		
		for (int i=0; i<m.length-1; i++) {
			for (int j=0; j<m.length-1; j++) {
				m2[i][j]=m[i][j];
			}
		}
		return m2;
	}
	
	/**
	 * Método que comprueba que una matriz es cuadrada
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	private boolean esCuadrada(int[][] m) {
		for (int i=0; i<m.length;i++) {
			if (m.length != m[i].length) {
				return false;
			}
		}
		return true;
	}
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1031)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.ui 4 0 2021-09-19 20:21:49.738
!MESSAGE Unhandled event loop exception
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1031)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.jdt.core 4 4 2021-09-19 20:21:50.558
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package p1Algoritmia;

import java.security.InvalidParameterException;
/**
 * Titulo: Clase Algorithms
 * 
 * @author Omar Teixeira
 * @version 10/09/2021
 */
public class Algorithms {
	/**
	 * Constante Sleep Time
	 */
	private static final long SLEEP_TIME = 1;
	
	/**
	 * Método doNothing
	 */
	public static void doNothing() {
		try {
			Thread.sleep(SLEEP_TIME);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}

	/**
	 * Método que calcula el factorial de un numero mayor o igual a cero de forma recursiva
	 * 
	 * @param n, numero a calcular el factorial
	 * @return factorial
	 */
	public long factorial (int n) { // Calcula el factorial de n>=0 de forma recursiva
		doNothing();
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);		
		
		if (n==0)
			return 1;
		else
			return n*factorial(n-1);		
	} 
	
	/**
	 * Método que calcula el numero que ocupa el n introducido en la sucesión de fibonacci
	 * 
	 * @param n, numero a calcular el fibonacci
	 * @return valor fibonacci
	 */
	public int fibonacci (int n) { // Calcula el termino n-esimo teniendo en cuenta que el primer término se considera fib(0)=0; y fib(1)=1		
		if (n<0)
		throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		
		if (n==0)
			return 0;
		else if (n==1)
			return 1;
		else
			return fibonacci(n-1)+fibonacci(n-2);		
	} 
	
	/**
	 * Método que calcula la potencia recursiva 1 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec1(int n) {  // calcula 2 elevado a n de forma recursiva 2^n = 2*2^(n-1)
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		
		if (n==0)
			return 1;
		else 
			return 2*pow2Rec1(n-1);				
	} 
	
	/**
	 * Método que calcula la potencia iterativa de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Iter (int n) {  // calcula 2 elevado a n de forma iterativa 
	    if (n<0)
	    	throw new InvalidParameterException("No permitidos exponentes negativos como "+ n); 
	    
	    long pow=2;
	    for (int i=0; i<=n;i++) {
	    	doNothing();
	    	pow=2*pow;
	    }	    
	    return pow; 
	} 

	/**
	 * Método que calcula la potencia recursiva 2 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec2 (int n) { // calcula 2 elevado a n de forma recursiva 2^n = 2^(n-1)+2^(n-1) 
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		if (n==0)
			return 1;
		else 
			return pow2Rec2(n-1) + pow2Rec2(n-1);
	} 
	
	/**
	 * Método que calcula la potencia recursiva 3 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec3 (int n) { // calcula 2 elevado a n de forma recursiva 2^n = 2^(n/2)*2^(n/2) si n par y *2 si es impar 
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		if (n==0)
			return 1;
		else if (n%2==0)
			return pow2Rec3(n/2)*pow2Rec3(n/2);
		else 
			return pow2Rec3(n/2)*pow2Rec3(n/2)*2; 
	} 
	
	/**
	 * Método que calcula la potencia recursiva 4 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec4 (int n) {  // calcula 2 elevado a n de forma recursiva 2^n = como pow2Rec3 pero sin repetir llamada 
		doNothing();
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		if (n==0) {
			return 1;
		} else { 
			if (n%2==0) {
				long res = pow2Rec4(n/2);
				return res*res;
			}
			else { 
				long res = pow2Rec4(n/2);
				return 2*res*res;
			}
		}	
		} 
	  
	/**
	 * Método que calcula la potencia de un numero a elevado al numero introducido b
	 * 
	 * @param a, base
	 * @param b, exponente
	 * @return potencia de la base elevada al exponente
	 */
	public long potenciaRec(int a, int b) { // Calcula a elevado a b de forma recursiva por potencias sucesivas 
		if (a<0 || b<0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido"); 
		
		if(a==1 || b==0)
			return 1;
		else			
			return a*potenciaRec(a,b-1);
		 
	}
	
	/**
	 * Método que calcula el resto de la división de dos numeros
	 * 
	 * @param a, dividendo
	 * @param b, divisor
	 * @return resto
	 */
	public int restoDivRec (int a, int b) {  // calcula el resto de la división a/b de forma recursiva 
		if (a<0 || b<=0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido");
		
		if (a<b)
			return a;
		else
			return restoDivRec(a-b,b);		
	} 
	
	/**
	 * Método que calcula la división entera de dos numeros
	 * 
	 * @param a, dividendo
	 * @param b, divisor
	 * @return division entera
	 */
	public int divEntRec (int a, int b) {  // calcula la división entera a/b de forma recursiva 
		if (a<0 || b<=0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido");		
		
		if (a<b)
			return 0;
		else
			return 1+divEntRec(a-b,b);		
	} 
	
	/**
	 * Método que invierte un numero entero de forma recursiva
	 * 
	 * @param n, numero a invertir
	 * @return numero invertido
	 */
	public int invertirEnteroRec(int n) {  // Invierte un entero invertirEnteroRec(1234)=4321 de forma recursiva
		if (n<10)
			return n;
		else			
			return (n%10) * (int)Math.pow(10, Integer.toString(n/10).length())+ invertirEnteroRec(n/10);
	} 

	/**
	 * Método que invierte un string de forma recursiva
	 * 
	 * @param l, string a invertir
	 * @return string invertido
	 */
	public String invertirStringRec(String l) { // Invierte un string de forma recursiva invertirStringRec("abc")="cba" 
		if (l.length()==1)
			return l;
		else
			return invertirStringRec(l.substring(1)) + l.charAt(0);
	}
	  
	/**
	 * Método que tiene una complejidad temporal lineal
	 * 
	 * @param n, parametro
	 */
	public void linear (int n) { // Algoritmo con una complejidad temporal lineal 
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		for (int i=0; i<=n; i++) {
			doNothing();
			System.out.println("El algoritmo se ha ejecutado: " + i + " vez/veces");
		}
	} 

	/**
	 * Método que tiene una complejidad temporal lineal
	 * 
	 * @param n, parametro
	 */
	public void quadratic(int n) { // Algoritmo con una complejidad temporal cuadrática 
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		for (int i=0; i<=n; i++) {
			for (int j=0; j<=n;j++) {
				doNothing();
				System.out.println("El algoritmo se ha ejecutado: " + j + " vez/veces");
			}
			System.out.println("--------"+i+"---------");
		}
	} 

	  

	public void cubic(int n) { // Algoritmo con una complejidad temporal cúbica 
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		for (int i=0; i<=n; i++) {
			for (int j=0; j<=n;j++) {
				for (int k=0; k<=n;k++) {
					doNothing();
					("El algoritmo se ha ejecutado: " + k + " vez/veces");
				}
				System.out.println("--------"+j+"---------");
			}
			System.out.println("~~~~~~~~~"+j+"~~~~~~~~~");
		}

	} 

	  

	public void logarithmic(int n) { // Algoritmo con una complejidad temporal logarítmica en cualquier base 

	if (n<0) 

	throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 

	} 	

	/**
	 * Método que comprueba si una matriz cuadrada es simetrica 
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	public boolean esSimetrica(int[][] m) { // Indica si es simétrica una matriz cuadrada de forma recursiva
		if (m.length == 1 && m[0].length == 1) {
			return true;
		} else if (!esCuadrada(m)) {
			return false;
		} else if (esIgualFilaColumna(m)){
			if (esSimetrica(eliminaFila(m))){
				return true;
			}			
		}
		return false;
	}
	
	/**
	 * Método que comprueba que la ultima fila es igual a la ultima columna
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	private boolean esIgualFilaColumna(int[][] m) {
		for (int i=0; i<m.length; i++) {
			if (m[m.length-1][i]!= m[i][m.length-1]) {
				return false;
			}
		}
		return true;
	}

	/**
	 * Método que elimina las filas de la matriz
	 * 
	 * @param m, matriz a la que eliminar las filas
	 * @return nueva matriz con las filas eliminadas
	 */
	private int[][] eliminaFila(int[][] m) {
		int [][] m2 = new int[m.length-1][m.length-1];		
		for (int i=0; i<m.length-1; i++) {
			for (int j=0; j<m.length-1; j++) {
				m2[i][j]=m[i][j];
			}
		}
		return m2;
	}
	
	/**
	 * Método que comprueba que una matriz es cuadrada
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	private boolean esCuadrada(int[][] m) {
		for (int i=0; i<m.length;i++) {
			if (m.length != m[i].length) {
				return false;
			}
		}
		return true;
	}
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-09-19 20:21:50.560
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-09-19 20:21:50.561
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.jdt.core 4 4 2021-09-19 20:21:50.565
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package p1Algoritmia;

import java.security.InvalidParameterException;
/**
 * Titulo: Clase Algorithms
 * 
 * @author Omar Teixeira
 * @version 10/09/2021
 */
public class Algorithms {
	/**
	 * Constante Sleep Time
	 */
	private static final long SLEEP_TIME = 1;
	
	/**
	 * Método doNothing
	 */
	public static void doNothing() {
		try {
			Thread.sleep(SLEEP_TIME);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}

	/**
	 * Método que calcula el factorial de un numero mayor o igual a cero de forma recursiva
	 * 
	 * @param n, numero a calcular el factorial
	 * @return factorial
	 */
	public long factorial (int n) { // Calcula el factorial de n>=0 de forma recursiva
		doNothing();
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);		
		
		if (n==0)
			return 1;
		else
			return n*factorial(n-1);		
	} 
	
	/**
	 * Método que calcula el numero que ocupa el n introducido en la sucesión de fibonacci
	 * 
	 * @param n, numero a calcular el fibonacci
	 * @return valor fibonacci
	 */
	public int fibonacci (int n) { // Calcula el termino n-esimo teniendo en cuenta que el primer término se considera fib(0)=0; y fib(1)=1		
		if (n<0)
		throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		
		if (n==0)
			return 0;
		else if (n==1)
			return 1;
		else
			return fibonacci(n-1)+fibonacci(n-2);		
	} 
	
	/**
	 * Método que calcula la potencia recursiva 1 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec1(int n) {  // calcula 2 elevado a n de forma recursiva 2^n = 2*2^(n-1)
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		
		if (n==0)
			return 1;
		else 
			return 2*pow2Rec1(n-1);				
	} 
	
	/**
	 * Método que calcula la potencia iterativa de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Iter (int n) {  // calcula 2 elevado a n de forma iterativa 
	    if (n<0)
	    	throw new InvalidParameterException("No permitidos exponentes negativos como "+ n); 
	    
	    long pow=2;
	    for (int i=0; i<=n;i++) {
	    	doNothing();
	    	pow=2*pow;
	    }	    
	    return pow; 
	} 

	/**
	 * Método que calcula la potencia recursiva 2 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec2 (int n) { // calcula 2 elevado a n de forma recursiva 2^n = 2^(n-1)+2^(n-1) 
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		if (n==0)
			return 1;
		else 
			return pow2Rec2(n-1) + pow2Rec2(n-1);
	} 
	
	/**
	 * Método que calcula la potencia recursiva 3 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec3 (int n) { // calcula 2 elevado a n de forma recursiva 2^n = 2^(n/2)*2^(n/2) si n par y *2 si es impar 
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		if (n==0)
			return 1;
		else if (n%2==0)
			return pow2Rec3(n/2)*pow2Rec3(n/2);
		else 
			return pow2Rec3(n/2)*pow2Rec3(n/2)*2; 
	} 
	
	/**
	 * Método que calcula la potencia recursiva 4 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec4 (int n) {  // calcula 2 elevado a n de forma recursiva 2^n = como pow2Rec3 pero sin repetir llamada 
		doNothing();
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		if (n==0) {
			return 1;
		} else { 
			if (n%2==0) {
				long res = pow2Rec4(n/2);
				return res*res;
			}
			else { 
				long res = pow2Rec4(n/2);
				return 2*res*res;
			}
		}	
		} 
	  
	/**
	 * Método que calcula la potencia de un numero a elevado al numero introducido b
	 * 
	 * @param a, base
	 * @param b, exponente
	 * @return potencia de la base elevada al exponente
	 */
	public long potenciaRec(int a, int b) { // Calcula a elevado a b de forma recursiva por potencias sucesivas 
		if (a<0 || b<0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido"); 
		
		if(a==1 || b==0)
			return 1;
		else			
			return a*potenciaRec(a,b-1);
		 
	}
	
	/**
	 * Método que calcula el resto de la división de dos numeros
	 * 
	 * @param a, dividendo
	 * @param b, divisor
	 * @return resto
	 */
	public int restoDivRec (int a, int b) {  // calcula el resto de la división a/b de forma recursiva 
		if (a<0 || b<=0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido");
		
		if (a<b)
			return a;
		else
			return restoDivRec(a-b,b);		
	} 
	
	/**
	 * Método que calcula la división entera de dos numeros
	 * 
	 * @param a, dividendo
	 * @param b, divisor
	 * @return division entera
	 */
	public int divEntRec (int a, int b) {  // calcula la división entera a/b de forma recursiva 
		if (a<0 || b<=0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido");		
		
		if (a<b)
			return 0;
		else
			return 1+divEntRec(a-b,b);		
	} 
	
	/**
	 * Método que invierte un numero entero de forma recursiva
	 * 
	 * @param n, numero a invertir
	 * @return numero invertido
	 */
	public int invertirEnteroRec(int n) {  // Invierte un entero invertirEnteroRec(1234)=4321 de forma recursiva
		if (n<10)
			return n;
		else			
			return (n%10) * (int)Math.pow(10, Integer.toString(n/10).length())+ invertirEnteroRec(n/10);
	} 

	/**
	 * Método que invierte un string de forma recursiva
	 * 
	 * @param l, string a invertir
	 * @return string invertido
	 */
	public String invertirStringRec(String l) { // Invierte un string de forma recursiva invertirStringRec("abc")="cba" 
		if (l.length()==1)
			return l;
		else
			return invertirStringRec(l.substring(1)) + l.charAt(0);
	}
	  
	/**
	 * Método que tiene una complejidad temporal lineal
	 * 
	 * @param n, parametro
	 */
	public void linear (int n) { // Algoritmo con una complejidad temporal lineal 
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		for (int i=0; i<=n; i++) {
			doNothing();
			System.out.println("El algoritmo se ha ejecutado: " + i + " vez/veces");
		}
	} 

	/**
	 * Método que tiene una complejidad temporal lineal
	 * 
	 * @param n, parametro
	 */
	public void quadratic(int n) { // Algoritmo con una complejidad temporal cuadrática 
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		for (int i=0; i<=n; i++) {
			for (int j=0; j<=n;j++) {
				doNothing();
				System.out.println("El algoritmo se ha ejecutado: " + j + " vez/veces");
			}
			System.out.println("--------"+i+"---------");
		}
	} 

	  

	public void cubic(int n) { // Algoritmo con una complejidad temporal cúbica 
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		for (int i=0; i<=n; i++) {
			for (int j=0; j<=n;j++) {
				for (int k=0; k<=n;k++) {
					doNothing();
					("El algoritmo se ha ejecutado: " + k + " vez/veces");
				}
				System.out.println("--------"+j+"---------");
			}
			System.out.println("~~~~~~~~~"+j+"~~~~~~~~~");
		}

	} 

	  

	public void logarithmic(int n) { // Algoritmo con una complejidad temporal logarítmica en cualquier base 

	if (n<0) 

	throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 

	} 	

	/**
	 * Método que comprueba si una matriz cuadrada es simetrica 
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	public boolean esSimetrica(int[][] m) { // Indica si es simétrica una matriz cuadrada de forma recursiva
		if (m.length == 1 && m[0].length == 1) {
			return true;
		} else if (!esCuadrada(m)) {
			return false;
		} else if (esIgualFilaColumna(m)){
			if (esSimetrica(eliminaFila(m))){
				return true;
			}			
		}
		return false;
	}
	
	/**
	 * Método que comprueba que la ultima fila es igual a la ultima columna
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	private boolean esIgualFilaColumna(int[][] m) {
		for (int i=0; i<m.length; i++) {
			if (m[m.length-1][i]!= m[i][m.length-1]) {
				return false;
			}
		}
		return true;
	}

	/**
	 * Método que elimina las filas de la matriz
	 * 
	 * @param m, matriz a la que eliminar las filas
	 * @return nueva matriz con las filas eliminadas
	 */
	private int[][] eliminaFila(int[][] m) {
		int [][] m2 = new int[m.length-1][m.length-1];		
		for (int i=0; i<m.length-1; i++) {
			for (int j=0; j<m.length-1; j++) {
				m2[i][j]=m[i][j];
			}
		}
		return m2;
	}
	
	/**
	 * Método que comprueba que una matriz es cuadrada
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	private boolean esCuadrada(int[][] m) {
		for (int i=0; i<m.length;i++) {
			if (m.length != m[i].length) {
				return false;
			}
		}
		return true;
	}
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1031)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.ui 4 0 2021-09-19 20:21:50.566
!MESSAGE Unhandled event loop exception
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1031)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.jdt.core 4 4 2021-09-19 20:21:53.690
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package p1Algoritmia;

import java.security.InvalidParameterException;
/**
 * Titulo: Clase Algorithms
 * 
 * @author Omar Teixeira
 * @version 10/09/2021
 */
public class Algorithms {
	/**
	 * Constante Sleep Time
	 */
	private static final long SLEEP_TIME = 1;
	
	/**
	 * Método doNothing
	 */
	public static void doNothing() {
		try {
			Thread.sleep(SLEEP_TIME);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}

	/**
	 * Método que calcula el factorial de un numero mayor o igual a cero de forma recursiva
	 * 
	 * @param n, numero a calcular el factorial
	 * @return factorial
	 */
	public long factorial (int n) { // Calcula el factorial de n>=0 de forma recursiva
		doNothing();
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);		
		
		if (n==0)
			return 1;
		else
			return n*factorial(n-1);		
	} 
	
	/**
	 * Método que calcula el numero que ocupa el n introducido en la sucesión de fibonacci
	 * 
	 * @param n, numero a calcular el fibonacci
	 * @return valor fibonacci
	 */
	public int fibonacci (int n) { // Calcula el termino n-esimo teniendo en cuenta que el primer término se considera fib(0)=0; y fib(1)=1		
		if (n<0)
		throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		
		if (n==0)
			return 0;
		else if (n==1)
			return 1;
		else
			return fibonacci(n-1)+fibonacci(n-2);		
	} 
	
	/**
	 * Método que calcula la potencia recursiva 1 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec1(int n) {  // calcula 2 elevado a n de forma recursiva 2^n = 2*2^(n-1)
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		
		if (n==0)
			return 1;
		else 
			return 2*pow2Rec1(n-1);				
	} 
	
	/**
	 * Método que calcula la potencia iterativa de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Iter (int n) {  // calcula 2 elevado a n de forma iterativa 
	    if (n<0)
	    	throw new InvalidParameterException("No permitidos exponentes negativos como "+ n); 
	    
	    long pow=2;
	    for (int i=0; i<=n;i++) {
	    	doNothing();
	    	pow=2*pow;
	    }	    
	    return pow; 
	} 

	/**
	 * Método que calcula la potencia recursiva 2 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec2 (int n) { // calcula 2 elevado a n de forma recursiva 2^n = 2^(n-1)+2^(n-1) 
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		if (n==0)
			return 1;
		else 
			return pow2Rec2(n-1) + pow2Rec2(n-1);
	} 
	
	/**
	 * Método que calcula la potencia recursiva 3 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec3 (int n) { // calcula 2 elevado a n de forma recursiva 2^n = 2^(n/2)*2^(n/2) si n par y *2 si es impar 
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		if (n==0)
			return 1;
		else if (n%2==0)
			return pow2Rec3(n/2)*pow2Rec3(n/2);
		else 
			return pow2Rec3(n/2)*pow2Rec3(n/2)*2; 
	} 
	
	/**
	 * Método que calcula la potencia recursiva 4 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec4 (int n) {  // calcula 2 elevado a n de forma recursiva 2^n = como pow2Rec3 pero sin repetir llamada 
		doNothing();
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		if (n==0) {
			return 1;
		} else { 
			if (n%2==0) {
				long res = pow2Rec4(n/2);
				return res*res;
			}
			else { 
				long res = pow2Rec4(n/2);
				return 2*res*res;
			}
		}	
		} 
	  
	/**
	 * Método que calcula la potencia de un numero a elevado al numero introducido b
	 * 
	 * @param a, base
	 * @param b, exponente
	 * @return potencia de la base elevada al exponente
	 */
	public long potenciaRec(int a, int b) { // Calcula a elevado a b de forma recursiva por potencias sucesivas 
		if (a<0 || b<0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido"); 
		
		if(a==1 || b==0)
			return 1;
		else			
			return a*potenciaRec(a,b-1);
		 
	}
	
	/**
	 * Método que calcula el resto de la división de dos numeros
	 * 
	 * @param a, dividendo
	 * @param b, divisor
	 * @return resto
	 */
	public int restoDivRec (int a, int b) {  // calcula el resto de la división a/b de forma recursiva 
		if (a<0 || b<=0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido");
		
		if (a<b)
			return a;
		else
			return restoDivRec(a-b,b);		
	} 
	
	/**
	 * Método que calcula la división entera de dos numeros
	 * 
	 * @param a, dividendo
	 * @param b, divisor
	 * @return division entera
	 */
	public int divEntRec (int a, int b) {  // calcula la división entera a/b de forma recursiva 
		if (a<0 || b<=0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido");		
		
		if (a<b)
			return 0;
		else
			return 1+divEntRec(a-b,b);		
	} 
	
	/**
	 * Método que invierte un numero entero de forma recursiva
	 * 
	 * @param n, numero a invertir
	 * @return numero invertido
	 */
	public int invertirEnteroRec(int n) {  // Invierte un entero invertirEnteroRec(1234)=4321 de forma recursiva
		if (n<10)
			return n;
		else			
			return (n%10) * (int)Math.pow(10, Integer.toString(n/10).length())+ invertirEnteroRec(n/10);
	} 

	/**
	 * Método que invierte un string de forma recursiva
	 * 
	 * @param l, string a invertir
	 * @return string invertido
	 */
	public String invertirStringRec(String l) { // Invierte un string de forma recursiva invertirStringRec("abc")="cba" 
		if (l.length()==1)
			return l;
		else
			return invertirStringRec(l.substring(1)) + l.charAt(0);
	}
	  
	/**
	 * Método que tiene una complejidad temporal lineal
	 * 
	 * @param n, parametro
	 */
	public void linear (int n) { // Algoritmo con una complejidad temporal lineal 
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		for (int i=0; i<=n; i++) {
			doNothing();
			System.out.println("El algoritmo se ha ejecutado: " + i + " vez/veces");
		}
	} 

	/**
	 * Método que tiene una complejidad temporal lineal
	 * 
	 * @param n, parametro
	 */
	public void quadratic(int n) { // Algoritmo con una complejidad temporal cuadrática 
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		for (int i=0; i<=n; i++) {
			for (int j=0; j<=n;j++) {
				doNothing();
				System.out.println("El algoritmo se ha ejecutado: " + j + " vez/veces");
			}
			System.out.println("--------"+i+"---------");
		}
	} 

	  

	public void cubic(int n) { // Algoritmo con una complejidad temporal cúbica 
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		for (int i=0; i<=n; i++) {
			for (int j=0; j<=n;j++) {
				for (int k=0; k<=n;k++) {
					doNothing();
					("El algoritmo se ha ejecutado: " + k + " vez/veces");
				}
				System.out.println("--------"+j+"---------");
			}
			System.out.println("~~~~~~~~~"+j+"~~~~~~~~~");
		}

	} 

	  

	public void logarithmic(int n) { // Algoritmo con una complejidad temporal logarítmica en cualquier base 

	if (n<0) 

	throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 

	} 	

	/**
	 * Método que comprueba si una matriz cuadrada es simetrica 
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	public boolean esSimetrica(int[][] m) { // Indica si es simétrica una matriz cuadrada de forma recursiva
		if (m.length == 1 && m[0].length == 1) {
			return true;
		} else if (!esCuadrada(m)) {
			return false;
		} else if (esIgualFilaColumna(m)){
			if (esSimetrica(eliminaFila(m))){
				return true;
			}			
		}
		return false;
	}
	
	/**
	 * Método que comprueba que la ultima fila es igual a la ultima columna
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	private boolean esIgualFilaColumna(int[][] m) {
		for (int i=0; i<m.length; i++) {
			if (m[m.length-1][i]!= m[i][m.length-1]) {
				return false;
			}
		}
		return true;
	}

	/**
	 * Método que elimina las filas de la matriz
	 * 
	 * @param m, matriz a la que eliminar las filas
	 * @return nueva matriz con las filas eliminadas
	 */
	private int[][] eliminaFila(int[][] m) {
		int [][] m2 = new int[m.length-1][m.length-1];		
		for (int i=0; i<m.length-1; i++) {
			for (int j=0; j<m.length-1; j++) {
				m2[i][j]=m[i][j];
			}
		}
		return m2;
	}
	
	/**
	 * Método que comprueba que una matriz es cuadrada
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	private boolean esCuadrada(int[][] m) {
		for (int i=0; i<m.length;i++) {
			if (m.length != m[i].length) {
				return false;
			}
		}
		return true;
	}
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:439)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:366)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:326)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:276)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at jdk.internal.reflect.GeneratedMethodAccessor50.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:319)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:253)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:487)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:584)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:653)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:443)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1270)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1042)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1067)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1052)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1094)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1519)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4882)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4760)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4930)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3624)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-09-19 20:21:53.692
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:439)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:366)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:326)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:276)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at jdk.internal.reflect.GeneratedMethodAccessor50.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:319)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:253)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:487)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:584)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:653)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:443)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1270)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1042)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1067)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1052)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1094)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1519)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4882)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4760)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4930)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3624)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-09-19 20:21:53.693
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:439)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:366)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:326)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:276)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at jdk.internal.reflect.GeneratedMethodAccessor50.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:319)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:253)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:487)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:584)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:653)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:443)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1270)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1042)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1067)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1052)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1094)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1519)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4882)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4760)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4930)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3624)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.jdt.core 4 4 2021-09-19 20:21:54.093
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package p1Algoritmia;

import java.security.InvalidParameterException;
/**
 * Titulo: Clase Algorithms
 * 
 * @author Omar Teixeira
 * @version 10/09/2021
 */
public class Algorithms {
	/**
	 * Constante Sleep Time
	 */
	private static final long SLEEP_TIME = 1;
	
	/**
	 * Método doNothing
	 */
	public static void doNothing() {
		try {
			Thread.sleep(SLEEP_TIME);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}

	/**
	 * Método que calcula el factorial de un numero mayor o igual a cero de forma recursiva
	 * 
	 * @param n, numero a calcular el factorial
	 * @return factorial
	 */
	public long factorial (int n) { // Calcula el factorial de n>=0 de forma recursiva
		doNothing();
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);		
		
		if (n==0)
			return 1;
		else
			return n*factorial(n-1);		
	} 
	
	/**
	 * Método que calcula el numero que ocupa el n introducido en la sucesión de fibonacci
	 * 
	 * @param n, numero a calcular el fibonacci
	 * @return valor fibonacci
	 */
	public int fibonacci (int n) { // Calcula el termino n-esimo teniendo en cuenta que el primer término se considera fib(0)=0; y fib(1)=1		
		if (n<0)
		throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		
		if (n==0)
			return 0;
		else if (n==1)
			return 1;
		else
			return fibonacci(n-1)+fibonacci(n-2);		
	} 
	
	/**
	 * Método que calcula la potencia recursiva 1 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec1(int n) {  // calcula 2 elevado a n de forma recursiva 2^n = 2*2^(n-1)
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		
		if (n==0)
			return 1;
		else 
			return 2*pow2Rec1(n-1);				
	} 
	
	/**
	 * Método que calcula la potencia iterativa de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Iter (int n) {  // calcula 2 elevado a n de forma iterativa 
	    if (n<0)
	    	throw new InvalidParameterException("No permitidos exponentes negativos como "+ n); 
	    
	    long pow=2;
	    for (int i=0; i<=n;i++) {
	    	doNothing();
	    	pow=2*pow;
	    }	    
	    return pow; 
	} 

	/**
	 * Método que calcula la potencia recursiva 2 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec2 (int n) { // calcula 2 elevado a n de forma recursiva 2^n = 2^(n-1)+2^(n-1) 
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		if (n==0)
			return 1;
		else 
			return pow2Rec2(n-1) + pow2Rec2(n-1);
	} 
	
	/**
	 * Método que calcula la potencia recursiva 3 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec3 (int n) { // calcula 2 elevado a n de forma recursiva 2^n = 2^(n/2)*2^(n/2) si n par y *2 si es impar 
		doNothing();
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		if (n==0)
			return 1;
		else if (n%2==0)
			return pow2Rec3(n/2)*pow2Rec3(n/2);
		else 
			return pow2Rec3(n/2)*pow2Rec3(n/2)*2; 
	} 
	
	/**
	 * Método que calcula la potencia recursiva 4 de 2 elevado al numero introducido n
	 * 
	 * @param n, numero al que elevar el 2
	 * @return potencia de 2 elevado a n
	 */
	public long pow2Rec4 (int n) {  // calcula 2 elevado a n de forma recursiva 2^n = como pow2Rec3 pero sin repetir llamada 
		doNothing();
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		if (n==0) {
			return 1;
		} else { 
			if (n%2==0) {
				long res = pow2Rec4(n/2);
				return res*res;
			}
			else { 
				long res = pow2Rec4(n/2);
				return 2*res*res;
			}
		}	
		} 
	  
	/**
	 * Método que calcula la potencia de un numero a elevado al numero introducido b
	 * 
	 * @param a, base
	 * @param b, exponente
	 * @return potencia de la base elevada al exponente
	 */
	public long potenciaRec(int a, int b) { // Calcula a elevado a b de forma recursiva por potencias sucesivas 
		if (a<0 || b<0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido"); 
		
		if(a==1 || b==0)
			return 1;
		else			
			return a*potenciaRec(a,b-1);
		 
	}
	
	/**
	 * Método que calcula el resto de la división de dos numeros
	 * 
	 * @param a, dividendo
	 * @param b, divisor
	 * @return resto
	 */
	public int restoDivRec (int a, int b) {  // calcula el resto de la división a/b de forma recursiva 
		if (a<0 || b<=0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido");
		
		if (a<b)
			return a;
		else
			return restoDivRec(a-b,b);		
	} 
	
	/**
	 * Método que calcula la división entera de dos numeros
	 * 
	 * @param a, dividendo
	 * @param b, divisor
	 * @return division entera
	 */
	public int divEntRec (int a, int b) {  // calcula la división entera a/b de forma recursiva 
		if (a<0 || b<=0) 
			throw new InvalidParameterException("No permitido alguno de los parámetros introducido");		
		
		if (a<b)
			return 0;
		else
			return 1+divEntRec(a-b,b);		
	} 
	
	/**
	 * Método que invierte un numero entero de forma recursiva
	 * 
	 * @param n, numero a invertir
	 * @return numero invertido
	 */
	public int invertirEnteroRec(int n) {  // Invierte un entero invertirEnteroRec(1234)=4321 de forma recursiva
		if (n<10)
			return n;
		else			
			return (n%10) * (int)Math.pow(10, Integer.toString(n/10).length())+ invertirEnteroRec(n/10);
	} 

	/**
	 * Método que invierte un string de forma recursiva
	 * 
	 * @param l, string a invertir
	 * @return string invertido
	 */
	public String invertirStringRec(String l) { // Invierte un string de forma recursiva invertirStringRec("abc")="cba" 
		if (l.length()==1)
			return l;
		else
			return invertirStringRec(l.substring(1)) + l.charAt(0);
	}
	  
	/**
	 * Método que tiene una complejidad temporal lineal
	 * 
	 * @param n, parametro
	 */
	public void linear (int n) { // Algoritmo con una complejidad temporal lineal 
		if (n<0) 
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 
		for (int i=0; i<=n; i++) {
			doNothing();
			System.out.println("El algoritmo se ha ejecutado: " + i + " vez/veces");
		}
	} 

	/**
	 * Método que tiene una complejidad temporal lineal
	 * 
	 * @param n, parametro
	 */
	public void quadratic(int n) { // Algoritmo con una complejidad temporal cuadrática 
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		for (int i=0; i<=n; i++) {
			for (int j=0; j<=n;j++) {
				doNothing();
				System.out.println("El algoritmo se ha ejecutado: " + j + " vez/veces");
			}
			System.out.println("--------"+i+"---------");
		}
	} 

	  

	public void cubic(int n) { // Algoritmo con una complejidad temporal cúbica 
		if (n<0)
			throw new InvalidParameterException("No permitidos parámetros negativos como "+ n);
		for (int i=0; i<=n; i++) {
			for (int j=0; j<=n;j++) {
				for (int k=0; k<=n;k++) {
					doNothing();
					("El algoritmo se ha ejecutado: " + k + " vez/veces");
				}
				System.out.println("--------"+j+"---------");
			}
			System.out.println("~~~~~~~~~"+j+"~~~~~~~~~");
		}

	} 

	  

	public void logarithmic(int n) { // Algoritmo con una complejidad temporal logarítmica en cualquier base 

	if (n<0) 

	throw new InvalidParameterException("No permitidos parámetros negativos como "+ n); 

	} 	

	/**
	 * Método que comprueba si una matriz cuadrada es simetrica 
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	public boolean esSimetrica(int[][] m) { // Indica si es simétrica una matriz cuadrada de forma recursiva
		if (m.length == 1 && m[0].length == 1) {
			return true;
		} else if (!esCuadrada(m)) {
			return false;
		} else if (esIgualFilaColumna(m)){
			if (esSimetrica(eliminaFila(m))){
				return true;
			}			
		}
		return false;
	}
	
	/**
	 * Método que comprueba que la ultima fila es igual a la ultima columna
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	private boolean esIgualFilaColumna(int[][] m) {
		for (int i=0; i<m.length; i++) {
			if (m[m.length-1][i]!= m[i][m.length-1]) {
				return false;
			}
		}
		return true;
	}

	/**
	 * Método que elimina las filas de la matriz
	 * 
	 * @param m, matriz a la que eliminar las filas
	 * @return nueva matriz con las filas eliminadas
	 */
	private int[][] eliminaFila(int[][] m) {
		int [][] m2 = new int[m.length-1][m.length-1];		
		for (int i=0; i<m.length-1; i++) {
			for (int j=0; j<m.length-1; j++) {
				m2[i][j]=m[i][j];
			}
		}
		return m2;
	}
	
	/**
	 * Método que comprueba que una matriz es cuadrada
	 * 
	 * @param m, matriz a comprobar
	 * @return true o false
	 */
	private boolean esCuadrada(int[][] m) {
		for (int i=0; i<m.length;i++) {
			if (m.length != m[i].length) {
				return false;
			}
		}
		return true;
	}
	
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-09-19 20:21:54.095
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-09-19 20:21:54.096
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.ui.workbench.texteditor 4 0 2021-09-19 20:22:31.042
!MESSAGE 
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.ui.texteditor.ITextEditor.isDirty()" because "this.fTextEditor" is null
	at org.eclipse.ui.texteditor.AbstractTextEditor$TextEditorSavable.isDirty(AbstractTextEditor.java:7165)
	at org.eclipse.ui.internal.Workbench.getFilteredSaveables(Workbench.java:3447)
	at org.eclipse.ui.internal.Workbench.saveAll(Workbench.java:3420)
	at org.eclipse.ui.ide.IDE$1.run(IDE.java:1494)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.ide.IDE.saveAllEditors(IDE.java:1482)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.doSave(SaveScopeResourcesHandler.java:228)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.handleStatus(SaveScopeResourcesHandler.java:182)
	at org.eclipse.debug.internal.ui.sourcelookup.Prompter.lambda$0(Prompter.java:73)
	at org.eclipse.ui.internal.PendingSyncExec.run(PendingSyncExec.java:68)
	at org.eclipse.ui.internal.UILockListener.doPendingWork(UILockListener.java:171)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.ui.workbench.texteditor 4 0 2021-09-19 20:22:48.656
!MESSAGE 
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.ui.texteditor.ITextEditor.isDirty()" because "this.fTextEditor" is null
	at org.eclipse.ui.texteditor.AbstractTextEditor$TextEditorSavable.isDirty(AbstractTextEditor.java:7165)
	at org.eclipse.ui.internal.Workbench.getFilteredSaveables(Workbench.java:3447)
	at org.eclipse.ui.internal.Workbench.saveAll(Workbench.java:3420)
	at org.eclipse.ui.ide.IDE$1.run(IDE.java:1494)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.ide.IDE.saveAllEditors(IDE.java:1482)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.doSave(SaveScopeResourcesHandler.java:228)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.handleStatus(SaveScopeResourcesHandler.java:182)
	at org.eclipse.debug.internal.ui.sourcelookup.Prompter.lambda$0(Prompter.java:73)
	at org.eclipse.ui.internal.PendingSyncExec.run(PendingSyncExec.java:68)
	at org.eclipse.ui.internal.UILockListener.doPendingWork(UILockListener.java:171)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.ui.workbench.texteditor 4 0 2021-09-19 20:26:17.143
!MESSAGE 
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.ui.texteditor.ITextEditor.isDirty()" because "this.fTextEditor" is null
	at org.eclipse.ui.texteditor.AbstractTextEditor$TextEditorSavable.isDirty(AbstractTextEditor.java:7165)
	at org.eclipse.ui.internal.Workbench.getFilteredSaveables(Workbench.java:3447)
	at org.eclipse.ui.internal.Workbench.saveAll(Workbench.java:3420)
	at org.eclipse.ui.ide.IDE$1.run(IDE.java:1494)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.ide.IDE.saveAllEditors(IDE.java:1482)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.doSave(SaveScopeResourcesHandler.java:228)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.handleStatus(SaveScopeResourcesHandler.java:182)
	at org.eclipse.debug.internal.ui.sourcelookup.Prompter.lambda$0(Prompter.java:73)
	at org.eclipse.ui.internal.PendingSyncExec.run(PendingSyncExec.java:68)
	at org.eclipse.ui.internal.UILockListener.doPendingWork(UILockListener.java:171)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.ui.workbench.texteditor 4 0 2021-09-19 20:35:43.369
!MESSAGE 
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.ui.texteditor.ITextEditor.isDirty()" because "this.fTextEditor" is null
	at org.eclipse.ui.texteditor.AbstractTextEditor$TextEditorSavable.isDirty(AbstractTextEditor.java:7165)
	at org.eclipse.ui.internal.Workbench.getFilteredSaveables(Workbench.java:3447)
	at org.eclipse.ui.internal.Workbench.saveAll(Workbench.java:3420)
	at org.eclipse.ui.ide.IDE$1.run(IDE.java:1494)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.ide.IDE.saveAllEditors(IDE.java:1482)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.doSave(SaveScopeResourcesHandler.java:228)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.handleStatus(SaveScopeResourcesHandler.java:182)
	at org.eclipse.debug.internal.ui.sourcelookup.Prompter.lambda$0(Prompter.java:73)
	at org.eclipse.ui.internal.PendingSyncExec.run(PendingSyncExec.java:68)
	at org.eclipse.ui.internal.UILockListener.doPendingWork(UILockListener.java:171)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.ui.workbench.texteditor 4 0 2021-09-19 20:35:51.500
!MESSAGE 
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.ui.texteditor.ITextEditor.isDirty()" because "this.fTextEditor" is null
	at org.eclipse.ui.texteditor.AbstractTextEditor$TextEditorSavable.isDirty(AbstractTextEditor.java:7165)
	at org.eclipse.ui.internal.Workbench.getFilteredSaveables(Workbench.java:3447)
	at org.eclipse.ui.internal.Workbench.saveAll(Workbench.java:3420)
	at org.eclipse.ui.ide.IDE$1.run(IDE.java:1494)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.ide.IDE.saveAllEditors(IDE.java:1482)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.doSave(SaveScopeResourcesHandler.java:228)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.handleStatus(SaveScopeResourcesHandler.java:182)
	at org.eclipse.debug.internal.ui.sourcelookup.Prompter.lambda$0(Prompter.java:73)
	at org.eclipse.ui.internal.PendingSyncExec.run(PendingSyncExec.java:68)
	at org.eclipse.ui.internal.UILockListener.doPendingWork(UILockListener.java:171)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.ui.workbench.texteditor 4 0 2021-09-19 20:36:15.585
!MESSAGE 
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.ui.texteditor.ITextEditor.isDirty()" because "this.fTextEditor" is null
	at org.eclipse.ui.texteditor.AbstractTextEditor$TextEditorSavable.isDirty(AbstractTextEditor.java:7165)
	at org.eclipse.ui.internal.Workbench.getFilteredSaveables(Workbench.java:3447)
	at org.eclipse.ui.internal.Workbench.saveAll(Workbench.java:3420)
	at org.eclipse.ui.ide.IDE$1.run(IDE.java:1494)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.ide.IDE.saveAllEditors(IDE.java:1482)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.doSave(SaveScopeResourcesHandler.java:228)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.handleStatus(SaveScopeResourcesHandler.java:182)
	at org.eclipse.debug.internal.ui.sourcelookup.Prompter.lambda$0(Prompter.java:73)
	at org.eclipse.ui.internal.PendingSyncExec.run(PendingSyncExec.java:68)
	at org.eclipse.ui.internal.UILockListener.doPendingWork(UILockListener.java:171)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.ui.workbench.texteditor 4 0 2021-09-19 20:38:45.648
!MESSAGE 
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.ui.texteditor.ITextEditor.isDirty()" because "this.fTextEditor" is null
	at org.eclipse.ui.texteditor.AbstractTextEditor$TextEditorSavable.isDirty(AbstractTextEditor.java:7165)
	at org.eclipse.ui.internal.Workbench.getFilteredSaveables(Workbench.java:3447)
	at org.eclipse.ui.internal.Workbench.saveAll(Workbench.java:3420)
	at org.eclipse.ui.ide.IDE$1.run(IDE.java:1494)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.ide.IDE.saveAllEditors(IDE.java:1482)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.doSave(SaveScopeResourcesHandler.java:228)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.handleStatus(SaveScopeResourcesHandler.java:182)
	at org.eclipse.debug.internal.ui.sourcelookup.Prompter.lambda$0(Prompter.java:73)
	at org.eclipse.ui.internal.PendingSyncExec.run(PendingSyncExec.java:68)
	at org.eclipse.ui.internal.UILockListener.doPendingWork(UILockListener.java:171)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.ui.workbench.texteditor 4 0 2021-09-19 20:48:32.119
!MESSAGE 
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.ui.texteditor.ITextEditor.isDirty()" because "this.fTextEditor" is null
	at org.eclipse.ui.texteditor.AbstractTextEditor$TextEditorSavable.isDirty(AbstractTextEditor.java:7165)
	at org.eclipse.ui.internal.Workbench.getFilteredSaveables(Workbench.java:3447)
	at org.eclipse.ui.internal.Workbench.saveAll(Workbench.java:3420)
	at org.eclipse.ui.ide.IDE$1.run(IDE.java:1494)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.ide.IDE.saveAllEditors(IDE.java:1482)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.doSave(SaveScopeResourcesHandler.java:228)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.handleStatus(SaveScopeResourcesHandler.java:182)
	at org.eclipse.debug.internal.ui.sourcelookup.Prompter.lambda$0(Prompter.java:73)
	at org.eclipse.ui.internal.PendingSyncExec.run(PendingSyncExec.java:68)
	at org.eclipse.ui.internal.UILockListener.doPendingWork(UILockListener.java:171)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.ui.workbench.texteditor 4 0 2021-09-19 20:48:51.576
!MESSAGE 
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.ui.texteditor.ITextEditor.isDirty()" because "this.fTextEditor" is null
	at org.eclipse.ui.texteditor.AbstractTextEditor$TextEditorSavable.isDirty(AbstractTextEditor.java:7165)
	at org.eclipse.ui.internal.Workbench.getFilteredSaveables(Workbench.java:3447)
	at org.eclipse.ui.internal.Workbench.saveAll(Workbench.java:3420)
	at org.eclipse.ui.ide.IDE$1.run(IDE.java:1494)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.ide.IDE.saveAllEditors(IDE.java:1482)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.doSave(SaveScopeResourcesHandler.java:228)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.handleStatus(SaveScopeResourcesHandler.java:182)
	at org.eclipse.debug.internal.ui.sourcelookup.Prompter.lambda$0(Prompter.java:73)
	at org.eclipse.ui.internal.PendingSyncExec.run(PendingSyncExec.java:68)
	at org.eclipse.ui.internal.UILockListener.doPendingWork(UILockListener.java:171)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.ui.workbench.texteditor 4 0 2021-09-19 20:49:09.229
!MESSAGE 
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.ui.texteditor.ITextEditor.isDirty()" because "this.fTextEditor" is null
	at org.eclipse.ui.texteditor.AbstractTextEditor$TextEditorSavable.isDirty(AbstractTextEditor.java:7165)
	at org.eclipse.ui.internal.Workbench.getFilteredSaveables(Workbench.java:3447)
	at org.eclipse.ui.internal.Workbench.saveAll(Workbench.java:3420)
	at org.eclipse.ui.ide.IDE$1.run(IDE.java:1494)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.ide.IDE.saveAllEditors(IDE.java:1482)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.doSave(SaveScopeResourcesHandler.java:228)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.handleStatus(SaveScopeResourcesHandler.java:182)
	at org.eclipse.debug.internal.ui.sourcelookup.Prompter.lambda$0(Prompter.java:73)
	at org.eclipse.ui.internal.PendingSyncExec.run(PendingSyncExec.java:68)
	at org.eclipse.ui.internal.UILockListener.doPendingWork(UILockListener.java:171)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.ui.workbench.texteditor 4 0 2021-09-19 20:49:25.646
!MESSAGE 
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.ui.texteditor.ITextEditor.isDirty()" because "this.fTextEditor" is null
	at org.eclipse.ui.texteditor.AbstractTextEditor$TextEditorSavable.isDirty(AbstractTextEditor.java:7165)
	at org.eclipse.ui.internal.Workbench.getFilteredSaveables(Workbench.java:3447)
	at org.eclipse.ui.internal.Workbench.saveAll(Workbench.java:3420)
	at org.eclipse.ui.ide.IDE$1.run(IDE.java:1494)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.ide.IDE.saveAllEditors(IDE.java:1482)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.doSave(SaveScopeResourcesHandler.java:228)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.handleStatus(SaveScopeResourcesHandler.java:182)
	at org.eclipse.debug.internal.ui.sourcelookup.Prompter.lambda$0(Prompter.java:73)
	at org.eclipse.ui.internal.PendingSyncExec.run(PendingSyncExec.java:68)
	at org.eclipse.ui.internal.UILockListener.doPendingWork(UILockListener.java:171)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.ui.workbench.texteditor 4 0 2021-09-19 20:52:09.137
!MESSAGE 
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.ui.texteditor.ITextEditor.isDirty()" because "this.fTextEditor" is null
	at org.eclipse.ui.texteditor.AbstractTextEditor$TextEditorSavable.isDirty(AbstractTextEditor.java:7165)
	at org.eclipse.ui.internal.Workbench.getFilteredSaveables(Workbench.java:3447)
	at org.eclipse.ui.internal.Workbench.saveAll(Workbench.java:3420)
	at org.eclipse.ui.ide.IDE$1.run(IDE.java:1494)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.ide.IDE.saveAllEditors(IDE.java:1482)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.doSave(SaveScopeResourcesHandler.java:228)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.handleStatus(SaveScopeResourcesHandler.java:182)
	at org.eclipse.debug.internal.ui.sourcelookup.Prompter.lambda$0(Prompter.java:73)
	at org.eclipse.ui.internal.PendingSyncExec.run(PendingSyncExec.java:68)
	at org.eclipse.ui.internal.UILockListener.doPendingWork(UILockListener.java:171)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.ui.workbench.texteditor 4 0 2021-09-19 20:52:48.531
!MESSAGE 
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.ui.texteditor.ITextEditor.isDirty()" because "this.fTextEditor" is null
	at org.eclipse.ui.texteditor.AbstractTextEditor$TextEditorSavable.isDirty(AbstractTextEditor.java:7165)
	at org.eclipse.ui.internal.Workbench.getFilteredSaveables(Workbench.java:3447)
	at org.eclipse.ui.internal.Workbench.saveAll(Workbench.java:3420)
	at org.eclipse.ui.ide.IDE$1.run(IDE.java:1494)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.ide.IDE.saveAllEditors(IDE.java:1482)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.doSave(SaveScopeResourcesHandler.java:228)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.handleStatus(SaveScopeResourcesHandler.java:182)
	at org.eclipse.debug.internal.ui.sourcelookup.Prompter.lambda$0(Prompter.java:73)
	at org.eclipse.ui.internal.PendingSyncExec.run(PendingSyncExec.java:68)
	at org.eclipse.ui.internal.UILockListener.doPendingWork(UILockListener.java:171)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.ui.workbench.texteditor 4 0 2021-09-19 20:54:50.677
!MESSAGE 
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.ui.texteditor.ITextEditor.isDirty()" because "this.fTextEditor" is null
	at org.eclipse.ui.texteditor.AbstractTextEditor$TextEditorSavable.isDirty(AbstractTextEditor.java:7165)
	at org.eclipse.ui.internal.Workbench.getFilteredSaveables(Workbench.java:3447)
	at org.eclipse.ui.internal.Workbench.saveAll(Workbench.java:3420)
	at org.eclipse.ui.ide.IDE$1.run(IDE.java:1494)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.ide.IDE.saveAllEditors(IDE.java:1482)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.doSave(SaveScopeResourcesHandler.java:228)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.handleStatus(SaveScopeResourcesHandler.java:182)
	at org.eclipse.debug.internal.ui.sourcelookup.Prompter.lambda$0(Prompter.java:73)
	at org.eclipse.ui.internal.PendingSyncExec.run(PendingSyncExec.java:68)
	at org.eclipse.ui.internal.UILockListener.doPendingWork(UILockListener.java:171)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.ui.workbench.texteditor 4 0 2021-09-19 20:55:05.793
!MESSAGE 
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.ui.texteditor.ITextEditor.isDirty()" because "this.fTextEditor" is null
	at org.eclipse.ui.texteditor.AbstractTextEditor$TextEditorSavable.isDirty(AbstractTextEditor.java:7165)
	at org.eclipse.ui.internal.Workbench.getFilteredSaveables(Workbench.java:3447)
	at org.eclipse.ui.internal.Workbench.saveAll(Workbench.java:3420)
	at org.eclipse.ui.ide.IDE$1.run(IDE.java:1494)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.ide.IDE.saveAllEditors(IDE.java:1482)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.doSave(SaveScopeResourcesHandler.java:228)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.handleStatus(SaveScopeResourcesHandler.java:182)
	at org.eclipse.debug.internal.ui.sourcelookup.Prompter.lambda$0(Prompter.java:73)
	at org.eclipse.ui.internal.PendingSyncExec.run(PendingSyncExec.java:68)
	at org.eclipse.ui.internal.UILockListener.doPendingWork(UILockListener.java:171)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.ui.workbench.texteditor 4 0 2021-09-19 22:01:16.272
!MESSAGE 
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.ui.texteditor.ITextEditor.isDirty()" because "this.fTextEditor" is null
	at org.eclipse.ui.texteditor.AbstractTextEditor$TextEditorSavable.isDirty(AbstractTextEditor.java:7165)
	at org.eclipse.ui.internal.Workbench.getFilteredSaveables(Workbench.java:3447)
	at org.eclipse.ui.internal.Workbench.saveAll(Workbench.java:3420)
	at org.eclipse.ui.ide.IDE$1.run(IDE.java:1494)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.ide.IDE.saveAllEditors(IDE.java:1482)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.doSave(SaveScopeResourcesHandler.java:228)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.handleStatus(SaveScopeResourcesHandler.java:182)
	at org.eclipse.debug.internal.ui.sourcelookup.Prompter.lambda$0(Prompter.java:73)
	at org.eclipse.ui.internal.PendingSyncExec.run(PendingSyncExec.java:68)
	at org.eclipse.ui.internal.UILockListener.doPendingWork(UILockListener.java:171)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.ui.workbench.texteditor 4 0 2021-09-19 22:01:26.864
!MESSAGE 
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.ui.texteditor.ITextEditor.isDirty()" because "this.fTextEditor" is null
	at org.eclipse.ui.texteditor.AbstractTextEditor$TextEditorSavable.isDirty(AbstractTextEditor.java:7165)
	at org.eclipse.ui.internal.Workbench.getFilteredSaveables(Workbench.java:3447)
	at org.eclipse.ui.internal.Workbench.saveAll(Workbench.java:3420)
	at org.eclipse.ui.ide.IDE$1.run(IDE.java:1494)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.ide.IDE.saveAllEditors(IDE.java:1482)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.doSave(SaveScopeResourcesHandler.java:228)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.handleStatus(SaveScopeResourcesHandler.java:182)
	at org.eclipse.debug.internal.ui.sourcelookup.Prompter.lambda$0(Prompter.java:73)
	at org.eclipse.ui.internal.PendingSyncExec.run(PendingSyncExec.java:68)
	at org.eclipse.ui.internal.UILockListener.doPendingWork(UILockListener.java:171)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.ui.workbench.texteditor 4 0 2021-09-19 22:01:50.664
!MESSAGE 
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.ui.texteditor.ITextEditor.isDirty()" because "this.fTextEditor" is null
	at org.eclipse.ui.texteditor.AbstractTextEditor$TextEditorSavable.isDirty(AbstractTextEditor.java:7165)
	at org.eclipse.ui.internal.Workbench.getFilteredSaveables(Workbench.java:3447)
	at org.eclipse.ui.internal.Workbench.saveAll(Workbench.java:3420)
	at org.eclipse.ui.ide.IDE$1.run(IDE.java:1494)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.ide.IDE.saveAllEditors(IDE.java:1482)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.doSave(SaveScopeResourcesHandler.java:228)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.handleStatus(SaveScopeResourcesHandler.java:182)
	at org.eclipse.debug.internal.ui.sourcelookup.Prompter.lambda$0(Prompter.java:73)
	at org.eclipse.ui.internal.PendingSyncExec.run(PendingSyncExec.java:68)
	at org.eclipse.ui.internal.UILockListener.doPendingWork(UILockListener.java:171)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.ui.workbench.texteditor 4 0 2021-09-19 22:04:26.995
!MESSAGE 
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.ui.texteditor.ITextEditor.isDirty()" because "this.fTextEditor" is null
	at org.eclipse.ui.texteditor.AbstractTextEditor$TextEditorSavable.isDirty(AbstractTextEditor.java:7165)
	at org.eclipse.ui.internal.Workbench.getFilteredSaveables(Workbench.java:3447)
	at org.eclipse.ui.internal.Workbench.saveAll(Workbench.java:3420)
	at org.eclipse.ui.ide.IDE$1.run(IDE.java:1494)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.ide.IDE.saveAllEditors(IDE.java:1482)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.doSave(SaveScopeResourcesHandler.java:228)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.handleStatus(SaveScopeResourcesHandler.java:182)
	at org.eclipse.debug.internal.ui.sourcelookup.Prompter.lambda$0(Prompter.java:73)
	at org.eclipse.ui.internal.PendingSyncExec.run(PendingSyncExec.java:68)
	at org.eclipse.ui.internal.UILockListener.doPendingWork(UILockListener.java:171)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)
