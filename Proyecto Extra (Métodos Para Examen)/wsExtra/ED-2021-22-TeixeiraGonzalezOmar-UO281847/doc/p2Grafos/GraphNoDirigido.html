<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="es">
<head>
<!-- Generated by javadoc (15) on Sat Dec 18 17:39:07 CET 2021 -->
<title>GraphNoDirigido</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="dc.created" content="2021-12-18">
<meta name="description" content="declaration: package: p2Grafos, class: GraphNoDirigido">
<meta name="generator" content="javadoc/ClassWriterImpl">
<link rel="stylesheet" type="text/css" href="../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../script-dir/jquery-ui.min.css" title="Style">
<link rel="stylesheet" type="text/css" href="../jquery-ui.overrides.css" title="Style">
<script type="text/javascript" src="../script.js"></script>
<script type="text/javascript" src="../script-dir/jquery-3.5.1.min.js"></script>
<script type="text/javascript" src="../script-dir/jquery-ui.min.js"></script>
</head>
<body class="class-declaration-page">
<script type="text/javascript">var data = {"i0":10,"i1":10,"i2":10,"i3":10,"i4":10,"i5":10,"i6":10,"i7":10,"i8":10,"i9":10,"i10":10,"i11":10,"i12":10,"i13":10,"i14":10,"i15":10,"i16":10,"i17":10,"i18":10,"i19":10,"i20":10,"i21":10,"i22":10,"i23":10,"i24":10,"i25":10};
var tabs = {65535:["t0","All Methods"],2:["t2","Instance Methods"],8:["t4","Concrete Methods"]};
var altColor = "alt-color";
var rowColor = "row-color";
var tableTab = "table-tab";
var activeTableTab = "active-table-tab";
var pathtoroot = "../";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<div class="flex-box">
<header role="banner" class="flex-header">
<nav role="navigation">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="top-nav" id="navbar.top">
<div class="skip-nav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<ul id="navbar.top.firstrow" class="nav-list" title="Navigation">
<li><a href="../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="nav-bar-cell1-rev">Class</li>
<li><a href="class-use/GraphNoDirigido.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../deprecated-list.html">Deprecated</a></li>
<li><a href="../index-files/index-1.html">Index</a></li>
<li><a href="../help-doc.html">Help</a></li>
</ul>
</div>
<div class="sub-nav">
<div>
<ul class="sub-nav-list">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="sub-nav-list">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<div class="nav-list-search"><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</div>
</div>
<!-- ========= END OF TOP NAVBAR ========= -->
<span class="skip-nav" id="skip.navbar.top">
<!--   -->
</span></nav>
</header>
<div class="flex-content">
<main role="main">
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="sub-title"><span class="package-label-in-type">Package</span>&nbsp;<a href="package-summary.html">p2Grafos</a></div>
<h1 title="Class GraphNoDirigido" class="title">Class GraphNoDirigido&lt;T&gt;</h1>
</div>
<div class="inheritance" title="Inheritance Tree">java.lang.Object
<div class="inheritance">p2Grafos.GraphNoDirigido&lt;T&gt;</div>
</div>
<section class="description">
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>T</code> - , generico</dd>
</dl>
<hr>
<pre>public class <span class="type-name-label">GraphNoDirigido&lt;T&gt;</span>
extends java.lang.Object</pre>
<div class="block">Titulo: Clase Graph</div>
<dl class="notes">
<dt>Version:</dt>
<dd>24/09/2021</dd>
<dt>Author:</dt>
<dd>UO281847</dd>
</dl>
</section>
<section class="summary">
<ul class="summary-list">
<!-- =========== FIELD SUMMARY =========== -->
<li>
<section class="field-summary" id="field.summary">
<h2>Field Summary</h2>
<div class="member-summary">
<table class="summary-table">
<caption><span>Fields</span></caption>
<thead>
<tr>
<th class="col-first" scope="col">Modifier and Type</th>
<th class="col-second" scope="col">Field</th>
<th class="col-last" scope="col">Description</th>
</tr>
</thead>
<tbody>
<tr class="alt-color">
<td class="col-first"><code>protected double[][]</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#aFloyd">aFloyd</a></span></code></th>
<td class="col-last">
<div class="block">Matriz A de Floyd</div>
</td>
</tr>
<tr class="row-color">
<td class="col-first"><code>protected boolean[][]</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#edges">edges</a></span></code></th>
<td class="col-last">
<div class="block">Atributo edges</div>
</td>
</tr>
<tr class="alt-color">
<td class="col-first"><code>private static double</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#infinite">infinite</a></span></code></th>
<td class="col-last">
<div class="block">Constante infinite</div>
</td>
</tr>
<tr class="row-color">
<td class="col-first"><code>protected <a href="GraphNoDirigido.html" title="type parameter in GraphNoDirigido">T</a>[]</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#nodes">nodes</a></span></code></th>
<td class="col-last">
<div class="block">Atributo nodes</div>
</td>
</tr>
<tr class="alt-color">
<td class="col-first"><code>protected int</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#numNodes">numNodes</a></span></code></th>
<td class="col-last">
<div class="block">Atributo numNodes</div>
</td>
</tr>
<tr class="row-color">
<td class="col-first"><code>protected int[][]</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#pFloyd">pFloyd</a></span></code></th>
<td class="col-last">
<div class="block">Matriz P de Floyd</div>
</td>
</tr>
<tr class="alt-color">
<td class="col-first"><code>protected double[][]</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#weights">weights</a></span></code></th>
<td class="col-last">
<div class="block">Atributo weights</div>
</td>
</tr>
</tbody>
</table>
</div>
</section>
</li>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<li>
<section class="constructor-summary" id="constructor.summary">
<h2>Constructor Summary</h2>
<div class="member-summary">
<table class="summary-table">
<caption><span>Constructors</span></caption>
<thead>
<tr>
<th class="col-first" scope="col">Constructor</th>
<th class="col-last" scope="col">Description</th>
</tr>
</thead>
<tbody>
<tr class="alt-color">
<th class="col-constructor-name" scope="row"><code><span class="member-name-link"><a href="#%3Cinit%3E(int)">GraphNoDirigido</a></span>&#8203;(int&nbsp;tam)</code></th>
<td class="col-last">
<div class="block">Se le pasa el numero maximo de nodos del grafo</div>
</td>
</tr>
<tr class="row-color">
<th class="col-constructor-name" scope="row"><code><span class="member-name-link"><a href="#%3Cinit%3E(int,T%5B%5D,boolean%5B%5D%5B%5D,double%5B%5D%5B%5D)">GraphNoDirigido</a></span>&#8203;(int&nbsp;tam,
<a href="GraphNoDirigido.html" title="type parameter in GraphNoDirigido">T</a>[]&nbsp;initialNodes,
boolean[][]&nbsp;initialEdges,
double[][]&nbsp;initialWeights)</code></th>
<td class="col-last">
<div class="block">Constructor del grafo con parámetros para personalizarlo desde el principio</div>
</td>
</tr>
<tr class="alt-color">
<th class="col-constructor-name" scope="row"><code><span class="member-name-link"><a href="#%3Cinit%3E(int,T%5B%5D,boolean%5B%5D%5B%5D,double%5B%5D%5B%5D,double%5B%5D%5B%5D,int%5B%5D%5B%5D)">GraphNoDirigido</a></span>&#8203;(int&nbsp;tam,
<a href="GraphNoDirigido.html" title="type parameter in GraphNoDirigido">T</a>[]&nbsp;initialNodes,
boolean[][]&nbsp;initialEdges,
double[][]&nbsp;initialWeights,
double[][]&nbsp;initialAfloyd,
int[][]&nbsp;initialPfloyd)</code></th>
<td class="col-last">
<div class="block">Constructor del grafo con parámetros para personalizarlo desde el principio con más posibilidades</div>
</td>
</tr>
</tbody>
</table>
</div>
</section>
</li>
<!-- ========== METHOD SUMMARY =========== -->
<li>
<section class="method-summary" id="method.summary">
<h2>Method Summary</h2>
<div class="member-summary" id="method-summary-table">
<div class="table-tabs" role="tablist" aria-orientation="horizontal"><button role="tab" aria-selected="true" aria-controls="method-summary-table.tabpanel" tabindex="0" onkeydown="switchTab(event)" id="t0" class="active-table-tab">All Methods</button><button role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" id="t2" class="table-tab" onclick="show(2);">Instance Methods</button><button role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" id="t4" class="table-tab" onclick="show(8);">Concrete Methods</button></div>
<div id="method-summary-table.tabpanel" role="tabpanel">
<table class="summary-table" aria-labelledby="t0">
<thead>
<tr>
<th class="col-first" scope="col">Modifier and Type</th>
<th class="col-second" scope="col">Method</th>
<th class="col-last" scope="col">Description</th>
</tr>
</thead>
<tbody>
<tr class="alt-color" id="i0">
<td class="col-first"><code>int</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#addEdge(T,T,double)">addEdge</a></span>&#8203;(<a href="GraphNoDirigido.html" title="type parameter in GraphNoDirigido">T</a>&nbsp;source,
<a href="GraphNoDirigido.html" title="type parameter in GraphNoDirigido">T</a>&nbsp;target,
double&nbsp;edgeWeight)</code></th>
<td class="col-last">
<div class="block">Inserta una arista con el peso indicado (> 0) entre dos nodos, uno origen y  
 otro destino.</div>
</td>
</tr>
<tr class="row-color" id="i1">
<td class="col-first"><code>int</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#addNode(T)">addNode</a></span>&#8203;(<a href="GraphNoDirigido.html" title="type parameter in GraphNoDirigido">T</a>&nbsp;node)</code></th>
<td class="col-last">
<div class="block">Inserta un nuevo nodo que se le pasa como parámetro si lo inserta devuelve 0.</div>
</td>
</tr>
<tr class="alt-color" id="i2">
<td class="col-first"><code>private void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#addNodeElse(T)">addNodeElse</a></span>&#8203;(<a href="GraphNoDirigido.html" title="type parameter in GraphNoDirigido">T</a>&nbsp;node)</code></th>
<td class="col-last">
<div class="block">Método que añade un nodo en la siguiente posición no ocupada</div>
</td>
</tr>
<tr class="row-color" id="i3">
<td class="col-first"><code>private void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#addNodeFirst(T)">addNodeFirst</a></span>&#8203;(<a href="GraphNoDirigido.html" title="type parameter in GraphNoDirigido">T</a>&nbsp;node)</code></th>
<td class="col-last">
<div class="block">Método que añade un nodo en la primera posición</div>
</td>
</tr>
<tr class="alt-color" id="i4">
<td class="col-first"><code>private int</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#addWrongEdge(T,T,double)">addWrongEdge</a></span>&#8203;(<a href="GraphNoDirigido.html" title="type parameter in GraphNoDirigido">T</a>&nbsp;source,
<a href="GraphNoDirigido.html" title="type parameter in GraphNoDirigido">T</a>&nbsp;target,
double&nbsp;edgeWeight)</code></th>
<td class="col-last">
<div class="block">Método que comprueba los casos en los que no se puede añadir la arista</div>
</td>
</tr>
<tr class="row-color" id="i5">
<td class="col-first"><code>private int</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#addWrongNode(T)">addWrongNode</a></span>&#8203;(<a href="GraphNoDirigido.html" title="type parameter in GraphNoDirigido">T</a>&nbsp;node)</code></th>
<td class="col-last">
<div class="block">Método que comprueba los casos en los que no se puede añadir el nodo</div>
</td>
</tr>
<tr class="alt-color" id="i6">
<td class="col-first"><code>private boolean[]</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#aNodes(T,boolean%5B%5D)">aNodes</a></span>&#8203;(<a href="GraphNoDirigido.html" title="type parameter in GraphNoDirigido">T</a>&nbsp;origen,
boolean[]&nbsp;accesible)</code></th>
<td class="col-last">
<div class="block">Método que devuelve el vector con los nodos accesibles desde el que se pasa como parámetro</div>
</td>
</tr>
<tr class="row-color" id="i7">
<td class="col-first"><code>double[]</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#dijkstra(T)">dijkstra</a></span>&#8203;(<a href="GraphNoDirigido.html" title="type parameter in GraphNoDirigido">T</a>&nbsp;nodoOrigen)</code></th>
<td class="col-last">
<div class="block">Algoritmo de Dijkstra para encontrar el camino de coste mínimo desde nodoOrigen   
 hasta el resto de nodos.</div>
</td>
</tr>
<tr class="alt-color" id="i8">
<td class="col-first"><code>boolean</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#existsEdge(T,T)">existsEdge</a></span>&#8203;(<a href="GraphNoDirigido.html" title="type parameter in GraphNoDirigido">T</a>&nbsp;source,
<a href="GraphNoDirigido.html" title="type parameter in GraphNoDirigido">T</a>&nbsp;target)</code></th>
<td class="col-last">
<div class="block">Comprueba si existe una arista entre dos nodos que se pasan como parámetro  
 si alguno de los nodos no existe, no existe la arista evidentemente</div>
</td>
</tr>
<tr class="row-color" id="i9">
<td class="col-first"><code>boolean</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#existsNode(T)">existsNode</a></span>&#8203;(<a href="GraphNoDirigido.html" title="type parameter in GraphNoDirigido">T</a>&nbsp;node)</code></th>
<td class="col-last">
<div class="block">Indica si existe o no el nodo en el grafo</div>
</td>
</tr>
<tr class="alt-color" id="i10">
<td class="col-first"><code>int</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#floyd()">floyd</a></span>()</code></th>
<td class="col-last">
<div class="block">Aplica el algoritmo de Floyd al grafo y devuelve 0 si lo aplica y genera matrices A y P; y –1 si no lo hace</div>
</td>
</tr>
<tr class="row-color" id="i11">
<td class="col-first"><code>protected double[][]</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#getAFloyd()">getAFloyd</a></span>()</code></th>
<td class="col-last">
<div class="block">Devuelve la matriz A de Floyd, con infinito si no hay camino   
 Si no se ha invocado a Floyd debe devolver null  (OJO que no lo invoca)</div>
</td>
</tr>
<tr class="alt-color" id="i12">
<td class="col-first"><code>double</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#getEdge(T,T)">getEdge</a></span>&#8203;(<a href="GraphNoDirigido.html" title="type parameter in GraphNoDirigido">T</a>&nbsp;source,
<a href="GraphNoDirigido.html" title="type parameter in GraphNoDirigido">T</a>&nbsp;target)</code></th>
<td class="col-last">
<div class="block">Devuelve el peso de la arista que conecta dos nodos 
 Se suman los valores de los errores si se dan varios simultaneamente 
 Error 1: No existe nodo origen, valor –1, 
 Error 2: No existe nodo destino, valor -2 
 Error 3: No existe la arista pero sí los nodos origen y destino, valor –4</div>
</td>
</tr>
<tr class="row-color" id="i13">
<td class="col-first"><code>protected int</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#getNode(T)">getNode</a></span>&#8203;(<a href="GraphNoDirigido.html" title="type parameter in GraphNoDirigido">T</a>&nbsp;node)</code></th>
<td class="col-last">
<div class="block">Obtiene el índice de un nodo en el vector de nodos, y –1 si no existe
   
 ¡¡¡ OJO que es privado porque depende de la implementación !!!</div>
</td>
</tr>
<tr class="alt-color" id="i14">
<td class="col-first"><code>protected int[][]</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#getPFloyd()">getPFloyd</a></span>()</code></th>
<td class="col-last">
<div class="block">Devuelve la matriz P de Floyd, con -1 en las posiciones en las que no hay nodo intermedio   
 Si no se ha invocado a Floyd debe devolver null  (OJO que no lo invoca)</div>
</td>
</tr>
<tr class="row-color" id="i15">
<td class="col-first"><code>private boolean</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#isFull()">isFull</a></span>()</code></th>
<td class="col-last">
<div class="block">Método que comprueba que el vector de nodos está lleno</div>
</td>
</tr>
<tr class="alt-color" id="i16">
<td class="col-first"><code>private int</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#minCost(double%5B%5D,boolean%5B%5D)">minCost</a></span>&#8203;(double[]&nbsp;vectorD,
boolean[]&nbsp;visited)</code></th>
<td class="col-last">
<div class="block">Busca el nodo con distancia minima en D al resto de nodos, 
 se le pasa el vector D de dijkstra y 
 el conjunto de visitados (como un vector de booleanos) y 
 devuelve el indice del nodo buscado 
 Si hay varios con mismo coste devuelve el que tenga índice 
 más bajo en el vector de nodos 
 o -1 si el grafo es no conexo o no quedan nodos sin visitar</div>
</td>
</tr>
<tr class="row-color" id="i17">
<td class="col-first"><code>double</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#minCostPath(T,T)">minCostPath</a></span>&#8203;(<a href="GraphNoDirigido.html" title="type parameter in GraphNoDirigido">T</a>&nbsp;origen,
<a href="GraphNoDirigido.html" title="type parameter in GraphNoDirigido">T</a>&nbsp;destino)</code></th>
<td class="col-last">
<div class="block">Devuelve el coste del camino de coste mínimo entre origen y destino según Floyd  
 Si no están generadas las matrices de Floyd, las genera.</div>
</td>
</tr>
<tr class="alt-color" id="i18">
<td class="col-first"><code>java.lang.String</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#path(T,T)">path</a></span>&#8203;(<a href="GraphNoDirigido.html" title="type parameter in GraphNoDirigido">T</a>&nbsp;origen,
<a href="GraphNoDirigido.html" title="type parameter in GraphNoDirigido">T</a>&nbsp;destino)</code></th>
<td class="col-last">
<div class="block">Indica el camino entre los nodos que se le pasan como parámetros en un String de esta forma:  
 Origen<tab>(coste0)<tab>Intermedio1<tab>(coste1)….IntermedioN<tab>(costeN)<tab>Destino<tab>  
 Si no están generadas las matrices de Floyd, las genera, si se puede.</div>
</td>
</tr>
<tr class="row-color" id="i19">
<td class="col-first"><code>java.lang.String</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#recorridoProfundidad(T)">recorridoProfundidad</a></span>&#8203;(<a href="GraphNoDirigido.html" title="type parameter in GraphNoDirigido">T</a>&nbsp;origen)</code></th>
<td class="col-last">
<div class="block">Lanza el recorrido en profundidad de un grafo desde un nodo determinado,  
 No necesariamente recorre todos los nodos.</div>
</td>
</tr>
<tr class="alt-color" id="i20">
<td class="col-first"><code>private java.lang.String</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#recursivePath(int,int,java.lang.String)">recursivePath</a></span>&#8203;(int&nbsp;indexOrigen,
int&nbsp;indexDestino,
java.lang.String&nbsp;path)</code></th>
<td class="col-last">
<div class="block">Método que calcula el camino de forma recursiva, pasando por los nodos</div>
</td>
</tr>
<tr class="row-color" id="i21">
<td class="col-first"><code>private java.lang.String</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#recursiveRecorrido(int,boolean%5B%5D)">recursiveRecorrido</a></span>&#8203;(int&nbsp;i,
boolean[]&nbsp;visited)</code></th>
<td class="col-last">
<div class="block">Método recursivo que recorre todos los nodos del vector de visitados, 
 comprueba que tienen una arista en comun con la posición del nodo 
 que se le pasa como parámetro, marca este nodo como visitado y le añade el toString al recorrido</div>
</td>
</tr>
<tr class="alt-color" id="i22">
<td class="col-first"><code>int</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#removeEdge(T,T)">removeEdge</a></span>&#8203;(<a href="GraphNoDirigido.html" title="type parameter in GraphNoDirigido">T</a>&nbsp;source,
<a href="GraphNoDirigido.html" title="type parameter in GraphNoDirigido">T</a>&nbsp;target)</code></th>
<td class="col-last">
<div class="block">Borra la arista del grafo que conecta dos nodos   
 Se suman los valores de los errores si se dan varios simultaneamente 
 Error 1: No existe nodo origen, valor –1, 
 Error 2: No existe nodo destino, valor -2 
 Error 3: No existe la arista pero sí los nodos origen y destino, valor –4 
 devuelve 0 si la borra</div>
</td>
</tr>
<tr class="row-color" id="i23">
<td class="col-first"><code>int</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#removeNode(T)">removeNode</a></span>&#8203;(<a href="GraphNoDirigido.html" title="type parameter in GraphNoDirigido">T</a>&nbsp;node)</code></th>
<td class="col-last">
<div class="block">Borra el nodo deseado del vector de nodos así como las aristas de las que  
 forma parte, devolviendo 0 si lo hace y –1 si no lo hace</div>
</td>
</tr>
<tr class="alt-color" id="i24">
<td class="col-first"><code>java.lang.String</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#toString()">toString</a></span>()</code></th>
<td class="col-last">
<div class="block">Devuelve un String con la informacion del grafo (incluyendo matrices de Floyd)  
 Si se ha usado para pruebas el toString anterior, sería conveniente renombrarlo antes (mediante refactorizacion) 
 antes de sustituirlo por este, para que sigan pasando las pruebas anteriores sin problemas.</div>
</td>
</tr>
<tr class="row-color" id="i25">
<td class="col-first"><code>private int</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#wrongEdge(T,T)">wrongEdge</a></span>&#8203;(<a href="GraphNoDirigido.html" title="type parameter in GraphNoDirigido">T</a>&nbsp;source,
<a href="GraphNoDirigido.html" title="type parameter in GraphNoDirigido">T</a>&nbsp;target)</code></th>
<td class="col-last">
<div class="block">Método que comprueba los casos en los que no se puede devolver la arista</div>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="inherited-list">
<h3 id="methods.inherited.from.class.java.lang.Object">Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, wait, wait, wait</code></div>
</section>
</li>
</ul>
</section>
<section class="details">
<ul class="details-list">
<!-- ============ FIELD DETAIL =========== -->
<li>
<section class="field-details" id="field.detail">
<h2>Field Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="infinite">
<h3>infinite</h3>
<div class="member-signature"><span class="modifiers">private static final</span>&nbsp;<span class="return-type">double</span>&nbsp;<span class="member-name">infinite</span></div>
<div class="block">Constante infinite</div>
<dl class="notes">
<dt>See Also:</dt>
<dd><a href="../constant-values.html#p2Grafos.GraphNoDirigido.infinite">Constant Field Values</a></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="nodes">
<h3>nodes</h3>
<div class="member-signature"><span class="modifiers">protected</span>&nbsp;<span class="return-type"><a href="GraphNoDirigido.html" title="type parameter in GraphNoDirigido">T</a>[]</span>&nbsp;<span class="member-name">nodes</span></div>
<div class="block">Atributo nodes</div>
</section>
</li>
<li>
<section class="detail" id="edges">
<h3>edges</h3>
<div class="member-signature"><span class="modifiers">protected</span>&nbsp;<span class="return-type">boolean[][]</span>&nbsp;<span class="member-name">edges</span></div>
<div class="block">Atributo edges</div>
</section>
</li>
<li>
<section class="detail" id="weights">
<h3>weights</h3>
<div class="member-signature"><span class="modifiers">protected</span>&nbsp;<span class="return-type">double[][]</span>&nbsp;<span class="member-name">weights</span></div>
<div class="block">Atributo weights</div>
</section>
</li>
<li>
<section class="detail" id="numNodes">
<h3>numNodes</h3>
<div class="member-signature"><span class="modifiers">protected</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="member-name">numNodes</span></div>
<div class="block">Atributo numNodes</div>
</section>
</li>
<li>
<section class="detail" id="aFloyd">
<h3>aFloyd</h3>
<div class="member-signature"><span class="modifiers">protected</span>&nbsp;<span class="return-type">double[][]</span>&nbsp;<span class="member-name">aFloyd</span></div>
<div class="block">Matriz A de Floyd</div>
</section>
</li>
<li>
<section class="detail" id="pFloyd">
<h3>pFloyd</h3>
<div class="member-signature"><span class="modifiers">protected</span>&nbsp;<span class="return-type">int[][]</span>&nbsp;<span class="member-name">pFloyd</span></div>
<div class="block">Matriz P de Floyd</div>
</section>
</li>
</ul>
</section>
</li>
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<li>
<section class="constructor-details" id="constructor.detail">
<h2>Constructor Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="&lt;init&gt;(int)">
<h3>GraphNoDirigido</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="member-name">GraphNoDirigido</span>&#8203;(<span class="parameters">int&nbsp;tam)</span></div>
<div class="block">Se le pasa el numero maximo de nodos del grafo</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>tam</code> - , tanaño del vector de nodos</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="&lt;init&gt;(int,T[],boolean[][],double[][])">
<h3 id="&lt;init&gt;(int,java.lang.Object[],boolean[][][],double[][][])">GraphNoDirigido</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="member-name">GraphNoDirigido</span>&#8203;(<span class="parameters">int&nbsp;tam,
<a href="GraphNoDirigido.html" title="type parameter in GraphNoDirigido">T</a>[]&nbsp;initialNodes,
boolean[][]&nbsp;initialEdges,
double[][]&nbsp;initialWeights)</span></div>
<div class="block">Constructor del grafo con parámetros para personalizarlo desde el principio</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>tam</code> - , tamaño</dd>
<dd><code>initialNodes</code> - , nodos iniciales</dd>
<dd><code>initialEdges</code> - , aristas iniciales</dd>
<dd><code>initialWeights</code> - , pesos iniciales</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="&lt;init&gt;(int,T[],boolean[][],double[][],double[][],int[][])">
<h3 id="&lt;init&gt;(int,java.lang.Object[],boolean[][][],double[][][],double[][][],int[][][])">GraphNoDirigido</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="member-name">GraphNoDirigido</span>&#8203;(<span class="parameters">int&nbsp;tam,
<a href="GraphNoDirigido.html" title="type parameter in GraphNoDirigido">T</a>[]&nbsp;initialNodes,
boolean[][]&nbsp;initialEdges,
double[][]&nbsp;initialWeights,
double[][]&nbsp;initialAfloyd,
int[][]&nbsp;initialPfloyd)</span></div>
<div class="block">Constructor del grafo con parámetros para personalizarlo desde el principio con más posibilidades</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>tam</code> - , tamaño</dd>
<dd><code>initialNodes</code> - , nodos iniciales</dd>
<dd><code>initialEdges</code> - , aristas iniciales</dd>
<dd><code>initialWeights</code> - , pesos iniciales</dd>
<dd><code>initialAfloyd</code> - , matriz A de Floyd inicial</dd>
<dd><code>initialPfloyd</code> - , matriz P de Floyd inicial</dd>
</dl>
</section>
</li>
</ul>
</section>
</li>
<!-- ============ METHOD DETAIL ========== -->
<li>
<section class="method-details" id="method.detail">
<h2>Method Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="addNode(T)">
<h3 id="addNode(java.lang.Object)">addNode</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="member-name">addNode</span>&#8203;(<span class="parameters"><a href="GraphNoDirigido.html" title="type parameter in GraphNoDirigido">T</a>&nbsp;node)</span></div>
<div class="block">Inserta un nuevo nodo que se le pasa como parámetro si lo inserta devuelve 0.
 Error 1: si ya existe, valor -1 
 Error 2: no cabe, valor -2 
 Error 3: el nodo a insertar no es válido, valor –4
 Se suman los errores en caso de que se den varios, por ejemplo: 
 si además de no ser válido no cabe, devuelve -6 (suma errores 2 y 3)</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>node</code> - , nodo</dd>
<dt>Returns:</dt>
<dd>0, -1, -2, -4 o la suma</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="addWrongNode(T)">
<h3 id="addWrongNode(java.lang.Object)">addWrongNode</h3>
<div class="member-signature"><span class="modifiers">private</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="member-name">addWrongNode</span>&#8203;(<span class="parameters"><a href="GraphNoDirigido.html" title="type parameter in GraphNoDirigido">T</a>&nbsp;node)</span></div>
<div class="block">Método que comprueba los casos en los que no se puede añadir el nodo</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>node</code> - , nodo</dd>
<dt>Returns:</dt>
<dd>error, error</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="addNodeFirst(T)">
<h3 id="addNodeFirst(java.lang.Object)">addNodeFirst</h3>
<div class="member-signature"><span class="modifiers">private</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">addNodeFirst</span>&#8203;(<span class="parameters"><a href="GraphNoDirigido.html" title="type parameter in GraphNoDirigido">T</a>&nbsp;node)</span></div>
<div class="block">Método que añade un nodo en la primera posición</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>node</code> - , nodo a añadir</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="addNodeElse(T)">
<h3 id="addNodeElse(java.lang.Object)">addNodeElse</h3>
<div class="member-signature"><span class="modifiers">private</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">addNodeElse</span>&#8203;(<span class="parameters"><a href="GraphNoDirigido.html" title="type parameter in GraphNoDirigido">T</a>&nbsp;node)</span></div>
<div class="block">Método que añade un nodo en la siguiente posición no ocupada</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>node</code> - , nodo a añadir</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="isFull()">
<h3>isFull</h3>
<div class="member-signature"><span class="modifiers">private</span>&nbsp;<span class="return-type">boolean</span>&nbsp;<span class="member-name">isFull</span>()</div>
<div class="block">Método que comprueba que el vector de nodos está lleno</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>true o false</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="getNode(T)">
<h3 id="getNode(java.lang.Object)">getNode</h3>
<div class="member-signature"><span class="modifiers">protected</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="member-name">getNode</span>&#8203;(<span class="parameters"><a href="GraphNoDirigido.html" title="type parameter in GraphNoDirigido">T</a>&nbsp;node)</span></div>
<div class="block">Obtiene el índice de un nodo en el vector de nodos, y –1 si no existe
   
 ¡¡¡ OJO que es privado porque depende de la implementación !!!</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>node</code> - , nodo</dd>
<dt>Returns:</dt>
<dd>i o -1</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="existsNode(T)">
<h3 id="existsNode(java.lang.Object)">existsNode</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">boolean</span>&nbsp;<span class="member-name">existsNode</span>&#8203;(<span class="parameters"><a href="GraphNoDirigido.html" title="type parameter in GraphNoDirigido">T</a>&nbsp;node)</span></div>
<div class="block">Indica si existe o no el nodo en el grafo</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>node</code> - , nodo</dd>
<dt>Returns:</dt>
<dd>true</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="removeNode(T)">
<h3 id="removeNode(java.lang.Object)">removeNode</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="member-name">removeNode</span>&#8203;(<span class="parameters"><a href="GraphNoDirigido.html" title="type parameter in GraphNoDirigido">T</a>&nbsp;node)</span></div>
<div class="block">Borra el nodo deseado del vector de nodos así como las aristas de las que  
 forma parte, devolviendo 0 si lo hace y –1 si no lo hace</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>node</code> - , nodo a eliminar</dd>
<dt>Returns:</dt>
<dd>0 o -1</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="addEdge(T,T,double)">
<h3 id="addEdge(java.lang.Object,java.lang.Object,double)">addEdge</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="member-name">addEdge</span>&#8203;(<span class="parameters"><a href="GraphNoDirigido.html" title="type parameter in GraphNoDirigido">T</a>&nbsp;source,
<a href="GraphNoDirigido.html" title="type parameter in GraphNoDirigido">T</a>&nbsp;target,
double&nbsp;edgeWeight)</span></div>
<div class="block">Inserta una arista con el peso indicado (> 0) entre dos nodos, uno origen y  
 otro destino. Si la arista existe, no la inserta.  
 Devuelve 0 si la inserta 
 Se suman los valores de los errores si se dan varios simultaneamente, 
 por ejemplo si se dan errores 1 y 2 el resultado es la suma de los valores correspondientes (-3) 
 Error 1: No existe nodo origen, valor -1 
 Error 2: No existe nodo destino, valor -2   
 Error 3: Ya existe la arista, valor -4 
 Error 4: El peso no es válido, valor -8</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>source</code> - , nodo origen</dd>
<dd><code>target</code> - , nodo destino</dd>
<dd><code>edgeWeight</code> - , peso de la arista</dd>
<dt>Returns:</dt>
<dd>error o 0</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="addWrongEdge(T,T,double)">
<h3 id="addWrongEdge(java.lang.Object,java.lang.Object,double)">addWrongEdge</h3>
<div class="member-signature"><span class="modifiers">private</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="member-name">addWrongEdge</span>&#8203;(<span class="parameters"><a href="GraphNoDirigido.html" title="type parameter in GraphNoDirigido">T</a>&nbsp;source,
<a href="GraphNoDirigido.html" title="type parameter in GraphNoDirigido">T</a>&nbsp;target,
double&nbsp;edgeWeight)</span></div>
<div class="block">Método que comprueba los casos en los que no se puede añadir la arista</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>source</code> - , nodo origen</dd>
<dd><code>target</code> - , nodo destino</dd>
<dd><code>edgeWeight</code> - , peso de la arista</dd>
<dt>Returns:</dt>
<dd>error, error si tiene</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="getEdge(T,T)">
<h3 id="getEdge(java.lang.Object,java.lang.Object)">getEdge</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">double</span>&nbsp;<span class="member-name">getEdge</span>&#8203;(<span class="parameters"><a href="GraphNoDirigido.html" title="type parameter in GraphNoDirigido">T</a>&nbsp;source,
<a href="GraphNoDirigido.html" title="type parameter in GraphNoDirigido">T</a>&nbsp;target)</span></div>
<div class="block">Devuelve el peso de la arista que conecta dos nodos 
 Se suman los valores de los errores si se dan varios simultaneamente 
 Error 1: No existe nodo origen, valor –1, 
 Error 2: No existe nodo destino, valor -2 
 Error 3: No existe la arista pero sí los nodos origen y destino, valor –4</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>source</code> - , nodo origen</dd>
<dd><code>target</code> - , nodo destino</dd>
<dt>Returns:</dt>
<dd>peso</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="wrongEdge(T,T)">
<h3 id="wrongEdge(java.lang.Object,java.lang.Object)">wrongEdge</h3>
<div class="member-signature"><span class="modifiers">private</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="member-name">wrongEdge</span>&#8203;(<span class="parameters"><a href="GraphNoDirigido.html" title="type parameter in GraphNoDirigido">T</a>&nbsp;source,
<a href="GraphNoDirigido.html" title="type parameter in GraphNoDirigido">T</a>&nbsp;target)</span></div>
<div class="block">Método que comprueba los casos en los que no se puede devolver la arista</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>source</code> - , nodo origen</dd>
<dd><code>target</code> - , nodo destino</dd>
<dt>Returns:</dt>
<dd>error</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="existsEdge(T,T)">
<h3 id="existsEdge(java.lang.Object,java.lang.Object)">existsEdge</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">boolean</span>&nbsp;<span class="member-name">existsEdge</span>&#8203;(<span class="parameters"><a href="GraphNoDirigido.html" title="type parameter in GraphNoDirigido">T</a>&nbsp;source,
<a href="GraphNoDirigido.html" title="type parameter in GraphNoDirigido">T</a>&nbsp;target)</span></div>
<div class="block">Comprueba si existe una arista entre dos nodos que se pasan como parámetro  
 si alguno de los nodos no existe, no existe la arista evidentemente</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>source</code> - , nodo origen</dd>
<dd><code>target</code> - , nodo destino</dd>
<dt>Returns:</dt>
<dd>true o false</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="removeEdge(T,T)">
<h3 id="removeEdge(java.lang.Object,java.lang.Object)">removeEdge</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="member-name">removeEdge</span>&#8203;(<span class="parameters"><a href="GraphNoDirigido.html" title="type parameter in GraphNoDirigido">T</a>&nbsp;source,
<a href="GraphNoDirigido.html" title="type parameter in GraphNoDirigido">T</a>&nbsp;target)</span></div>
<div class="block">Borra la arista del grafo que conecta dos nodos   
 Se suman los valores de los errores si se dan varios simultaneamente 
 Error 1: No existe nodo origen, valor –1, 
 Error 2: No existe nodo destino, valor -2 
 Error 3: No existe la arista pero sí los nodos origen y destino, valor –4 
 devuelve 0 si la borra</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>source</code> - , nodo origen</dd>
<dd><code>target</code> - , nodo destino</dd>
<dt>Returns:</dt>
<dd>0, -1, -2, -4 o la suma</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="dijkstra(T)">
<h3 id="dijkstra(java.lang.Object)">dijkstra</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">double[]</span>&nbsp;<span class="member-name">dijkstra</span>&#8203;(<span class="parameters"><a href="GraphNoDirigido.html" title="type parameter in GraphNoDirigido">T</a>&nbsp;nodoOrigen)</span></div>
<div class="block">Algoritmo de Dijkstra para encontrar el camino de coste mínimo desde nodoOrigen   
 hasta el resto de nodos. Devuelve el vector D de Dijkstra  
 Si no existe el nodoOrigen (o es inválido como parámetro) devuelve null</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>nodoOrigen</code> - , nodoOrigen</dd>
<dt>Returns:</dt>
<dd>vectorD,, vector de pesos</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="minCost(double[],boolean[])">
<h3>minCost</h3>
<div class="member-signature"><span class="modifiers">private</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="member-name">minCost</span>&#8203;(<span class="parameters">double[]&nbsp;vectorD,
boolean[]&nbsp;visited)</span></div>
<div class="block">Busca el nodo con distancia minima en D al resto de nodos, 
 se le pasa el vector D de dijkstra y 
 el conjunto de visitados (como un vector de booleanos) y 
 devuelve el indice del nodo buscado 
 Si hay varios con mismo coste devuelve el que tenga índice 
 más bajo en el vector de nodos 
 o -1 si el grafo es no conexo o no quedan nodos sin visitar</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>vectorD</code> - , vector D</dd>
<dd><code>visited</code> - , vectores visitados</dd>
<dt>Returns:</dt>
<dd>ind, minimo Coste</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="floyd()">
<h3>floyd</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="member-name">floyd</span>()</div>
<div class="block">Aplica el algoritmo de Floyd al grafo y devuelve 0 si lo aplica y genera matrices A y P; y –1 si no lo hace</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>0 o -1</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="getAFloyd()">
<h3>getAFloyd</h3>
<div class="member-signature"><span class="modifiers">protected</span>&nbsp;<span class="return-type">double[][]</span>&nbsp;<span class="member-name">getAFloyd</span>()</div>
<div class="block">Devuelve la matriz A de Floyd, con infinito si no hay camino   
 Si no se ha invocado a Floyd debe devolver null  (OJO que no lo invoca)</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>aFloyd, matriz A de Floyd</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="getPFloyd()">
<h3>getPFloyd</h3>
<div class="member-signature"><span class="modifiers">protected</span>&nbsp;<span class="return-type">int[][]</span>&nbsp;<span class="member-name">getPFloyd</span>()</div>
<div class="block">Devuelve la matriz P de Floyd, con -1 en las posiciones en las que no hay nodo intermedio   
 Si no se ha invocado a Floyd debe devolver null  (OJO que no lo invoca)</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>pFloyd, matriz P de Floyd</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="minCostPath(T,T)">
<h3 id="minCostPath(java.lang.Object,java.lang.Object)">minCostPath</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">double</span>&nbsp;<span class="member-name">minCostPath</span>&#8203;(<span class="parameters"><a href="GraphNoDirigido.html" title="type parameter in GraphNoDirigido">T</a>&nbsp;origen,
<a href="GraphNoDirigido.html" title="type parameter in GraphNoDirigido">T</a>&nbsp;destino)</span></div>
<div class="block">Devuelve el coste del camino de coste mínimo entre origen y destino según Floyd  
 Si no están generadas las matrices de Floyd, las genera.  
 Si no puede obtener el valor por alguna razón, devuelve –1 (OJO que es distinto de infinito)</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>origen</code> - , nodoOrigen</dd>
<dd><code>destino</code> - , nodoDestino</dd>
<dt>Returns:</dt>
<dd>minCost, coste minimo del camino</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="path(T,T)">
<h3 id="path(java.lang.Object,java.lang.Object)">path</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">java.lang.String</span>&nbsp;<span class="member-name">path</span>&#8203;(<span class="parameters"><a href="GraphNoDirigido.html" title="type parameter in GraphNoDirigido">T</a>&nbsp;origen,
<a href="GraphNoDirigido.html" title="type parameter in GraphNoDirigido">T</a>&nbsp;destino)</span></div>
<div class="block">Indica el camino entre los nodos que se le pasan como parámetros en un String de esta forma:  
 Origen<tab>(coste0)<tab>Intermedio1<tab>(coste1)….IntermedioN<tab>(costeN)<tab>Destino<tab>  
 Si no están generadas las matrices de Floyd, las genera, si se puede.  
 Si no hay camino: Origen<tab>(Infinity)<tab>Destino<tab> 
 Si Origen y Destino coinciden: Origen<tab>  
 Si no existen los 2 nodos devuelve una cadena vacía</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>origen</code> - , nodo Origen</dd>
<dd><code>destino</code> - , nodo Destino</dd>
<dt>Returns:</dt>
<dd>camino, cadena con el camino</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="aNodes(T,boolean[])">
<h3 id="aNodes(java.lang.Object,boolean[])">aNodes</h3>
<div class="member-signature"><span class="modifiers">private</span>&nbsp;<span class="return-type">boolean[]</span>&nbsp;<span class="member-name">aNodes</span>&#8203;(<span class="parameters"><a href="GraphNoDirigido.html" title="type parameter in GraphNoDirigido">T</a>&nbsp;origen,
boolean[]&nbsp;accesible)</span></div>
<div class="block">Método que devuelve el vector con los nodos accesibles desde el que se pasa como parámetro</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>origen</code> - , nodo origen</dd>
<dd><code>accesible</code> - , vector de nodos accesibles</dd>
<dt>Returns:</dt>
<dd>accesible, vector de nodos accesibles</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="recursivePath(int,int,java.lang.String)">
<h3>recursivePath</h3>
<div class="member-signature"><span class="modifiers">private</span>&nbsp;<span class="return-type">java.lang.String</span>&nbsp;<span class="member-name">recursivePath</span>&#8203;(<span class="parameters">int&nbsp;indexOrigen,
int&nbsp;indexDestino,
java.lang.String&nbsp;path)</span></div>
<div class="block">Método que calcula el camino de forma recursiva, pasando por los nodos</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>indexOrigen</code> - , indice del nodo Origen</dd>
<dd><code>indexDestino</code> - , indice del nodo Destino</dd>
<dd><code>path</code> - , camino</dd>
<dt>Returns:</dt>
<dd>camino</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="recorridoProfundidad(T)">
<h3 id="recorridoProfundidad(java.lang.Object)">recorridoProfundidad</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">java.lang.String</span>&nbsp;<span class="member-name">recorridoProfundidad</span>&#8203;(<span class="parameters"><a href="GraphNoDirigido.html" title="type parameter in GraphNoDirigido">T</a>&nbsp;origen)</span></div>
<div class="block">Lanza el recorrido en profundidad de un grafo desde un nodo determinado,  
 No necesariamente recorre todos los nodos.  
 Al recorrer cada nodo añade el toString del nodo y un tabulador  
 Se puede usar un método privado recursivo...  
 Se recorren vecinos empezando por el principio del vector de nodos (antes índices bajos) 
 Si no existe el nodo devuelve una cadena vacia</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>origen</code> - , nodo desde el que empieza el recorrido</dd>
<dt>Returns:</dt>
<dd>recorrido, cadena con recorrido en profundidad</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="recursiveRecorrido(int,boolean[])">
<h3>recursiveRecorrido</h3>
<div class="member-signature"><span class="modifiers">private</span>&nbsp;<span class="return-type">java.lang.String</span>&nbsp;<span class="member-name">recursiveRecorrido</span>&#8203;(<span class="parameters">int&nbsp;i,
boolean[]&nbsp;visited)</span></div>
<div class="block">Método recursivo que recorre todos los nodos del vector de visitados, 
 comprueba que tienen una arista en comun con la posición del nodo 
 que se le pasa como parámetro, marca este nodo como visitado y le añade el toString al recorrido</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>i</code> - , posición de los nodos</dd>
<dd><code>visited</code> - , vector de nodos visitados</dd>
<dt>Returns:</dt>
<dd>recorridoR, parte final del recorrido</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="toString()">
<h3>toString</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">java.lang.String</span>&nbsp;<span class="member-name">toString</span>()</div>
<div class="block">Devuelve un String con la informacion del grafo (incluyendo matrices de Floyd)  
 Si se ha usado para pruebas el toString anterior, sería conveniente renombrarlo antes (mediante refactorizacion) 
 antes de sustituirlo por este, para que sigan pasando las pruebas anteriores sin problemas.</div>
<dl class="notes">
<dt>Overrides:</dt>
<dd><code>toString</code>&nbsp;in class&nbsp;<code>java.lang.Object</code></dd>
<dt>Returns:</dt>
<dd>cadena, string</dd>
</dl>
</section>
</li>
</ul>
</section>
</li>
</ul>
</section>
<!-- ========= END OF CLASS DATA ========= -->
</main>
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottom-nav" id="navbar.bottom">
<div class="skip-nav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<ul id="navbar.bottom.firstrow" class="nav-list" title="Navigation">
<li><a href="../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="nav-bar-cell1-rev">Class</li>
<li><a href="class-use/GraphNoDirigido.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../deprecated-list.html">Deprecated</a></li>
<li><a href="../index-files/index-1.html">Index</a></li>
<li><a href="../help-doc.html">Help</a></li>
</ul>
</div>
<div class="sub-nav">
<div>
<ul class="sub-nav-list">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="sub-nav-list">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
</div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
<span class="skip-nav" id="skip.navbar.bottom">
<!--   -->
</span></nav>
</footer>
</div>
</div>
</body>
</html>
