!SESSION 2021-10-06 00:09:13.343 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=15.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_ES
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

This is a continuation of log file D:\Clase\3. Ingeniería Informática de Software\Segundo curso\Estructuras de Datos\Proyecto 2\ws2\.metadata\.bak_2.log
Created Time: 2021-10-06 00:59:53.365

!ENTRY org.eclipse.jdt.core 4 4 2021-10-06 00:59:53.365
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package p2Grafos;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import org.junit.Test;

/**
 * Titulo: Clase GraphTests
 * 
 * @author UO281847
 * @version 24/09/2021
 */
public class GraphTests {
	private Graph<Integer> g;
///*
// * Pruebas del método addNode:	
// */
//	/**
//	 * Test del método addNode sin errores
//	 */
//	@Test
//	public void testAddNodeFirst() {
//		Graph<Integer> g = new Graph<Integer>(3);
//		int node = 12;
//		assertEquals(0, g.addNode(node));
//		System.out.println(g.toString());	
//	}	
//	/**
//	 * Test del método addNode con nodo no valido
//	 */
//	@Test
//	public void testAddNodeNotValid() {
//		Graph<Integer> g = new Graph<Integer>(3);
//		int node = 1;
//		int node2 = 18;
//		assertEquals(0, g.addNode(node));
//		assertEquals(0, g.addNode(node2));
//		assertEquals(-5, g.addNode(null));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addNode cuando ya esta lleno
//	 */
//	@Test
//	public void testAddNodeFull() {
//		Graph<Integer> g = new Graph<Integer>(3);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 39;
//		int node4= 2;
//		assertEquals(0, g.addNode(node));
//		assertEquals(0, g.addNode(node2));
//		assertEquals(0, g.addNode(node3));
//		assertEquals(-2, g.addNode(node4));		
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addNode cuando ya existe
//	 */
//	@Test
//	public void testAddNodeAlreadyExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 39;
//		int node4 = 19;
//		int node5= 19;
//		assertEquals(0, g.addNode(node));
//		assertEquals(0, g.addNode(node2));
//		assertEquals(0, g.addNode(node3));
//		assertEquals(0, g.addNode(node4));
//		assertEquals(-1, g.addNode(node5));	
//		System.out.println(g.toString());	
//	}
//	
///*
// * Pruebas del método getNode:
// */
//	/**
//	 * Test del método getNode que devuelve la posición
//	 */
//	@Test
//	public void testGetNodeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		g.addNode(node);
//		assertEquals(0, g.getNode(node));
//	}
//	/**
//	 * Test del método getNode que devuelve la posición ya añadido
//	 */
//	@Test
//	public void testGetNodeVarious() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 23;
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(1, g.getNode(node2));
//	}
//	/**
//	 * Test del método getNode que devuelve -1
//	 */
//	@Test
//	public void testGetNodeDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 23;
//		g.addNode(node);
//		assertEquals(-1, g.getNode(node2));
//	}
//
///**
// * Pruebas del método existsNode:
// */
//	/**
//	 * Test del método existsNode que devuelve true
//	 */
//	@Test
//	public void testExistsNodeOne() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		g.addNode(node);
//		assertTrue(g.existsNode(node));
//	}
//	/**
//	 * Test del método existsNode que devuelve true
//	 */
//	@Test
//	public void testExistsNodeVarious() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 23;
//		g.addNode(node);
//		g.addNode(node2);
//		assertTrue(g.existsNode(node2));
//	}
//	/**
//	 * Test del método existsNode que devuelve true
//	 */
//	@Test
//	public void testExistsNodeFalse() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 23;
//		g.addNode(node);
//		assertFalse(g.existsNode(node2));
//	}
//
///*
// * Pruebas del método addEdge:
// */
//	/**
//	 * Test del método addEdge que no tiene errores
//	 */
//	@Test
//	public void testAddEdgeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;		
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(0, g.addEdge(node, node2, 12));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde no existe el nodo origen
//	 */
//	@Test
//	public void testAddEdgeSourceDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 23;
//		g.addNode(node);
//		g.addNode(node2);		
//		assertEquals(-1, g.addEdge(node3, node2, 12));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde no existe el nodo destino
//	 */
//	@Test
//	public void testAddEdgeTargetDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 23;
//		g.addNode(node);
//		g.addNode(node2);		
//		assertEquals(-2, g.addEdge(node, node3, 12));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde ya existe la arista
//	 */
//	@Test
//	public void testAddEdgeEdgeExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 12);
//		assertEquals(-4, g.addEdge(node, node2, 12));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde el peso no es valido
//	 */
//	@Test
//	public void testAddEdgeEdgeWightError() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(-8, g.addEdge(node, node2, -4));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde no existen los nodos 
//	 */
//	@Test
//	public void testAddEdgeSourceTargetError() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 12;
//		int node4 = 56;
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(-3, g.addEdge(node3, node4, 4));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde ya existe la arista y el peso no es valido
//	 */
//	@Test
//	public void testAddEdgeEdgeExistsEdgeWeightError() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-12, g.addEdge(node, node2, -4));
//		System.out.println(g.toString());	
//	}
//	
///*
// * Pruebas del método getEdge:
// */
//	/**
//	 * Test del método getEdge que no tiene errores
//	 */
//	@Test
//	public void testGetEdgeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(4, g.getEdge(node, node2),0.1);
//	}
//	/**
//	 * Test del método getEdge donde no existe el nodo origen
//	 */
//	@Test
//	public void testGetEdgeSourceDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 4;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-1, g.getEdge(node3, node2),0.1);
//	}
//	/**
//	 * Test del método getEdge donde no existe el nodo destino
//	 */
//	@Test
//	public void testGetEdgeTargetDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 4;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-2, g.getEdge(node, node3),0.1);
//	}
//	/**
//	 * Test del método getEdge donde existen los nodos y no la arista
//	 */
//	@Test
//	public void testGetEdgeEdgeDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(-4, g.getEdge(node, node2),0.1);
//	}
//	/**
//	 * Test del método getEdge donde no existen los nodos
//	 */
//	@Test
//	public void testGetEdgeBothDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 4;
//		int node4 = 6;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-3, g.getEdge(node3, node4),0.1);
//	}
//	
///*
// * Pruebas del método existsEdge:
// */
//	/**
//	 * Test del método existsEdge que no tiene errores
//	 */
//	@Test
//	public void testExistsEdgeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertTrue(g.existsEdge(node, node2));
//	}
//	/**
//	 * Test del método existsEdge donde no existe el nodo origen
//	 */
//	@Test
//	public void testExistsEdgeSourceDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3= 8;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertFalse(g.existsEdge(node3, node2));
//	}
//	/**
//	 * Test del método existsEdge donde no existe el nodo destino
//	 */
//	@Test
//	public void testExistsEdgeTargetDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3= 8;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertFalse(g.existsEdge(node, node3));
//	}
//	/**
//	 * Test del método existsEdge donde no existen los nodos
//	 */
//	@Test
//	public void testExistsEdgeBothDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		int node4 = 12;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertFalse(g.existsEdge(node3, node4));
//	}
//	
///*
// * Pruebas del método removeEdge:
// */
//	/**
//	 * Test del método removeEdge que no tiene errores 
//	 */
//	@Test
//	public void testRemoveEdgeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		int node4 = 12;
//		g.addNode(node);
//		g.addNode(node2); 
//		g.addNode(node3);
//		g.addNode(node4);
//		g.addEdge(node, node2, 4);
//		g.addEdge(node3, node4, 12);
//		assertEquals(0, g.removeEdge(node3, node4));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeEdge donde no existe el nodo origen
//	 */
//	@Test
//	public void testRemoveEdgeSourceDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		g.addNode(node);
//		g.addNode(node2); 
//		g.addEdge(node, node2, 4);
//		assertEquals(-1, g.removeEdge(node3, node2));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeEdge donde no existe el nodo destino
//	 */
//	@Test
//	public void testRemoveEdgeTargetDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		g.addNode(node);
//		g.addNode(node2); 
//		g.addEdge(node, node2, 4);
//		assertEquals(-2, g.removeEdge(node2, node3));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeEdge donde existen los nodos y no la arista
//	 */
//	@Test
//	public void testRemoveEdgeEdgeDontExistsNodesExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2); 
//		g.addEdge(node, node2, 4);
//		assertEquals(-4, g.removeEdge(node2, node));
//		System.out.println(g.toString());
//	}	
//	/**
//	 * Test del método removeEdge donde no existen los nodos
//	 */
//	@Test
//	public void testRemoveEdgeNodesDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		int node4 = 12;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-3, g.removeEdge(node3, node4));
//		System.out.println(g.toString());
//	}
///*
// * Pruebas del método removeNode:
// */
//	/**
//	 * Test del método removeNode que no tiene errores
//	 */
//	@Test
//	public void testRemoveNodeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;		
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(0, g.removeNode(node));
//		assertFalse(g.existsNode(node));
//		assertFalse(g.existsEdge(node, node2));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeNode que no tiene errores y borra toda la matriz
//	 */
//	@Test
//	public void testRemoveNodeVarious() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		int node4 = 12;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		g.addEdge(node, node, 12);
//		g.addEdge(node3, node, 7);
//		g.addEdge(node, node4, 15);
//		g.addEdge(node, node3, 9);
//		assertEquals(0, g.removeNode(node));
//		assertFalse(g.existsNode(node));
//		assertFalse(g.existsEdge(node, node2));
//		assertFalse(g.existsEdge(node, node));
//		assertFalse(g.existsEdge(node3, node));
//		assertFalse(g.existsEdge(node, node4));
//		assertFalse(g.existsEdge(node, node3));
//		System.out.println(g.toString());
//	}	
//	/**
//	 * Test del método removeNode donde el nodo no es valido
//	 */
//	@Test
//	public void testRemoveNodeNotValid() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;		
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-1, g.removeNode(null));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeNode donde el nodo no existe
//	 */
//	@Test
//	public void testRemoveNodeDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 12;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-1, g.removeNode(node3));
//		System.out.println(g.toString());
//	}
	/**
	 * Pruebas basicas de nodos
	 */
//	@Test
//	public void basicNodeTest() {
//		g=new Graph<Integer>(3); 
//	    assertFalse(g.existsNode(1)); //false
//	    assertFalse(g.existsNode(2)); //false
//	    assertEquals(0,g.addNode(1)); //0
//		assertEquals(0,g.addNode(2)); //0
//		assertTrue(g.existsNode(1)); //true
//		assertTrue(g.existsNode(2)); //true
//		assertEquals(-1,g.addNode(1)); //-1
//		assertEquals(-1,g.addNode(2)); //-1
//		assertEquals(0,g.addNode(3)); //0
//		assertEquals(-2,g.addNode(4)); //-2
//		assertFalse(g.existsNode(4)); //false
//		assertFalse(g.existsNode(5)); //false
//	}
	
//	@Test
//	public void basicEdgeTest() {
//		g=new Graph<Integer>(3); 
//		assertFalse(g.existsEdge(1,2)); //false
//		assertEquals(-3.0,g.getEdge(1,2),0.1); //-3.0
//		assertEquals(0,g.addNode(1)); //0
//		assertFalse(g.existsEdge(1,2)); //false
//		assertEquals(-2.0,g.getEdge(1,2),0.1); //-2.0
//		assertFalse(g.existsEdge(2,1)); //false
//		assertEquals(-1.0,g.getEdge(2,1),0.1); //-1.0
//		assertEquals(0,g.addNode(2)); //0
//		assertFalse(g.existsEdge(1,2)); //false
//		assertEquals(-4.0,g.getEdge(1,2),0.1); //-4.0
//		assertEquals(0,g.addEdge(1,2,12.12)); //0
//		assertEquals(-4,g.addEdge(1,2,12.1212)); //-4
//		assertEquals(0,g.addNode(3)); //0
//		assertFalse(g.existsEdge(1,3)); //false
//		assertFalse(g.existsEdge(3,2)); //false
//		assertEquals(-4.0,g.getEdge(1,3),0.1); //-4.0
//		assertEquals(-4.0,g.getEdge(3,2),0.1); //-4.0
//		assertEquals(0,g.addEdge(1,1,11.11)); //0
//		assertEquals(-4,g.addEdge(1,2,12.12)); //-4
//		assertEquals(0,g.addEdge(1,3,13.13)); //0
//		assertEquals(0,g.addEdge(2,1,21.21)); //0
//		assertEquals(0,g.addEdge(2,2,22.22)); //0
//		assertEquals(0,g.addEdge(2,3,23.23)); //0
//		assertEquals(0,g.addEdge(3,1,31.31)); //0
//		assertEquals(0,g.addEdge(3,2,32.32)); //0
//		assertEquals(0,g.addEdge(3,3,33.33)); //0
//		assertEquals(-4,g.addEdge(1,1,11.11)); //-4
//		assertEquals(-4,g.addEdge(1,2,12.12)); //-4
//		assertEquals(-4,g.addEdge(1,3,13.13)); //-4
//		assertEquals(-4,g.addEdge(2,1,21.21)); //-4
//		assertEquals(-4,g.addEdge(2,2,22.22)); //-4
//		assertEquals(-4,g.addEdge(2,3,23.23)); //-4
//		assertEquals(-4,g.addEdge(3,1,31.31)); //-4
//		assertEquals(-4,g.addEdge(3,2,32.32)); //-4
//		assertEquals(-4,g.addEdge(3,3,33.33)); //-4
//		g.getEdge(1,1,11.11); //11.11
//		g.getEdge(1,2,12.12); //12.12
//		g.getEdge(1,3,13.13); //13.129999999999999
//		g.getEdge(2,1,21.21); //21.21
//		g.getEdge(2,2,22.22); //22.22
//		g.getEdge(2,3,23.23); //23.23
//		g.getEdge(3,1,31.31); //31.310000000000002
//		g.getEdge(3,2,32.32); //32.32
//		g.getEdge(3,3,33.33); //33.33
//	}
	
	@Test
	public void basicEvolutionTest() {
		1 g.existsNode(1): //false
		2 g.existsNode(2): false
		3 g.addNode(1): 0
		4 g.addNode(2): 0
		5 g.existsNode(1): true
		6 g.existsNode(2): true
		7 g.addNode(1): -1
		8 g.addNode(2): -1
		9 g.addEdge(1,2, 1.2): 0
		10 g.addEdge(2,1, 2.1): 0
		11 g.addEdge(1,1, 1.1): 0
		12 g.getEdge(1,2): 1.2
		13 g.getEdge(2,1): 2.1
		14 g.getEdge(1,1): 1.1
		15 g.getEdge(2,3): -2.0
		16 g.existsEdge(1,2): true
		17 g.existsEdge(2,1): true
		18 g.existsEdge(1,1): true
		19 g.existsEdge(2,2): false
		20 g.removeEdge(2,2): -4
		21 g.addEdge(2,2,2.2): 0
		22 g.getEdge(2,2): 2.2
		23 g.existsEdge(2,2): true
		24 g.removeEdge(2,2): 0
		25 g.removeNode(3): -1
		26 g.addNode(3): 0
		27 g.addNode(4): -2
		28 g.getEdge(1, 3): -4.0
		29 g.addEdge(1,3, 1.3): 0
		30 g.existsEdge(1, 3): //true----------------(false)
		31 g.getEdge(1, 3): 1.3
		32 g.getEdge(1, 4): -2.0
		33 g.getEdge(5,1): -1.0
		34 g.getEdge(5,4): -3.0
		35 g.removeNode(3): 0
		36 g.removeNode(3): //0----------------(-1)
		37 g.existsEdge(1, 3): true
		38 g.getEdge(1, 3): //1.3-------------------(-2.0)
		39 g.removeNode(2): 0
		40 g.removeNode(2): //0---------------------(-1)
		41 g.existsEdge(1, 1): true
		42 g.removeNode(1): 0
		43 g.existsNode(1): //true----------------------(false)
		44 g.existsNode(2): true
		45 g.existsNode(3): true
		46 g.existsNode(4): false
		47 g.addNode(4): 0
		48 g.existsNode(4): true
		49 g.addEdge(4,4, 4.4): 0
		50 g.existsEdge(4, 4): true
		51 g.getEdge(4, 4): 4.4
		52 g.removeNode(4): 0
		53 g.removeNode(4): 0
		54 g.existsEdge(4, 4): true
		55 g.addNode(7): 0
		56 g.removeNode(2): 0
		57 g.removeNode(3): 0
		58 g.removeNode(4): -1
		59 g.existsEdge(7, 7): false
		60 g.addEdge(7,7, 7.7): 0
		61 g.addEdge(7,7, 17.17): -4
		62 g.getEdge(7, 7): 7.7
		63 g.addNode(8): 0
		64 g.addNode(9): 0
		65 g.existsEdge(7, 8): false
		66 g.existsEdge(8, 7): false
		67 g.existsEdge(8, 8): false
		68 g.existsEdge(8, 9): true
		69 g.existsEdge(9, 8): true
		70 g.existsEdge(9, 9): false
		71 g.addEdge(7,8, 7.8): 0
		72 g.addEdge(8,7, 8.7): 0
		73 g.addEdge(8,8, 8.8): 0
		74 g.addEdge(8,9, 8.9): -4
		75 g.addEdge(9,8, 9.8): -4
		76 g.addEdge(9,9, 9.9): 0
		77 g.addEdge(7,9, 7.9): 0
		78 g.addEdge(9,7, 9.7): 0
		79 g.getEdge(7, 7) --> -4.0
		80 g.getEdge(7, 8) --> 7.8
		81 g.getEdge(7, 9) --> 7.9
		82 g.getEdge(8, 7) --> 8.7
		83 g.getEdge(8, 8) --> 8.8
		84 g.getEdge(8, 9) --> 1.2
		85 g.getEdge(9, 7) --> 9.7
		86 g.getEdge(9, 8) --> 2.1
		87 g.getEdge(9, 9) --> 9.9
		88 g.removeNode(7): 0
		89 g.removeNode(7): 0
		90 g.getEdge(7, 7) --> -4.0
		91 g.getEdge(7, 8) --> 7.8
		92 g.getEdge(7, 9) --> 7.9
		93 g.getEdge(8, 7) --> 8.7
		94 g.getEdge(8, 8) --> 8.8
		95 g.getEdge(8, 9) --> 1.2
		96 g.getEdge(9, 7) --> 9.7
		97 g.getEdge(9, 8) --> 2.1
		98 g.getEdge(9, 9) --> 9.9
		99 g.removeNode(null): -1
		100 g.addNode(null): -4
		101 g.addNode(10): 0
		102 g.getEdge(8, 10) --> 8.7
		103 g.getEdge(10, 9) --> 7.9
		104 g.addNode(null): -6
		105 g.addEdge(8,8,-8.8): -12
		106 g.addEdge(7,8,-7.8): -9
		107 g.addEdge(8,7,-8.7): -10
		108 g.addEdge(7,7,-7.7): -11
		109 g.addEdge(null,8,0.8): -1
		110 g.addEdge(8,null,0.8): -2
		111 g.addEdge(null,null,0.8): -3
		112 g.getEdge(null,10): -1.0
		113 g.getEdge(10,null): -2.0
		114 g.getEdge(null,null): -3.0
		115 g.existsNode(null): false
		116 g.existsEdge(null,null): false
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-10-06 00:59:53.367
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-10-06 00:59:53.368
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-10-06 00:59:53.410
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package p2Grafos;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import org.junit.Test;

/**
 * Titulo: Clase GraphTests
 * 
 * @author UO281847
 * @version 24/09/2021
 */
public class GraphTests {
	private Graph<Integer> g;
///*
// * Pruebas del método addNode:	
// */
//	/**
//	 * Test del método addNode sin errores
//	 */
//	@Test
//	public void testAddNodeFirst() {
//		Graph<Integer> g = new Graph<Integer>(3);
//		int node = 12;
//		assertEquals(0, g.addNode(node));
//		System.out.println(g.toString());	
//	}	
//	/**
//	 * Test del método addNode con nodo no valido
//	 */
//	@Test
//	public void testAddNodeNotValid() {
//		Graph<Integer> g = new Graph<Integer>(3);
//		int node = 1;
//		int node2 = 18;
//		assertEquals(0, g.addNode(node));
//		assertEquals(0, g.addNode(node2));
//		assertEquals(-5, g.addNode(null));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addNode cuando ya esta lleno
//	 */
//	@Test
//	public void testAddNodeFull() {
//		Graph<Integer> g = new Graph<Integer>(3);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 39;
//		int node4= 2;
//		assertEquals(0, g.addNode(node));
//		assertEquals(0, g.addNode(node2));
//		assertEquals(0, g.addNode(node3));
//		assertEquals(-2, g.addNode(node4));		
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addNode cuando ya existe
//	 */
//	@Test
//	public void testAddNodeAlreadyExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 39;
//		int node4 = 19;
//		int node5= 19;
//		assertEquals(0, g.addNode(node));
//		assertEquals(0, g.addNode(node2));
//		assertEquals(0, g.addNode(node3));
//		assertEquals(0, g.addNode(node4));
//		assertEquals(-1, g.addNode(node5));	
//		System.out.println(g.toString());	
//	}
//	
///*
// * Pruebas del método getNode:
// */
//	/**
//	 * Test del método getNode que devuelve la posición
//	 */
//	@Test
//	public void testGetNodeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		g.addNode(node);
//		assertEquals(0, g.getNode(node));
//	}
//	/**
//	 * Test del método getNode que devuelve la posición ya añadido
//	 */
//	@Test
//	public void testGetNodeVarious() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 23;
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(1, g.getNode(node2));
//	}
//	/**
//	 * Test del método getNode que devuelve -1
//	 */
//	@Test
//	public void testGetNodeDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 23;
//		g.addNode(node);
//		assertEquals(-1, g.getNode(node2));
//	}
//
///**
// * Pruebas del método existsNode:
// */
//	/**
//	 * Test del método existsNode que devuelve true
//	 */
//	@Test
//	public void testExistsNodeOne() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		g.addNode(node);
//		assertTrue(g.existsNode(node));
//	}
//	/**
//	 * Test del método existsNode que devuelve true
//	 */
//	@Test
//	public void testExistsNodeVarious() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 23;
//		g.addNode(node);
//		g.addNode(node2);
//		assertTrue(g.existsNode(node2));
//	}
//	/**
//	 * Test del método existsNode que devuelve true
//	 */
//	@Test
//	public void testExistsNodeFalse() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 23;
//		g.addNode(node);
//		assertFalse(g.existsNode(node2));
//	}
//
///*
// * Pruebas del método addEdge:
// */
//	/**
//	 * Test del método addEdge que no tiene errores
//	 */
//	@Test
//	public void testAddEdgeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;		
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(0, g.addEdge(node, node2, 12));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde no existe el nodo origen
//	 */
//	@Test
//	public void testAddEdgeSourceDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 23;
//		g.addNode(node);
//		g.addNode(node2);		
//		assertEquals(-1, g.addEdge(node3, node2, 12));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde no existe el nodo destino
//	 */
//	@Test
//	public void testAddEdgeTargetDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 23;
//		g.addNode(node);
//		g.addNode(node2);		
//		assertEquals(-2, g.addEdge(node, node3, 12));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde ya existe la arista
//	 */
//	@Test
//	public void testAddEdgeEdgeExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 12);
//		assertEquals(-4, g.addEdge(node, node2, 12));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde el peso no es valido
//	 */
//	@Test
//	public void testAddEdgeEdgeWightError() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(-8, g.addEdge(node, node2, -4));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde no existen los nodos 
//	 */
//	@Test
//	public void testAddEdgeSourceTargetError() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 12;
//		int node4 = 56;
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(-3, g.addEdge(node3, node4, 4));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde ya existe la arista y el peso no es valido
//	 */
//	@Test
//	public void testAddEdgeEdgeExistsEdgeWeightError() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-12, g.addEdge(node, node2, -4));
//		System.out.println(g.toString());	
//	}
//	
///*
// * Pruebas del método getEdge:
// */
//	/**
//	 * Test del método getEdge que no tiene errores
//	 */
//	@Test
//	public void testGetEdgeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(4, g.getEdge(node, node2),0.1);
//	}
//	/**
//	 * Test del método getEdge donde no existe el nodo origen
//	 */
//	@Test
//	public void testGetEdgeSourceDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 4;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-1, g.getEdge(node3, node2),0.1);
//	}
//	/**
//	 * Test del método getEdge donde no existe el nodo destino
//	 */
//	@Test
//	public void testGetEdgeTargetDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 4;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-2, g.getEdge(node, node3),0.1);
//	}
//	/**
//	 * Test del método getEdge donde existen los nodos y no la arista
//	 */
//	@Test
//	public void testGetEdgeEdgeDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(-4, g.getEdge(node, node2),0.1);
//	}
//	/**
//	 * Test del método getEdge donde no existen los nodos
//	 */
//	@Test
//	public void testGetEdgeBothDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 4;
//		int node4 = 6;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-3, g.getEdge(node3, node4),0.1);
//	}
//	
///*
// * Pruebas del método existsEdge:
// */
//	/**
//	 * Test del método existsEdge que no tiene errores
//	 */
//	@Test
//	public void testExistsEdgeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertTrue(g.existsEdge(node, node2));
//	}
//	/**
//	 * Test del método existsEdge donde no existe el nodo origen
//	 */
//	@Test
//	public void testExistsEdgeSourceDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3= 8;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertFalse(g.existsEdge(node3, node2));
//	}
//	/**
//	 * Test del método existsEdge donde no existe el nodo destino
//	 */
//	@Test
//	public void testExistsEdgeTargetDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3= 8;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertFalse(g.existsEdge(node, node3));
//	}
//	/**
//	 * Test del método existsEdge donde no existen los nodos
//	 */
//	@Test
//	public void testExistsEdgeBothDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		int node4 = 12;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertFalse(g.existsEdge(node3, node4));
//	}
//	
///*
// * Pruebas del método removeEdge:
// */
//	/**
//	 * Test del método removeEdge que no tiene errores 
//	 */
//	@Test
//	public void testRemoveEdgeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		int node4 = 12;
//		g.addNode(node);
//		g.addNode(node2); 
//		g.addNode(node3);
//		g.addNode(node4);
//		g.addEdge(node, node2, 4);
//		g.addEdge(node3, node4, 12);
//		assertEquals(0, g.removeEdge(node3, node4));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeEdge donde no existe el nodo origen
//	 */
//	@Test
//	public void testRemoveEdgeSourceDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		g.addNode(node);
//		g.addNode(node2); 
//		g.addEdge(node, node2, 4);
//		assertEquals(-1, g.removeEdge(node3, node2));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeEdge donde no existe el nodo destino
//	 */
//	@Test
//	public void testRemoveEdgeTargetDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		g.addNode(node);
//		g.addNode(node2); 
//		g.addEdge(node, node2, 4);
//		assertEquals(-2, g.removeEdge(node2, node3));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeEdge donde existen los nodos y no la arista
//	 */
//	@Test
//	public void testRemoveEdgeEdgeDontExistsNodesExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2); 
//		g.addEdge(node, node2, 4);
//		assertEquals(-4, g.removeEdge(node2, node));
//		System.out.println(g.toString());
//	}	
//	/**
//	 * Test del método removeEdge donde no existen los nodos
//	 */
//	@Test
//	public void testRemoveEdgeNodesDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		int node4 = 12;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-3, g.removeEdge(node3, node4));
//		System.out.println(g.toString());
//	}
///*
// * Pruebas del método removeNode:
// */
//	/**
//	 * Test del método removeNode que no tiene errores
//	 */
//	@Test
//	public void testRemoveNodeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;		
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(0, g.removeNode(node));
//		assertFalse(g.existsNode(node));
//		assertFalse(g.existsEdge(node, node2));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeNode que no tiene errores y borra toda la matriz
//	 */
//	@Test
//	public void testRemoveNodeVarious() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		int node4 = 12;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		g.addEdge(node, node, 12);
//		g.addEdge(node3, node, 7);
//		g.addEdge(node, node4, 15);
//		g.addEdge(node, node3, 9);
//		assertEquals(0, g.removeNode(node));
//		assertFalse(g.existsNode(node));
//		assertFalse(g.existsEdge(node, node2));
//		assertFalse(g.existsEdge(node, node));
//		assertFalse(g.existsEdge(node3, node));
//		assertFalse(g.existsEdge(node, node4));
//		assertFalse(g.existsEdge(node, node3));
//		System.out.println(g.toString());
//	}	
//	/**
//	 * Test del método removeNode donde el nodo no es valido
//	 */
//	@Test
//	public void testRemoveNodeNotValid() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;		
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-1, g.removeNode(null));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeNode donde el nodo no existe
//	 */
//	@Test
//	public void testRemoveNodeDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 12;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-1, g.removeNode(node3));
//		System.out.println(g.toString());
//	}
	/**
	 * Pruebas basicas de nodos
	 */
//	@Test
//	public void basicNodeTest() {
//		g=new Graph<Integer>(3); 
//	    assertFalse(g.existsNode(1)); //false
//	    assertFalse(g.existsNode(2)); //false
//	    assertEquals(0,g.addNode(1)); //0
//		assertEquals(0,g.addNode(2)); //0
//		assertTrue(g.existsNode(1)); //true
//		assertTrue(g.existsNode(2)); //true
//		assertEquals(-1,g.addNode(1)); //-1
//		assertEquals(-1,g.addNode(2)); //-1
//		assertEquals(0,g.addNode(3)); //0
//		assertEquals(-2,g.addNode(4)); //-2
//		assertFalse(g.existsNode(4)); //false
//		assertFalse(g.existsNode(5)); //false
//	}
	
//	@Test
//	public void basicEdgeTest() {
//		g=new Graph<Integer>(3); 
//		assertFalse(g.existsEdge(1,2)); //false
//		assertEquals(-3.0,g.getEdge(1,2),0.1); //-3.0
//		assertEquals(0,g.addNode(1)); //0
//		assertFalse(g.existsEdge(1,2)); //false
//		assertEquals(-2.0,g.getEdge(1,2),0.1); //-2.0
//		assertFalse(g.existsEdge(2,1)); //false
//		assertEquals(-1.0,g.getEdge(2,1),0.1); //-1.0
//		assertEquals(0,g.addNode(2)); //0
//		assertFalse(g.existsEdge(1,2)); //false
//		assertEquals(-4.0,g.getEdge(1,2),0.1); //-4.0
//		assertEquals(0,g.addEdge(1,2,12.12)); //0
//		assertEquals(-4,g.addEdge(1,2,12.1212)); //-4
//		assertEquals(0,g.addNode(3)); //0
//		assertFalse(g.existsEdge(1,3)); //false
//		assertFalse(g.existsEdge(3,2)); //false
//		assertEquals(-4.0,g.getEdge(1,3),0.1); //-4.0
//		assertEquals(-4.0,g.getEdge(3,2),0.1); //-4.0
//		assertEquals(0,g.addEdge(1,1,11.11)); //0
//		assertEquals(-4,g.addEdge(1,2,12.12)); //-4
//		assertEquals(0,g.addEdge(1,3,13.13)); //0
//		assertEquals(0,g.addEdge(2,1,21.21)); //0
//		assertEquals(0,g.addEdge(2,2,22.22)); //0
//		assertEquals(0,g.addEdge(2,3,23.23)); //0
//		assertEquals(0,g.addEdge(3,1,31.31)); //0
//		assertEquals(0,g.addEdge(3,2,32.32)); //0
//		assertEquals(0,g.addEdge(3,3,33.33)); //0
//		assertEquals(-4,g.addEdge(1,1,11.11)); //-4
//		assertEquals(-4,g.addEdge(1,2,12.12)); //-4
//		assertEquals(-4,g.addEdge(1,3,13.13)); //-4
//		assertEquals(-4,g.addEdge(2,1,21.21)); //-4
//		assertEquals(-4,g.addEdge(2,2,22.22)); //-4
//		assertEquals(-4,g.addEdge(2,3,23.23)); //-4
//		assertEquals(-4,g.addEdge(3,1,31.31)); //-4
//		assertEquals(-4,g.addEdge(3,2,32.32)); //-4
//		assertEquals(-4,g.addEdge(3,3,33.33)); //-4
//		g.getEdge(1,1,11.11); //11.11
//		g.getEdge(1,2,12.12); //12.12
//		g.getEdge(1,3,13.13); //13.129999999999999
//		g.getEdge(2,1,21.21); //21.21
//		g.getEdge(2,2,22.22); //22.22
//		g.getEdge(2,3,23.23); //23.23
//		g.getEdge(3,1,31.31); //31.310000000000002
//		g.getEdge(3,2,32.32); //32.32
//		g.getEdge(3,3,33.33); //33.33
//	}
	
	@Test
	public void basicEvolutionTest() {
		1 g.existsNode(1): //false
		2 g.existsNode(2): false
		3 g.addNode(1): 0
		4 g.addNode(2): 0
		5 g.existsNode(1): true
		6 g.existsNode(2): true
		7 g.addNode(1): -1
		8 g.addNode(2): -1
		9 g.addEdge(1,2, 1.2): 0
		10 g.addEdge(2,1, 2.1): 0
		11 g.addEdge(1,1, 1.1): 0
		12 g.getEdge(1,2): 1.2
		13 g.getEdge(2,1): 2.1
		14 g.getEdge(1,1): 1.1
		15 g.getEdge(2,3): -2.0
		16 g.existsEdge(1,2): true
		17 g.existsEdge(2,1): true
		18 g.existsEdge(1,1): true
		19 g.existsEdge(2,2): false
		20 g.removeEdge(2,2): -4
		21 g.addEdge(2,2,2.2): 0
		22 g.getEdge(2,2): 2.2
		23 g.existsEdge(2,2): true
		24 g.removeEdge(2,2): 0
		25 g.removeNode(3): -1
		26 g.addNode(3): 0
		27 g.addNode(4): -2
		28 g.getEdge(1, 3): -4.0
		29 g.addEdge(1,3, 1.3): 0
		30 g.existsEdge(1, 3): //true----------------(false)
		31 g.getEdge(1, 3): 1.3
		32 g.getEdge(1, 4): -2.0
		33 g.getEdge(5,1): -1.0
		34 g.getEdge(5,4): -3.0
		35 g.removeNode(3): 0
		36 g.removeNode(3): //0----------------(-1)
		37 g.existsEdge(1, 3): true
		38 g.getEdge(1, 3): //1.3-------------------(-2.0)
		39 g.removeNode(2): 0
		40 g.removeNode(2): //0---------------------(-1)
		41 g.existsEdge(1, 1): true
		42 g.removeNode(1): 0
		43 g.existsNode(1): //true----------------------(false)
		44 g.existsNode(2): true
		45 g.existsNode(3): true
		46 g.existsNode(4): false
		47 g.addNode(4): 0
		48 g.existsNode(4): true
		49 g.addEdge(4,4, 4.4): 0
		50 g.existsEdge(4, 4): true
		51 g.getEdge(4, 4): 4.4
		52 g.removeNode(4): 0
		53 g.removeNode(4): 0
		54 g.existsEdge(4, 4): true
		55 g.addNode(7): 0
		56 g.removeNode(2): 0
		57 g.removeNode(3): 0
		58 g.removeNode(4): -1
		59 g.existsEdge(7, 7): false
		60 g.addEdge(7,7, 7.7): 0
		61 g.addEdge(7,7, 17.17): -4
		62 g.getEdge(7, 7): 7.7
		63 g.addNode(8): 0
		64 g.addNode(9): 0
		65 g.existsEdge(7, 8): false
		66 g.existsEdge(8, 7): false
		67 g.existsEdge(8, 8): false
		68 g.existsEdge(8, 9): true
		69 g.existsEdge(9, 8): true
		70 g.existsEdge(9, 9): false
		71 g.addEdge(7,8, 7.8): 0
		72 g.addEdge(8,7, 8.7): 0
		73 g.addEdge(8,8, 8.8): 0
		74 g.addEdge(8,9, 8.9): -4
		75 g.addEdge(9,8, 9.8): -4
		76 g.addEdge(9,9, 9.9): 0
		77 g.addEdge(7,9, 7.9): 0
		78 g.addEdge(9,7, 9.7): 0
		79 g.getEdge(7, 7) --> -4.0
		80 g.getEdge(7, 8) --> 7.8
		81 g.getEdge(7, 9) --> 7.9
		82 g.getEdge(8, 7) --> 8.7
		83 g.getEdge(8, 8) --> 8.8
		84 g.getEdge(8, 9) --> 1.2
		85 g.getEdge(9, 7) --> 9.7
		86 g.getEdge(9, 8) --> 2.1
		87 g.getEdge(9, 9) --> 9.9
		88 g.removeNode(7): 0
		89 g.removeNode(7): 0
		90 g.getEdge(7, 7) --> -4.0
		91 g.getEdge(7, 8) --> 7.8
		92 g.getEdge(7, 9) --> 7.9
		93 g.getEdge(8, 7) --> 8.7
		94 g.getEdge(8, 8) --> 8.8
		95 g.getEdge(8, 9) --> 1.2
		96 g.getEdge(9, 7) --> 9.7
		97 g.getEdge(9, 8) --> 2.1
		98 g.getEdge(9, 9) --> 9.9
		99 g.removeNode(null): -1
		100 g.addNode(null): -4
		101 g.addNode(10): 0
		102 g.getEdge(8, 10) --> 8.7
		103 g.getEdge(10, 9) --> 7.9
		104 g.addNode(null): -6
		105 g.addEdge(8,8,-8.8): -12
		106 g.addEdge(7,8,-7.8): -9
		107 g.addEdge(8,7,-8.7): -10
		108 g.addEdge(7,7,-7.7): -11
		109 g.addEdge(null,8,0.8): -1
		110 g.addEdge(8,null,0.8): -2
		111 g.addEdge(null,null,0.8): -3
		112 g.getEdge(null,10): -1.0
		113 g.getEdge(10,null): -2.0
		114 g.getEdge(null,null): -3.0
		115 g.existsNode(null): false
		116 g.existsEdge(null,null): false
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-10-06 00:59:53.412
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-10-06 00:59:53.414
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-10-06 00:59:54.854
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package p2Grafos;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import org.junit.Test;

/**
 * Titulo: Clase GraphTests
 * 
 * @author UO281847
 * @version 24/09/2021
 */
public class GraphTests {
	private Graph<Integer> g;
///*
// * Pruebas del método addNode:	
// */
//	/**
//	 * Test del método addNode sin errores
//	 */
//	@Test
//	public void testAddNodeFirst() {
//		Graph<Integer> g = new Graph<Integer>(3);
//		int node = 12;
//		assertEquals(0, g.addNode(node));
//		System.out.println(g.toString());	
//	}	
//	/**
//	 * Test del método addNode con nodo no valido
//	 */
//	@Test
//	public void testAddNodeNotValid() {
//		Graph<Integer> g = new Graph<Integer>(3);
//		int node = 1;
//		int node2 = 18;
//		assertEquals(0, g.addNode(node));
//		assertEquals(0, g.addNode(node2));
//		assertEquals(-5, g.addNode(null));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addNode cuando ya esta lleno
//	 */
//	@Test
//	public void testAddNodeFull() {
//		Graph<Integer> g = new Graph<Integer>(3);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 39;
//		int node4= 2;
//		assertEquals(0, g.addNode(node));
//		assertEquals(0, g.addNode(node2));
//		assertEquals(0, g.addNode(node3));
//		assertEquals(-2, g.addNode(node4));		
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addNode cuando ya existe
//	 */
//	@Test
//	public void testAddNodeAlreadyExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 39;
//		int node4 = 19;
//		int node5= 19;
//		assertEquals(0, g.addNode(node));
//		assertEquals(0, g.addNode(node2));
//		assertEquals(0, g.addNode(node3));
//		assertEquals(0, g.addNode(node4));
//		assertEquals(-1, g.addNode(node5));	
//		System.out.println(g.toString());	
//	}
//	
///*
// * Pruebas del método getNode:
// */
//	/**
//	 * Test del método getNode que devuelve la posición
//	 */
//	@Test
//	public void testGetNodeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		g.addNode(node);
//		assertEquals(0, g.getNode(node));
//	}
//	/**
//	 * Test del método getNode que devuelve la posición ya añadido
//	 */
//	@Test
//	public void testGetNodeVarious() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 23;
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(1, g.getNode(node2));
//	}
//	/**
//	 * Test del método getNode que devuelve -1
//	 */
//	@Test
//	public void testGetNodeDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 23;
//		g.addNode(node);
//		assertEquals(-1, g.getNode(node2));
//	}
//
///**
// * Pruebas del método existsNode:
// */
//	/**
//	 * Test del método existsNode que devuelve true
//	 */
//	@Test
//	public void testExistsNodeOne() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		g.addNode(node);
//		assertTrue(g.existsNode(node));
//	}
//	/**
//	 * Test del método existsNode que devuelve true
//	 */
//	@Test
//	public void testExistsNodeVarious() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 23;
//		g.addNode(node);
//		g.addNode(node2);
//		assertTrue(g.existsNode(node2));
//	}
//	/**
//	 * Test del método existsNode que devuelve true
//	 */
//	@Test
//	public void testExistsNodeFalse() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 23;
//		g.addNode(node);
//		assertFalse(g.existsNode(node2));
//	}
//
///*
// * Pruebas del método addEdge:
// */
//	/**
//	 * Test del método addEdge que no tiene errores
//	 */
//	@Test
//	public void testAddEdgeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;		
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(0, g.addEdge(node, node2, 12));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde no existe el nodo origen
//	 */
//	@Test
//	public void testAddEdgeSourceDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 23;
//		g.addNode(node);
//		g.addNode(node2);		
//		assertEquals(-1, g.addEdge(node3, node2, 12));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde no existe el nodo destino
//	 */
//	@Test
//	public void testAddEdgeTargetDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 23;
//		g.addNode(node);
//		g.addNode(node2);		
//		assertEquals(-2, g.addEdge(node, node3, 12));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde ya existe la arista
//	 */
//	@Test
//	public void testAddEdgeEdgeExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 12);
//		assertEquals(-4, g.addEdge(node, node2, 12));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde el peso no es valido
//	 */
//	@Test
//	public void testAddEdgeEdgeWightError() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(-8, g.addEdge(node, node2, -4));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde no existen los nodos 
//	 */
//	@Test
//	public void testAddEdgeSourceTargetError() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 12;
//		int node4 = 56;
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(-3, g.addEdge(node3, node4, 4));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde ya existe la arista y el peso no es valido
//	 */
//	@Test
//	public void testAddEdgeEdgeExistsEdgeWeightError() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-12, g.addEdge(node, node2, -4));
//		System.out.println(g.toString());	
//	}
//	
///*
// * Pruebas del método getEdge:
// */
//	/**
//	 * Test del método getEdge que no tiene errores
//	 */
//	@Test
//	public void testGetEdgeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(4, g.getEdge(node, node2),0.1);
//	}
//	/**
//	 * Test del método getEdge donde no existe el nodo origen
//	 */
//	@Test
//	public void testGetEdgeSourceDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 4;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-1, g.getEdge(node3, node2),0.1);
//	}
//	/**
//	 * Test del método getEdge donde no existe el nodo destino
//	 */
//	@Test
//	public void testGetEdgeTargetDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 4;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-2, g.getEdge(node, node3),0.1);
//	}
//	/**
//	 * Test del método getEdge donde existen los nodos y no la arista
//	 */
//	@Test
//	public void testGetEdgeEdgeDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(-4, g.getEdge(node, node2),0.1);
//	}
//	/**
//	 * Test del método getEdge donde no existen los nodos
//	 */
//	@Test
//	public void testGetEdgeBothDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 4;
//		int node4 = 6;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-3, g.getEdge(node3, node4),0.1);
//	}
//	
///*
// * Pruebas del método existsEdge:
// */
//	/**
//	 * Test del método existsEdge que no tiene errores
//	 */
//	@Test
//	public void testExistsEdgeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertTrue(g.existsEdge(node, node2));
//	}
//	/**
//	 * Test del método existsEdge donde no existe el nodo origen
//	 */
//	@Test
//	public void testExistsEdgeSourceDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3= 8;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertFalse(g.existsEdge(node3, node2));
//	}
//	/**
//	 * Test del método existsEdge donde no existe el nodo destino
//	 */
//	@Test
//	public void testExistsEdgeTargetDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3= 8;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertFalse(g.existsEdge(node, node3));
//	}
//	/**
//	 * Test del método existsEdge donde no existen los nodos
//	 */
//	@Test
//	public void testExistsEdgeBothDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		int node4 = 12;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertFalse(g.existsEdge(node3, node4));
//	}
//	
///*
// * Pruebas del método removeEdge:
// */
//	/**
//	 * Test del método removeEdge que no tiene errores 
//	 */
//	@Test
//	public void testRemoveEdgeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		int node4 = 12;
//		g.addNode(node);
//		g.addNode(node2); 
//		g.addNode(node3);
//		g.addNode(node4);
//		g.addEdge(node, node2, 4);
//		g.addEdge(node3, node4, 12);
//		assertEquals(0, g.removeEdge(node3, node4));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeEdge donde no existe el nodo origen
//	 */
//	@Test
//	public void testRemoveEdgeSourceDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		g.addNode(node);
//		g.addNode(node2); 
//		g.addEdge(node, node2, 4);
//		assertEquals(-1, g.removeEdge(node3, node2));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeEdge donde no existe el nodo destino
//	 */
//	@Test
//	public void testRemoveEdgeTargetDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		g.addNode(node);
//		g.addNode(node2); 
//		g.addEdge(node, node2, 4);
//		assertEquals(-2, g.removeEdge(node2, node3));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeEdge donde existen los nodos y no la arista
//	 */
//	@Test
//	public void testRemoveEdgeEdgeDontExistsNodesExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2); 
//		g.addEdge(node, node2, 4);
//		assertEquals(-4, g.removeEdge(node2, node));
//		System.out.println(g.toString());
//	}	
//	/**
//	 * Test del método removeEdge donde no existen los nodos
//	 */
//	@Test
//	public void testRemoveEdgeNodesDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		int node4 = 12;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-3, g.removeEdge(node3, node4));
//		System.out.println(g.toString());
//	}
///*
// * Pruebas del método removeNode:
// */
//	/**
//	 * Test del método removeNode que no tiene errores
//	 */
//	@Test
//	public void testRemoveNodeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;		
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(0, g.removeNode(node));
//		assertFalse(g.existsNode(node));
//		assertFalse(g.existsEdge(node, node2));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeNode que no tiene errores y borra toda la matriz
//	 */
//	@Test
//	public void testRemoveNodeVarious() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		int node4 = 12;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		g.addEdge(node, node, 12);
//		g.addEdge(node3, node, 7);
//		g.addEdge(node, node4, 15);
//		g.addEdge(node, node3, 9);
//		assertEquals(0, g.removeNode(node));
//		assertFalse(g.existsNode(node));
//		assertFalse(g.existsEdge(node, node2));
//		assertFalse(g.existsEdge(node, node));
//		assertFalse(g.existsEdge(node3, node));
//		assertFalse(g.existsEdge(node, node4));
//		assertFalse(g.existsEdge(node, node3));
//		System.out.println(g.toString());
//	}	
//	/**
//	 * Test del método removeNode donde el nodo no es valido
//	 */
//	@Test
//	public void testRemoveNodeNotValid() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;		
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-1, g.removeNode(null));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeNode donde el nodo no existe
//	 */
//	@Test
//	public void testRemoveNodeDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 12;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-1, g.removeNode(node3));
//		System.out.println(g.toString());
//	}
	/**
	 * Pruebas basicas de nodos
	 */
//	@Test
//	public void basicNodeTest() {
//		g=new Graph<Integer>(3); 
//	    assertFalse(g.existsNode(1)); //false
//	    assertFalse(g.existsNode(2)); //false
//	    assertEquals(0,g.addNode(1)); //0
//		assertEquals(0,g.addNode(2)); //0
//		assertTrue(g.existsNode(1)); //true
//		assertTrue(g.existsNode(2)); //true
//		assertEquals(-1,g.addNode(1)); //-1
//		assertEquals(-1,g.addNode(2)); //-1
//		assertEquals(0,g.addNode(3)); //0
//		assertEquals(-2,g.addNode(4)); //-2
//		assertFalse(g.existsNode(4)); //false
//		assertFalse(g.existsNode(5)); //false
//	}
	
//	@Test
//	public void basicEdgeTest() {
//		g=new Graph<Integer>(3); 
//		assertFalse(g.existsEdge(1,2)); //false
//		assertEquals(-3.0,g.getEdge(1,2),0.1); //-3.0
//		assertEquals(0,g.addNode(1)); //0
//		assertFalse(g.existsEdge(1,2)); //false
//		assertEquals(-2.0,g.getEdge(1,2),0.1); //-2.0
//		assertFalse(g.existsEdge(2,1)); //false
//		assertEquals(-1.0,g.getEdge(2,1),0.1); //-1.0
//		assertEquals(0,g.addNode(2)); //0
//		assertFalse(g.existsEdge(1,2)); //false
//		assertEquals(-4.0,g.getEdge(1,2),0.1); //-4.0
//		assertEquals(0,g.addEdge(1,2,12.12)); //0
//		assertEquals(-4,g.addEdge(1,2,12.1212)); //-4
//		assertEquals(0,g.addNode(3)); //0
//		assertFalse(g.existsEdge(1,3)); //false
//		assertFalse(g.existsEdge(3,2)); //false
//		assertEquals(-4.0,g.getEdge(1,3),0.1); //-4.0
//		assertEquals(-4.0,g.getEdge(3,2),0.1); //-4.0
//		assertEquals(0,g.addEdge(1,1,11.11)); //0
//		assertEquals(-4,g.addEdge(1,2,12.12)); //-4
//		assertEquals(0,g.addEdge(1,3,13.13)); //0
//		assertEquals(0,g.addEdge(2,1,21.21)); //0
//		assertEquals(0,g.addEdge(2,2,22.22)); //0
//		assertEquals(0,g.addEdge(2,3,23.23)); //0
//		assertEquals(0,g.addEdge(3,1,31.31)); //0
//		assertEquals(0,g.addEdge(3,2,32.32)); //0
//		assertEquals(0,g.addEdge(3,3,33.33)); //0
//		assertEquals(-4,g.addEdge(1,1,11.11)); //-4
//		assertEquals(-4,g.addEdge(1,2,12.12)); //-4
//		assertEquals(-4,g.addEdge(1,3,13.13)); //-4
//		assertEquals(-4,g.addEdge(2,1,21.21)); //-4
//		assertEquals(-4,g.addEdge(2,2,22.22)); //-4
//		assertEquals(-4,g.addEdge(2,3,23.23)); //-4
//		assertEquals(-4,g.addEdge(3,1,31.31)); //-4
//		assertEquals(-4,g.addEdge(3,2,32.32)); //-4
//		assertEquals(-4,g.addEdge(3,3,33.33)); //-4
//		g.getEdge(1,1,11.11); //11.11
//		g.getEdge(1,2,12.12); //12.12
//		g.getEdge(1,3,13.13); //13.129999999999999
//		g.getEdge(2,1,21.21); //21.21
//		g.getEdge(2,2,22.22); //22.22
//		g.getEdge(2,3,23.23); //23.23
//		g.getEdge(3,1,31.31); //31.310000000000002
//		g.getEdge(3,2,32.32); //32.32
//		g.getEdge(3,3,33.33); //33.33
//	}
	
	@Test
	public void basicEvolutionTest() {
		1 g.existsNode(1): //false
		2 g.existsNode(2): false
		3 g.addNode(1): 0
		4 g.addNode(2): 0
		5 g.existsNode(1): true
		6 g.existsNode(2): true
		7 g.addNode(1): -1
		8 g.addNode(2): -1
		9 g.addEdge(1,2, 1.2): 0
		10 g.addEdge(2,1, 2.1): 0
		11 g.addEdge(1,1, 1.1): 0
		12 g.getEdge(1,2): 1.2
		13 g.getEdge(2,1): 2.1
		14 g.getEdge(1,1): 1.1
		15 g.getEdge(2,3): -2.0
		16 g.existsEdge(1,2): true
		17 g.existsEdge(2,1): true
		18 g.existsEdge(1,1): true
		19 g.existsEdge(2,2): false
		20 g.removeEdge(2,2): -4
		21 g.addEdge(2,2,2.2): 0
		22 g.getEdge(2,2): 2.2
		23 g.existsEdge(2,2): true
		24 g.removeEdge(2,2): 0
		25 g.removeNode(3): -1
		26 g.addNode(3): 0
		27 g.addNode(4): -2
		28 g.getEdge(1, 3): -4.0
		29 g.addEdge(1,3, 1.3): 0
		30 g.existsEdge(1, 3): //true----------------(false)
		31 g.getEdge(1, 3): 1.3
		32 g.getEdge(1, 4): -2.0
		33 g.getEdge(5,1): -1.0
		34 g.getEdge(5,4): -3.0
		35 g.removeNode(3): 0
		36 g.removeNode(3): //0----------------(-1)
		37 g.existsEdge(1, 3): true
		38 g.getEdge(1, 3): //1.3-------------------(-2.0)
		39 g.removeNode(2): 0
		40 g.removeNode(2): //0---------------------(-1)
		41 g.existsEdge(1, 1): true
		42 g.removeNode(1): 0
		43 g.existsNode(1): //true----------------------(false)
		44 g.existsNode(2): true
		45 g.existsNode(3): true
		46 g.existsNode(4): false
		47 g.addNode(4): 0
		48 g.existsNode(4): true
		49 g.addEdge(4,4, 4.4): 0
		50 g.existsEdge(4, 4): //true
		51 g.getEdge(4, 4): 4.4
		52 g.removeNode(4): 0
		53 g.removeNode(4): 0
		54 g.existsEdge(4, 4): true
		55 g.addNode(7): 0
		56 g.removeNode(2): 0
		57 g.removeNode(3): 0
		58 g.removeNode(4): -1
		59 g.existsEdge(7, 7): false
		60 g.addEdge(7,7, 7.7): 0
		61 g.addEdge(7,7, 17.17): -4
		62 g.getEdge(7, 7): 7.7
		63 g.addNode(8): 0
		64 g.addNode(9): 0
		65 g.existsEdge(7, 8): false
		66 g.existsEdge(8, 7): false
		67 g.existsEdge(8, 8): false
		68 g.existsEdge(8, 9): true
		69 g.existsEdge(9, 8): true
		70 g.existsEdge(9, 9): false
		71 g.addEdge(7,8, 7.8): 0
		72 g.addEdge(8,7, 8.7): 0
		73 g.addEdge(8,8, 8.8): 0
		74 g.addEdge(8,9, 8.9): -4
		75 g.addEdge(9,8, 9.8): -4
		76 g.addEdge(9,9, 9.9): 0
		77 g.addEdge(7,9, 7.9): 0
		78 g.addEdge(9,7, 9.7): 0
		79 g.getEdge(7, 7) --> -4.0
		80 g.getEdge(7, 8) --> 7.8
		81 g.getEdge(7, 9) --> 7.9
		82 g.getEdge(8, 7) --> 8.7
		83 g.getEdge(8, 8) --> 8.8
		84 g.getEdge(8, 9) --> 1.2
		85 g.getEdge(9, 7) --> 9.7
		86 g.getEdge(9, 8) --> 2.1
		87 g.getEdge(9, 9) --> 9.9
		88 g.removeNode(7): 0
		89 g.removeNode(7): 0
		90 g.getEdge(7, 7) --> -4.0
		91 g.getEdge(7, 8) --> 7.8
		92 g.getEdge(7, 9) --> 7.9
		93 g.getEdge(8, 7) --> 8.7
		94 g.getEdge(8, 8) --> 8.8
		95 g.getEdge(8, 9) --> 1.2
		96 g.getEdge(9, 7) --> 9.7
		97 g.getEdge(9, 8) --> 2.1
		98 g.getEdge(9, 9) --> 9.9
		99 g.removeNode(null): -1
		100 g.addNode(null): -4
		101 g.addNode(10): 0
		102 g.getEdge(8, 10) --> 8.7
		103 g.getEdge(10, 9) --> 7.9
		104 g.addNode(null): -6
		105 g.addEdge(8,8,-8.8): -12
		106 g.addEdge(7,8,-7.8): -9
		107 g.addEdge(8,7,-8.7): -10
		108 g.addEdge(7,7,-7.7): -11
		109 g.addEdge(null,8,0.8): -1
		110 g.addEdge(8,null,0.8): -2
		111 g.addEdge(null,null,0.8): -3
		112 g.getEdge(null,10): -1.0
		113 g.getEdge(10,null): -2.0
		114 g.getEdge(null,null): -3.0
		115 g.existsNode(null): false
		116 g.existsEdge(null,null): false
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-10-06 00:59:54.856
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-10-06 00:59:54.857
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-10-06 00:59:55.339
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package p2Grafos;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import org.junit.Test;

/**
 * Titulo: Clase GraphTests
 * 
 * @author UO281847
 * @version 24/09/2021
 */
public class GraphTests {
	private Graph<Integer> g;
///*
// * Pruebas del método addNode:	
// */
//	/**
//	 * Test del método addNode sin errores
//	 */
//	@Test
//	public void testAddNodeFirst() {
//		Graph<Integer> g = new Graph<Integer>(3);
//		int node = 12;
//		assertEquals(0, g.addNode(node));
//		System.out.println(g.toString());	
//	}	
//	/**
//	 * Test del método addNode con nodo no valido
//	 */
//	@Test
//	public void testAddNodeNotValid() {
//		Graph<Integer> g = new Graph<Integer>(3);
//		int node = 1;
//		int node2 = 18;
//		assertEquals(0, g.addNode(node));
//		assertEquals(0, g.addNode(node2));
//		assertEquals(-5, g.addNode(null));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addNode cuando ya esta lleno
//	 */
//	@Test
//	public void testAddNodeFull() {
//		Graph<Integer> g = new Graph<Integer>(3);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 39;
//		int node4= 2;
//		assertEquals(0, g.addNode(node));
//		assertEquals(0, g.addNode(node2));
//		assertEquals(0, g.addNode(node3));
//		assertEquals(-2, g.addNode(node4));		
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addNode cuando ya existe
//	 */
//	@Test
//	public void testAddNodeAlreadyExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 39;
//		int node4 = 19;
//		int node5= 19;
//		assertEquals(0, g.addNode(node));
//		assertEquals(0, g.addNode(node2));
//		assertEquals(0, g.addNode(node3));
//		assertEquals(0, g.addNode(node4));
//		assertEquals(-1, g.addNode(node5));	
//		System.out.println(g.toString());	
//	}
//	
///*
// * Pruebas del método getNode:
// */
//	/**
//	 * Test del método getNode que devuelve la posición
//	 */
//	@Test
//	public void testGetNodeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		g.addNode(node);
//		assertEquals(0, g.getNode(node));
//	}
//	/**
//	 * Test del método getNode que devuelve la posición ya añadido
//	 */
//	@Test
//	public void testGetNodeVarious() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 23;
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(1, g.getNode(node2));
//	}
//	/**
//	 * Test del método getNode que devuelve -1
//	 */
//	@Test
//	public void testGetNodeDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 23;
//		g.addNode(node);
//		assertEquals(-1, g.getNode(node2));
//	}
//
///**
// * Pruebas del método existsNode:
// */
//	/**
//	 * Test del método existsNode que devuelve true
//	 */
//	@Test
//	public void testExistsNodeOne() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		g.addNode(node);
//		assertTrue(g.existsNode(node));
//	}
//	/**
//	 * Test del método existsNode que devuelve true
//	 */
//	@Test
//	public void testExistsNodeVarious() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 23;
//		g.addNode(node);
//		g.addNode(node2);
//		assertTrue(g.existsNode(node2));
//	}
//	/**
//	 * Test del método existsNode que devuelve true
//	 */
//	@Test
//	public void testExistsNodeFalse() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 23;
//		g.addNode(node);
//		assertFalse(g.existsNode(node2));
//	}
//
///*
// * Pruebas del método addEdge:
// */
//	/**
//	 * Test del método addEdge que no tiene errores
//	 */
//	@Test
//	public void testAddEdgeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;		
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(0, g.addEdge(node, node2, 12));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde no existe el nodo origen
//	 */
//	@Test
//	public void testAddEdgeSourceDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 23;
//		g.addNode(node);
//		g.addNode(node2);		
//		assertEquals(-1, g.addEdge(node3, node2, 12));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde no existe el nodo destino
//	 */
//	@Test
//	public void testAddEdgeTargetDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 23;
//		g.addNode(node);
//		g.addNode(node2);		
//		assertEquals(-2, g.addEdge(node, node3, 12));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde ya existe la arista
//	 */
//	@Test
//	public void testAddEdgeEdgeExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 12);
//		assertEquals(-4, g.addEdge(node, node2, 12));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde el peso no es valido
//	 */
//	@Test
//	public void testAddEdgeEdgeWightError() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(-8, g.addEdge(node, node2, -4));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde no existen los nodos 
//	 */
//	@Test
//	public void testAddEdgeSourceTargetError() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 12;
//		int node4 = 56;
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(-3, g.addEdge(node3, node4, 4));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde ya existe la arista y el peso no es valido
//	 */
//	@Test
//	public void testAddEdgeEdgeExistsEdgeWeightError() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-12, g.addEdge(node, node2, -4));
//		System.out.println(g.toString());	
//	}
//	
///*
// * Pruebas del método getEdge:
// */
//	/**
//	 * Test del método getEdge que no tiene errores
//	 */
//	@Test
//	public void testGetEdgeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(4, g.getEdge(node, node2),0.1);
//	}
//	/**
//	 * Test del método getEdge donde no existe el nodo origen
//	 */
//	@Test
//	public void testGetEdgeSourceDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 4;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-1, g.getEdge(node3, node2),0.1);
//	}
//	/**
//	 * Test del método getEdge donde no existe el nodo destino
//	 */
//	@Test
//	public void testGetEdgeTargetDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 4;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-2, g.getEdge(node, node3),0.1);
//	}
//	/**
//	 * Test del método getEdge donde existen los nodos y no la arista
//	 */
//	@Test
//	public void testGetEdgeEdgeDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(-4, g.getEdge(node, node2),0.1);
//	}
//	/**
//	 * Test del método getEdge donde no existen los nodos
//	 */
//	@Test
//	public void testGetEdgeBothDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 4;
//		int node4 = 6;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-3, g.getEdge(node3, node4),0.1);
//	}
//	
///*
// * Pruebas del método existsEdge:
// */
//	/**
//	 * Test del método existsEdge que no tiene errores
//	 */
//	@Test
//	public void testExistsEdgeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertTrue(g.existsEdge(node, node2));
//	}
//	/**
//	 * Test del método existsEdge donde no existe el nodo origen
//	 */
//	@Test
//	public void testExistsEdgeSourceDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3= 8;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertFalse(g.existsEdge(node3, node2));
//	}
//	/**
//	 * Test del método existsEdge donde no existe el nodo destino
//	 */
//	@Test
//	public void testExistsEdgeTargetDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3= 8;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertFalse(g.existsEdge(node, node3));
//	}
//	/**
//	 * Test del método existsEdge donde no existen los nodos
//	 */
//	@Test
//	public void testExistsEdgeBothDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		int node4 = 12;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertFalse(g.existsEdge(node3, node4));
//	}
//	
///*
// * Pruebas del método removeEdge:
// */
//	/**
//	 * Test del método removeEdge que no tiene errores 
//	 */
//	@Test
//	public void testRemoveEdgeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		int node4 = 12;
//		g.addNode(node);
//		g.addNode(node2); 
//		g.addNode(node3);
//		g.addNode(node4);
//		g.addEdge(node, node2, 4);
//		g.addEdge(node3, node4, 12);
//		assertEquals(0, g.removeEdge(node3, node4));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeEdge donde no existe el nodo origen
//	 */
//	@Test
//	public void testRemoveEdgeSourceDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		g.addNode(node);
//		g.addNode(node2); 
//		g.addEdge(node, node2, 4);
//		assertEquals(-1, g.removeEdge(node3, node2));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeEdge donde no existe el nodo destino
//	 */
//	@Test
//	public void testRemoveEdgeTargetDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		g.addNode(node);
//		g.addNode(node2); 
//		g.addEdge(node, node2, 4);
//		assertEquals(-2, g.removeEdge(node2, node3));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeEdge donde existen los nodos y no la arista
//	 */
//	@Test
//	public void testRemoveEdgeEdgeDontExistsNodesExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2); 
//		g.addEdge(node, node2, 4);
//		assertEquals(-4, g.removeEdge(node2, node));
//		System.out.println(g.toString());
//	}	
//	/**
//	 * Test del método removeEdge donde no existen los nodos
//	 */
//	@Test
//	public void testRemoveEdgeNodesDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		int node4 = 12;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-3, g.removeEdge(node3, node4));
//		System.out.println(g.toString());
//	}
///*
// * Pruebas del método removeNode:
// */
//	/**
//	 * Test del método removeNode que no tiene errores
//	 */
//	@Test
//	public void testRemoveNodeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;		
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(0, g.removeNode(node));
//		assertFalse(g.existsNode(node));
//		assertFalse(g.existsEdge(node, node2));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeNode que no tiene errores y borra toda la matriz
//	 */
//	@Test
//	public void testRemoveNodeVarious() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		int node4 = 12;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		g.addEdge(node, node, 12);
//		g.addEdge(node3, node, 7);
//		g.addEdge(node, node4, 15);
//		g.addEdge(node, node3, 9);
//		assertEquals(0, g.removeNode(node));
//		assertFalse(g.existsNode(node));
//		assertFalse(g.existsEdge(node, node2));
//		assertFalse(g.existsEdge(node, node));
//		assertFalse(g.existsEdge(node3, node));
//		assertFalse(g.existsEdge(node, node4));
//		assertFalse(g.existsEdge(node, node3));
//		System.out.println(g.toString());
//	}	
//	/**
//	 * Test del método removeNode donde el nodo no es valido
//	 */
//	@Test
//	public void testRemoveNodeNotValid() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;		
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-1, g.removeNode(null));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeNode donde el nodo no existe
//	 */
//	@Test
//	public void testRemoveNodeDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 12;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-1, g.removeNode(node3));
//		System.out.println(g.toString());
//	}
	/**
	 * Pruebas basicas de nodos
	 */
//	@Test
//	public void basicNodeTest() {
//		g=new Graph<Integer>(3); 
//	    assertFalse(g.existsNode(1)); //false
//	    assertFalse(g.existsNode(2)); //false
//	    assertEquals(0,g.addNode(1)); //0
//		assertEquals(0,g.addNode(2)); //0
//		assertTrue(g.existsNode(1)); //true
//		assertTrue(g.existsNode(2)); //true
//		assertEquals(-1,g.addNode(1)); //-1
//		assertEquals(-1,g.addNode(2)); //-1
//		assertEquals(0,g.addNode(3)); //0
//		assertEquals(-2,g.addNode(4)); //-2
//		assertFalse(g.existsNode(4)); //false
//		assertFalse(g.existsNode(5)); //false
//	}
	
//	@Test
//	public void basicEdgeTest() {
//		g=new Graph<Integer>(3); 
//		assertFalse(g.existsEdge(1,2)); //false
//		assertEquals(-3.0,g.getEdge(1,2),0.1); //-3.0
//		assertEquals(0,g.addNode(1)); //0
//		assertFalse(g.existsEdge(1,2)); //false
//		assertEquals(-2.0,g.getEdge(1,2),0.1); //-2.0
//		assertFalse(g.existsEdge(2,1)); //false
//		assertEquals(-1.0,g.getEdge(2,1),0.1); //-1.0
//		assertEquals(0,g.addNode(2)); //0
//		assertFalse(g.existsEdge(1,2)); //false
//		assertEquals(-4.0,g.getEdge(1,2),0.1); //-4.0
//		assertEquals(0,g.addEdge(1,2,12.12)); //0
//		assertEquals(-4,g.addEdge(1,2,12.1212)); //-4
//		assertEquals(0,g.addNode(3)); //0
//		assertFalse(g.existsEdge(1,3)); //false
//		assertFalse(g.existsEdge(3,2)); //false
//		assertEquals(-4.0,g.getEdge(1,3),0.1); //-4.0
//		assertEquals(-4.0,g.getEdge(3,2),0.1); //-4.0
//		assertEquals(0,g.addEdge(1,1,11.11)); //0
//		assertEquals(-4,g.addEdge(1,2,12.12)); //-4
//		assertEquals(0,g.addEdge(1,3,13.13)); //0
//		assertEquals(0,g.addEdge(2,1,21.21)); //0
//		assertEquals(0,g.addEdge(2,2,22.22)); //0
//		assertEquals(0,g.addEdge(2,3,23.23)); //0
//		assertEquals(0,g.addEdge(3,1,31.31)); //0
//		assertEquals(0,g.addEdge(3,2,32.32)); //0
//		assertEquals(0,g.addEdge(3,3,33.33)); //0
//		assertEquals(-4,g.addEdge(1,1,11.11)); //-4
//		assertEquals(-4,g.addEdge(1,2,12.12)); //-4
//		assertEquals(-4,g.addEdge(1,3,13.13)); //-4
//		assertEquals(-4,g.addEdge(2,1,21.21)); //-4
//		assertEquals(-4,g.addEdge(2,2,22.22)); //-4
//		assertEquals(-4,g.addEdge(2,3,23.23)); //-4
//		assertEquals(-4,g.addEdge(3,1,31.31)); //-4
//		assertEquals(-4,g.addEdge(3,2,32.32)); //-4
//		assertEquals(-4,g.addEdge(3,3,33.33)); //-4
//		g.getEdge(1,1,11.11); //11.11
//		g.getEdge(1,2,12.12); //12.12
//		g.getEdge(1,3,13.13); //13.129999999999999
//		g.getEdge(2,1,21.21); //21.21
//		g.getEdge(2,2,22.22); //22.22
//		g.getEdge(2,3,23.23); //23.23
//		g.getEdge(3,1,31.31); //31.310000000000002
//		g.getEdge(3,2,32.32); //32.32
//		g.getEdge(3,3,33.33); //33.33
//	}
	
	@Test
	public void basicEvolutionTest() {
		1 g.existsNode(1): //false
		2 g.existsNode(2): false
		3 g.addNode(1): 0
		4 g.addNode(2): 0
		5 g.existsNode(1): true
		6 g.existsNode(2): true
		7 g.addNode(1): -1
		8 g.addNode(2): -1
		9 g.addEdge(1,2, 1.2): 0
		10 g.addEdge(2,1, 2.1): 0
		11 g.addEdge(1,1, 1.1): 0
		12 g.getEdge(1,2): 1.2
		13 g.getEdge(2,1): 2.1
		14 g.getEdge(1,1): 1.1
		15 g.getEdge(2,3): -2.0
		16 g.existsEdge(1,2): true
		17 g.existsEdge(2,1): true
		18 g.existsEdge(1,1): true
		19 g.existsEdge(2,2): false
		20 g.removeEdge(2,2): -4
		21 g.addEdge(2,2,2.2): 0
		22 g.getEdge(2,2): 2.2
		23 g.existsEdge(2,2): true
		24 g.removeEdge(2,2): 0
		25 g.removeNode(3): -1
		26 g.addNode(3): 0
		27 g.addNode(4): -2
		28 g.getEdge(1, 3): -4.0
		29 g.addEdge(1,3, 1.3): 0
		30 g.existsEdge(1, 3): //true----------------(false)
		31 g.getEdge(1, 3): 1.3
		32 g.getEdge(1, 4): -2.0
		33 g.getEdge(5,1): -1.0
		34 g.getEdge(5,4): -3.0
		35 g.removeNode(3): 0
		36 g.removeNode(3): //0----------------(-1)
		37 g.existsEdge(1, 3): true
		38 g.getEdge(1, 3): //1.3-------------------(-2.0)
		39 g.removeNode(2): 0
		40 g.removeNode(2): //0---------------------(-1)
		41 g.existsEdge(1, 1): true
		42 g.removeNode(1): 0
		43 g.existsNode(1): //true----------------------(false)
		44 g.existsNode(2): true
		45 g.existsNode(3): true
		46 g.existsNode(4): false
		47 g.addNode(4): 0
		48 g.existsNode(4): true
		49 g.addEdge(4,4, 4.4): 0
		50 g.existsEdge(4, 4): //true
		51 g.getEdge(4, 4): 4.4
		52 g.removeNode(4): 0
		53 g.removeNode(4): 0
		54 g.existsEdge(4, 4): true
		55 g.addNode(7): 0
		56 g.removeNode(2): 0
		57 g.removeNode(3): 0
		58 g.removeNode(4): -1
		59 g.existsEdge(7, 7): false
		60 g.addEdge(7,7, 7.7): 0
		61 g.addEdge(7,7, 17.17): -4
		62 g.getEdge(7, 7): 7.7
		63 g.addNode(8): 0
		64 g.addNode(9): 0
		65 g.existsEdge(7, 8): false
		66 g.existsEdge(8, 7): false
		67 g.existsEdge(8, 8): false
		68 g.existsEdge(8, 9): true
		69 g.existsEdge(9, 8): true
		70 g.existsEdge(9, 9): false
		71 g.addEdge(7,8, 7.8): 0
		72 g.addEdge(8,7, 8.7): 0
		73 g.addEdge(8,8, 8.8): 0
		74 g.addEdge(8,9, 8.9): -4
		75 g.addEdge(9,8, 9.8): -4
		76 g.addEdge(9,9, 9.9): 0
		77 g.addEdge(7,9, 7.9): 0
		78 g.addEdge(9,7, 9.7): 0
		79 g.getEdge(7, 7) --> -4.0
		80 g.getEdge(7, 8) --> 7.8
		81 g.getEdge(7, 9) --> 7.9
		82 g.getEdge(8, 7) --> 8.7
		83 g.getEdge(8, 8) --> 8.8
		84 g.getEdge(8, 9) --> 1.2
		85 g.getEdge(9, 7) --> 9.7
		86 g.getEdge(9, 8) --> 2.1
		87 g.getEdge(9, 9) --> 9.9
		88 g.removeNode(7): 0
		89 g.removeNode(7): 0
		90 g.getEdge(7, 7) --> -4.0
		91 g.getEdge(7, 8) --> 7.8
		92 g.getEdge(7, 9) --> 7.9
		93 g.getEdge(8, 7) --> 8.7
		94 g.getEdge(8, 8) --> 8.8
		95 g.getEdge(8, 9) --> 1.2
		96 g.getEdge(9, 7) --> 9.7
		97 g.getEdge(9, 8) --> 2.1
		98 g.getEdge(9, 9) --> 9.9
		99 g.removeNode(null): -1
		100 g.addNode(null): -4
		101 g.addNode(10): 0
		102 g.getEdge(8, 10) --> 8.7
		103 g.getEdge(10, 9) --> 7.9
		104 g.addNode(null): -6
		105 g.addEdge(8,8,-8.8): -12
		106 g.addEdge(7,8,-7.8): -9
		107 g.addEdge(8,7,-8.7): -10
		108 g.addEdge(7,7,-7.7): -11
		109 g.addEdge(null,8,0.8): -1
		110 g.addEdge(8,null,0.8): -2
		111 g.addEdge(null,null,0.8): -3
		112 g.getEdge(null,10): -1.0
		113 g.getEdge(10,null): -2.0
		114 g.getEdge(null,null): -3.0
		115 g.existsNode(null): false
		116 g.existsEdge(null,null): false
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-10-06 00:59:55.341
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-10-06 00:59:55.343
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-10-06 00:59:57.397
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package p2Grafos;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import org.junit.Test;

/**
 * Titulo: Clase GraphTests
 * 
 * @author UO281847
 * @version 24/09/2021
 */
public class GraphTests {
	private Graph<Integer> g;
///*
// * Pruebas del método addNode:	
// */
//	/**
//	 * Test del método addNode sin errores
//	 */
//	@Test
//	public void testAddNodeFirst() {
//		Graph<Integer> g = new Graph<Integer>(3);
//		int node = 12;
//		assertEquals(0, g.addNode(node));
//		System.out.println(g.toString());	
//	}	
//	/**
//	 * Test del método addNode con nodo no valido
//	 */
//	@Test
//	public void testAddNodeNotValid() {
//		Graph<Integer> g = new Graph<Integer>(3);
//		int node = 1;
//		int node2 = 18;
//		assertEquals(0, g.addNode(node));
//		assertEquals(0, g.addNode(node2));
//		assertEquals(-5, g.addNode(null));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addNode cuando ya esta lleno
//	 */
//	@Test
//	public void testAddNodeFull() {
//		Graph<Integer> g = new Graph<Integer>(3);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 39;
//		int node4= 2;
//		assertEquals(0, g.addNode(node));
//		assertEquals(0, g.addNode(node2));
//		assertEquals(0, g.addNode(node3));
//		assertEquals(-2, g.addNode(node4));		
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addNode cuando ya existe
//	 */
//	@Test
//	public void testAddNodeAlreadyExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 39;
//		int node4 = 19;
//		int node5= 19;
//		assertEquals(0, g.addNode(node));
//		assertEquals(0, g.addNode(node2));
//		assertEquals(0, g.addNode(node3));
//		assertEquals(0, g.addNode(node4));
//		assertEquals(-1, g.addNode(node5));	
//		System.out.println(g.toString());	
//	}
//	
///*
// * Pruebas del método getNode:
// */
//	/**
//	 * Test del método getNode que devuelve la posición
//	 */
//	@Test
//	public void testGetNodeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		g.addNode(node);
//		assertEquals(0, g.getNode(node));
//	}
//	/**
//	 * Test del método getNode que devuelve la posición ya añadido
//	 */
//	@Test
//	public void testGetNodeVarious() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 23;
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(1, g.getNode(node2));
//	}
//	/**
//	 * Test del método getNode que devuelve -1
//	 */
//	@Test
//	public void testGetNodeDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 23;
//		g.addNode(node);
//		assertEquals(-1, g.getNode(node2));
//	}
//
///**
// * Pruebas del método existsNode:
// */
//	/**
//	 * Test del método existsNode que devuelve true
//	 */
//	@Test
//	public void testExistsNodeOne() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		g.addNode(node);
//		assertTrue(g.existsNode(node));
//	}
//	/**
//	 * Test del método existsNode que devuelve true
//	 */
//	@Test
//	public void testExistsNodeVarious() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 23;
//		g.addNode(node);
//		g.addNode(node2);
//		assertTrue(g.existsNode(node2));
//	}
//	/**
//	 * Test del método existsNode que devuelve true
//	 */
//	@Test
//	public void testExistsNodeFalse() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 23;
//		g.addNode(node);
//		assertFalse(g.existsNode(node2));
//	}
//
///*
// * Pruebas del método addEdge:
// */
//	/**
//	 * Test del método addEdge que no tiene errores
//	 */
//	@Test
//	public void testAddEdgeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;		
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(0, g.addEdge(node, node2, 12));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde no existe el nodo origen
//	 */
//	@Test
//	public void testAddEdgeSourceDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 23;
//		g.addNode(node);
//		g.addNode(node2);		
//		assertEquals(-1, g.addEdge(node3, node2, 12));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde no existe el nodo destino
//	 */
//	@Test
//	public void testAddEdgeTargetDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 23;
//		g.addNode(node);
//		g.addNode(node2);		
//		assertEquals(-2, g.addEdge(node, node3, 12));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde ya existe la arista
//	 */
//	@Test
//	public void testAddEdgeEdgeExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 12);
//		assertEquals(-4, g.addEdge(node, node2, 12));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde el peso no es valido
//	 */
//	@Test
//	public void testAddEdgeEdgeWightError() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(-8, g.addEdge(node, node2, -4));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde no existen los nodos 
//	 */
//	@Test
//	public void testAddEdgeSourceTargetError() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 12;
//		int node4 = 56;
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(-3, g.addEdge(node3, node4, 4));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde ya existe la arista y el peso no es valido
//	 */
//	@Test
//	public void testAddEdgeEdgeExistsEdgeWeightError() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-12, g.addEdge(node, node2, -4));
//		System.out.println(g.toString());	
//	}
//	
///*
// * Pruebas del método getEdge:
// */
//	/**
//	 * Test del método getEdge que no tiene errores
//	 */
//	@Test
//	public void testGetEdgeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(4, g.getEdge(node, node2),0.1);
//	}
//	/**
//	 * Test del método getEdge donde no existe el nodo origen
//	 */
//	@Test
//	public void testGetEdgeSourceDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 4;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-1, g.getEdge(node3, node2),0.1);
//	}
//	/**
//	 * Test del método getEdge donde no existe el nodo destino
//	 */
//	@Test
//	public void testGetEdgeTargetDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 4;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-2, g.getEdge(node, node3),0.1);
//	}
//	/**
//	 * Test del método getEdge donde existen los nodos y no la arista
//	 */
//	@Test
//	public void testGetEdgeEdgeDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(-4, g.getEdge(node, node2),0.1);
//	}
//	/**
//	 * Test del método getEdge donde no existen los nodos
//	 */
//	@Test
//	public void testGetEdgeBothDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 4;
//		int node4 = 6;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-3, g.getEdge(node3, node4),0.1);
//	}
//	
///*
// * Pruebas del método existsEdge:
// */
//	/**
//	 * Test del método existsEdge que no tiene errores
//	 */
//	@Test
//	public void testExistsEdgeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertTrue(g.existsEdge(node, node2));
//	}
//	/**
//	 * Test del método existsEdge donde no existe el nodo origen
//	 */
//	@Test
//	public void testExistsEdgeSourceDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3= 8;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertFalse(g.existsEdge(node3, node2));
//	}
//	/**
//	 * Test del método existsEdge donde no existe el nodo destino
//	 */
//	@Test
//	public void testExistsEdgeTargetDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3= 8;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertFalse(g.existsEdge(node, node3));
//	}
//	/**
//	 * Test del método existsEdge donde no existen los nodos
//	 */
//	@Test
//	public void testExistsEdgeBothDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		int node4 = 12;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertFalse(g.existsEdge(node3, node4));
//	}
//	
///*
// * Pruebas del método removeEdge:
// */
//	/**
//	 * Test del método removeEdge que no tiene errores 
//	 */
//	@Test
//	public void testRemoveEdgeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		int node4 = 12;
//		g.addNode(node);
//		g.addNode(node2); 
//		g.addNode(node3);
//		g.addNode(node4);
//		g.addEdge(node, node2, 4);
//		g.addEdge(node3, node4, 12);
//		assertEquals(0, g.removeEdge(node3, node4));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeEdge donde no existe el nodo origen
//	 */
//	@Test
//	public void testRemoveEdgeSourceDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		g.addNode(node);
//		g.addNode(node2); 
//		g.addEdge(node, node2, 4);
//		assertEquals(-1, g.removeEdge(node3, node2));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeEdge donde no existe el nodo destino
//	 */
//	@Test
//	public void testRemoveEdgeTargetDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		g.addNode(node);
//		g.addNode(node2); 
//		g.addEdge(node, node2, 4);
//		assertEquals(-2, g.removeEdge(node2, node3));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeEdge donde existen los nodos y no la arista
//	 */
//	@Test
//	public void testRemoveEdgeEdgeDontExistsNodesExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2); 
//		g.addEdge(node, node2, 4);
//		assertEquals(-4, g.removeEdge(node2, node));
//		System.out.println(g.toString());
//	}	
//	/**
//	 * Test del método removeEdge donde no existen los nodos
//	 */
//	@Test
//	public void testRemoveEdgeNodesDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		int node4 = 12;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-3, g.removeEdge(node3, node4));
//		System.out.println(g.toString());
//	}
///*
// * Pruebas del método removeNode:
// */
//	/**
//	 * Test del método removeNode que no tiene errores
//	 */
//	@Test
//	public void testRemoveNodeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;		
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(0, g.removeNode(node));
//		assertFalse(g.existsNode(node));
//		assertFalse(g.existsEdge(node, node2));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeNode que no tiene errores y borra toda la matriz
//	 */
//	@Test
//	public void testRemoveNodeVarious() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		int node4 = 12;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		g.addEdge(node, node, 12);
//		g.addEdge(node3, node, 7);
//		g.addEdge(node, node4, 15);
//		g.addEdge(node, node3, 9);
//		assertEquals(0, g.removeNode(node));
//		assertFalse(g.existsNode(node));
//		assertFalse(g.existsEdge(node, node2));
//		assertFalse(g.existsEdge(node, node));
//		assertFalse(g.existsEdge(node3, node));
//		assertFalse(g.existsEdge(node, node4));
//		assertFalse(g.existsEdge(node, node3));
//		System.out.println(g.toString());
//	}	
//	/**
//	 * Test del método removeNode donde el nodo no es valido
//	 */
//	@Test
//	public void testRemoveNodeNotValid() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;		
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-1, g.removeNode(null));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeNode donde el nodo no existe
//	 */
//	@Test
//	public void testRemoveNodeDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 12;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-1, g.removeNode(node3));
//		System.out.println(g.toString());
//	}
	/**
	 * Pruebas basicas de nodos
	 */
//	@Test
//	public void basicNodeTest() {
//		g=new Graph<Integer>(3); 
//	    assertFalse(g.existsNode(1)); //false
//	    assertFalse(g.existsNode(2)); //false
//	    assertEquals(0,g.addNode(1)); //0
//		assertEquals(0,g.addNode(2)); //0
//		assertTrue(g.existsNode(1)); //true
//		assertTrue(g.existsNode(2)); //true
//		assertEquals(-1,g.addNode(1)); //-1
//		assertEquals(-1,g.addNode(2)); //-1
//		assertEquals(0,g.addNode(3)); //0
//		assertEquals(-2,g.addNode(4)); //-2
//		assertFalse(g.existsNode(4)); //false
//		assertFalse(g.existsNode(5)); //false
//	}
	
//	@Test
//	public void basicEdgeTest() {
//		g=new Graph<Integer>(3); 
//		assertFalse(g.existsEdge(1,2)); //false
//		assertEquals(-3.0,g.getEdge(1,2),0.1); //-3.0
//		assertEquals(0,g.addNode(1)); //0
//		assertFalse(g.existsEdge(1,2)); //false
//		assertEquals(-2.0,g.getEdge(1,2),0.1); //-2.0
//		assertFalse(g.existsEdge(2,1)); //false
//		assertEquals(-1.0,g.getEdge(2,1),0.1); //-1.0
//		assertEquals(0,g.addNode(2)); //0
//		assertFalse(g.existsEdge(1,2)); //false
//		assertEquals(-4.0,g.getEdge(1,2),0.1); //-4.0
//		assertEquals(0,g.addEdge(1,2,12.12)); //0
//		assertEquals(-4,g.addEdge(1,2,12.1212)); //-4
//		assertEquals(0,g.addNode(3)); //0
//		assertFalse(g.existsEdge(1,3)); //false
//		assertFalse(g.existsEdge(3,2)); //false
//		assertEquals(-4.0,g.getEdge(1,3),0.1); //-4.0
//		assertEquals(-4.0,g.getEdge(3,2),0.1); //-4.0
//		assertEquals(0,g.addEdge(1,1,11.11)); //0
//		assertEquals(-4,g.addEdge(1,2,12.12)); //-4
//		assertEquals(0,g.addEdge(1,3,13.13)); //0
//		assertEquals(0,g.addEdge(2,1,21.21)); //0
//		assertEquals(0,g.addEdge(2,2,22.22)); //0
//		assertEquals(0,g.addEdge(2,3,23.23)); //0
//		assertEquals(0,g.addEdge(3,1,31.31)); //0
//		assertEquals(0,g.addEdge(3,2,32.32)); //0
//		assertEquals(0,g.addEdge(3,3,33.33)); //0
//		assertEquals(-4,g.addEdge(1,1,11.11)); //-4
//		assertEquals(-4,g.addEdge(1,2,12.12)); //-4
//		assertEquals(-4,g.addEdge(1,3,13.13)); //-4
//		assertEquals(-4,g.addEdge(2,1,21.21)); //-4
//		assertEquals(-4,g.addEdge(2,2,22.22)); //-4
//		assertEquals(-4,g.addEdge(2,3,23.23)); //-4
//		assertEquals(-4,g.addEdge(3,1,31.31)); //-4
//		assertEquals(-4,g.addEdge(3,2,32.32)); //-4
//		assertEquals(-4,g.addEdge(3,3,33.33)); //-4
//		g.getEdge(1,1,11.11); //11.11
//		g.getEdge(1,2,12.12); //12.12
//		g.getEdge(1,3,13.13); //13.129999999999999
//		g.getEdge(2,1,21.21); //21.21
//		g.getEdge(2,2,22.22); //22.22
//		g.getEdge(2,3,23.23); //23.23
//		g.getEdge(3,1,31.31); //31.310000000000002
//		g.getEdge(3,2,32.32); //32.32
//		g.getEdge(3,3,33.33); //33.33
//	}
	
	@Test
	public void basicEvolutionTest() {
		1 g.existsNode(1): //false
		2 g.existsNode(2): false
		3 g.addNode(1): 0
		4 g.addNode(2): 0
		5 g.existsNode(1): true
		6 g.existsNode(2): true
		7 g.addNode(1): -1
		8 g.addNode(2): -1
		9 g.addEdge(1,2, 1.2): 0
		10 g.addEdge(2,1, 2.1): 0
		11 g.addEdge(1,1, 1.1): 0
		12 g.getEdge(1,2): 1.2
		13 g.getEdge(2,1): 2.1
		14 g.getEdge(1,1): 1.1
		15 g.getEdge(2,3): -2.0
		16 g.existsEdge(1,2): true
		17 g.existsEdge(2,1): true
		18 g.existsEdge(1,1): true
		19 g.existsEdge(2,2): false
		20 g.removeEdge(2,2): -4
		21 g.addEdge(2,2,2.2): 0
		22 g.getEdge(2,2): 2.2
		23 g.existsEdge(2,2): true
		24 g.removeEdge(2,2): 0
		25 g.removeNode(3): -1
		26 g.addNode(3): 0
		27 g.addNode(4): -2
		28 g.getEdge(1, 3): -4.0
		29 g.addEdge(1,3, 1.3): 0
		30 g.existsEdge(1, 3): //true----------------(false)
		31 g.getEdge(1, 3): 1.3
		32 g.getEdge(1, 4): -2.0
		33 g.getEdge(5,1): -1.0
		34 g.getEdge(5,4): -3.0
		35 g.removeNode(3): 0
		36 g.removeNode(3): //0----------------(-1)
		37 g.existsEdge(1, 3): true
		38 g.getEdge(1, 3): //1.3-------------------(-2.0)
		39 g.removeNode(2): 0
		40 g.removeNode(2): //0---------------------(-1)
		41 g.existsEdge(1, 1): true
		42 g.removeNode(1): 0
		43 g.existsNode(1): //true----------------------(false)
		44 g.existsNode(2): true
		45 g.existsNode(3): true
		46 g.existsNode(4): false
		47 g.addNode(4): 0
		48 g.existsNode(4): true
		49 g.addEdge(4,4, 4.4): 0
		50 g.existsEdge(4, 4): //true--------------------
		51 g.getEdge(4, 4): 4.4
		52 g.removeNode(4): 0
		53 g.removeNode(4): 0
		54 g.existsEdge(4, 4): true
		55 g.addNode(7): 0
		56 g.removeNode(2): 0
		57 g.removeNode(3): 0
		58 g.removeNode(4): -1
		59 g.existsEdge(7, 7): false
		60 g.addEdge(7,7, 7.7): 0
		61 g.addEdge(7,7, 17.17): -4
		62 g.getEdge(7, 7): 7.7
		63 g.addNode(8): 0
		64 g.addNode(9): 0
		65 g.existsEdge(7, 8): false
		66 g.existsEdge(8, 7): false
		67 g.existsEdge(8, 8): false
		68 g.existsEdge(8, 9): true
		69 g.existsEdge(9, 8): true
		70 g.existsEdge(9, 9): false
		71 g.addEdge(7,8, 7.8): 0
		72 g.addEdge(8,7, 8.7): 0
		73 g.addEdge(8,8, 8.8): 0
		74 g.addEdge(8,9, 8.9): -4
		75 g.addEdge(9,8, 9.8): -4
		76 g.addEdge(9,9, 9.9): 0
		77 g.addEdge(7,9, 7.9): 0
		78 g.addEdge(9,7, 9.7): 0
		79 g.getEdge(7, 7) --> -4.0
		80 g.getEdge(7, 8) --> 7.8
		81 g.getEdge(7, 9) --> 7.9
		82 g.getEdge(8, 7) --> 8.7
		83 g.getEdge(8, 8) --> 8.8
		84 g.getEdge(8, 9) --> 1.2
		85 g.getEdge(9, 7) --> 9.7
		86 g.getEdge(9, 8) --> 2.1
		87 g.getEdge(9, 9) --> 9.9
		88 g.removeNode(7): 0
		89 g.removeNode(7): 0
		90 g.getEdge(7, 7) --> -4.0
		91 g.getEdge(7, 8) --> 7.8
		92 g.getEdge(7, 9) --> 7.9
		93 g.getEdge(8, 7) --> 8.7
		94 g.getEdge(8, 8) --> 8.8
		95 g.getEdge(8, 9) --> 1.2
		96 g.getEdge(9, 7) --> 9.7
		97 g.getEdge(9, 8) --> 2.1
		98 g.getEdge(9, 9) --> 9.9
		99 g.removeNode(null): -1
		100 g.addNode(null): -4
		101 g.addNode(10): 0
		102 g.getEdge(8, 10) --> 8.7
		103 g.getEdge(10, 9) --> 7.9
		104 g.addNode(null): -6
		105 g.addEdge(8,8,-8.8): -12
		106 g.addEdge(7,8,-7.8): -9
		107 g.addEdge(8,7,-8.7): -10
		108 g.addEdge(7,7,-7.7): -11
		109 g.addEdge(null,8,0.8): -1
		110 g.addEdge(8,null,0.8): -2
		111 g.addEdge(null,null,0.8): -3
		112 g.getEdge(null,10): -1.0
		113 g.getEdge(10,null): -2.0
		114 g.getEdge(null,null): -3.0
		115 g.existsNode(null): false
		116 g.existsEdge(null,null): false
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-10-06 00:59:57.399
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-10-06 00:59:57.400
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-10-06 00:59:57.439
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package p2Grafos;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import org.junit.Test;

/**
 * Titulo: Clase GraphTests
 * 
 * @author UO281847
 * @version 24/09/2021
 */
public class GraphTests {
	private Graph<Integer> g;
///*
// * Pruebas del método addNode:	
// */
//	/**
//	 * Test del método addNode sin errores
//	 */
//	@Test
//	public void testAddNodeFirst() {
//		Graph<Integer> g = new Graph<Integer>(3);
//		int node = 12;
//		assertEquals(0, g.addNode(node));
//		System.out.println(g.toString());	
//	}	
//	/**
//	 * Test del método addNode con nodo no valido
//	 */
//	@Test
//	public void testAddNodeNotValid() {
//		Graph<Integer> g = new Graph<Integer>(3);
//		int node = 1;
//		int node2 = 18;
//		assertEquals(0, g.addNode(node));
//		assertEquals(0, g.addNode(node2));
//		assertEquals(-5, g.addNode(null));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addNode cuando ya esta lleno
//	 */
//	@Test
//	public void testAddNodeFull() {
//		Graph<Integer> g = new Graph<Integer>(3);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 39;
//		int node4= 2;
//		assertEquals(0, g.addNode(node));
//		assertEquals(0, g.addNode(node2));
//		assertEquals(0, g.addNode(node3));
//		assertEquals(-2, g.addNode(node4));		
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addNode cuando ya existe
//	 */
//	@Test
//	public void testAddNodeAlreadyExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 39;
//		int node4 = 19;
//		int node5= 19;
//		assertEquals(0, g.addNode(node));
//		assertEquals(0, g.addNode(node2));
//		assertEquals(0, g.addNode(node3));
//		assertEquals(0, g.addNode(node4));
//		assertEquals(-1, g.addNode(node5));	
//		System.out.println(g.toString());	
//	}
//	
///*
// * Pruebas del método getNode:
// */
//	/**
//	 * Test del método getNode que devuelve la posición
//	 */
//	@Test
//	public void testGetNodeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		g.addNode(node);
//		assertEquals(0, g.getNode(node));
//	}
//	/**
//	 * Test del método getNode que devuelve la posición ya añadido
//	 */
//	@Test
//	public void testGetNodeVarious() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 23;
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(1, g.getNode(node2));
//	}
//	/**
//	 * Test del método getNode que devuelve -1
//	 */
//	@Test
//	public void testGetNodeDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 23;
//		g.addNode(node);
//		assertEquals(-1, g.getNode(node2));
//	}
//
///**
// * Pruebas del método existsNode:
// */
//	/**
//	 * Test del método existsNode que devuelve true
//	 */
//	@Test
//	public void testExistsNodeOne() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		g.addNode(node);
//		assertTrue(g.existsNode(node));
//	}
//	/**
//	 * Test del método existsNode que devuelve true
//	 */
//	@Test
//	public void testExistsNodeVarious() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 23;
//		g.addNode(node);
//		g.addNode(node2);
//		assertTrue(g.existsNode(node2));
//	}
//	/**
//	 * Test del método existsNode que devuelve true
//	 */
//	@Test
//	public void testExistsNodeFalse() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 23;
//		g.addNode(node);
//		assertFalse(g.existsNode(node2));
//	}
//
///*
// * Pruebas del método addEdge:
// */
//	/**
//	 * Test del método addEdge que no tiene errores
//	 */
//	@Test
//	public void testAddEdgeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;		
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(0, g.addEdge(node, node2, 12));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde no existe el nodo origen
//	 */
//	@Test
//	public void testAddEdgeSourceDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 23;
//		g.addNode(node);
//		g.addNode(node2);		
//		assertEquals(-1, g.addEdge(node3, node2, 12));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde no existe el nodo destino
//	 */
//	@Test
//	public void testAddEdgeTargetDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 23;
//		g.addNode(node);
//		g.addNode(node2);		
//		assertEquals(-2, g.addEdge(node, node3, 12));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde ya existe la arista
//	 */
//	@Test
//	public void testAddEdgeEdgeExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 12);
//		assertEquals(-4, g.addEdge(node, node2, 12));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde el peso no es valido
//	 */
//	@Test
//	public void testAddEdgeEdgeWightError() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(-8, g.addEdge(node, node2, -4));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde no existen los nodos 
//	 */
//	@Test
//	public void testAddEdgeSourceTargetError() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 12;
//		int node4 = 56;
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(-3, g.addEdge(node3, node4, 4));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde ya existe la arista y el peso no es valido
//	 */
//	@Test
//	public void testAddEdgeEdgeExistsEdgeWeightError() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-12, g.addEdge(node, node2, -4));
//		System.out.println(g.toString());	
//	}
//	
///*
// * Pruebas del método getEdge:
// */
//	/**
//	 * Test del método getEdge que no tiene errores
//	 */
//	@Test
//	public void testGetEdgeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(4, g.getEdge(node, node2),0.1);
//	}
//	/**
//	 * Test del método getEdge donde no existe el nodo origen
//	 */
//	@Test
//	public void testGetEdgeSourceDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 4;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-1, g.getEdge(node3, node2),0.1);
//	}
//	/**
//	 * Test del método getEdge donde no existe el nodo destino
//	 */
//	@Test
//	public void testGetEdgeTargetDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 4;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-2, g.getEdge(node, node3),0.1);
//	}
//	/**
//	 * Test del método getEdge donde existen los nodos y no la arista
//	 */
//	@Test
//	public void testGetEdgeEdgeDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(-4, g.getEdge(node, node2),0.1);
//	}
//	/**
//	 * Test del método getEdge donde no existen los nodos
//	 */
//	@Test
//	public void testGetEdgeBothDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 4;
//		int node4 = 6;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-3, g.getEdge(node3, node4),0.1);
//	}
//	
///*
// * Pruebas del método existsEdge:
// */
//	/**
//	 * Test del método existsEdge que no tiene errores
//	 */
//	@Test
//	public void testExistsEdgeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertTrue(g.existsEdge(node, node2));
//	}
//	/**
//	 * Test del método existsEdge donde no existe el nodo origen
//	 */
//	@Test
//	public void testExistsEdgeSourceDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3= 8;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertFalse(g.existsEdge(node3, node2));
//	}
//	/**
//	 * Test del método existsEdge donde no existe el nodo destino
//	 */
//	@Test
//	public void testExistsEdgeTargetDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3= 8;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertFalse(g.existsEdge(node, node3));
//	}
//	/**
//	 * Test del método existsEdge donde no existen los nodos
//	 */
//	@Test
//	public void testExistsEdgeBothDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		int node4 = 12;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertFalse(g.existsEdge(node3, node4));
//	}
//	
///*
// * Pruebas del método removeEdge:
// */
//	/**
//	 * Test del método removeEdge que no tiene errores 
//	 */
//	@Test
//	public void testRemoveEdgeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		int node4 = 12;
//		g.addNode(node);
//		g.addNode(node2); 
//		g.addNode(node3);
//		g.addNode(node4);
//		g.addEdge(node, node2, 4);
//		g.addEdge(node3, node4, 12);
//		assertEquals(0, g.removeEdge(node3, node4));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeEdge donde no existe el nodo origen
//	 */
//	@Test
//	public void testRemoveEdgeSourceDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		g.addNode(node);
//		g.addNode(node2); 
//		g.addEdge(node, node2, 4);
//		assertEquals(-1, g.removeEdge(node3, node2));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeEdge donde no existe el nodo destino
//	 */
//	@Test
//	public void testRemoveEdgeTargetDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		g.addNode(node);
//		g.addNode(node2); 
//		g.addEdge(node, node2, 4);
//		assertEquals(-2, g.removeEdge(node2, node3));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeEdge donde existen los nodos y no la arista
//	 */
//	@Test
//	public void testRemoveEdgeEdgeDontExistsNodesExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2); 
//		g.addEdge(node, node2, 4);
//		assertEquals(-4, g.removeEdge(node2, node));
//		System.out.println(g.toString());
//	}	
//	/**
//	 * Test del método removeEdge donde no existen los nodos
//	 */
//	@Test
//	public void testRemoveEdgeNodesDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		int node4 = 12;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-3, g.removeEdge(node3, node4));
//		System.out.println(g.toString());
//	}
///*
// * Pruebas del método removeNode:
// */
//	/**
//	 * Test del método removeNode que no tiene errores
//	 */
//	@Test
//	public void testRemoveNodeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;		
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(0, g.removeNode(node));
//		assertFalse(g.existsNode(node));
//		assertFalse(g.existsEdge(node, node2));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeNode que no tiene errores y borra toda la matriz
//	 */
//	@Test
//	public void testRemoveNodeVarious() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		int node4 = 12;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		g.addEdge(node, node, 12);
//		g.addEdge(node3, node, 7);
//		g.addEdge(node, node4, 15);
//		g.addEdge(node, node3, 9);
//		assertEquals(0, g.removeNode(node));
//		assertFalse(g.existsNode(node));
//		assertFalse(g.existsEdge(node, node2));
//		assertFalse(g.existsEdge(node, node));
//		assertFalse(g.existsEdge(node3, node));
//		assertFalse(g.existsEdge(node, node4));
//		assertFalse(g.existsEdge(node, node3));
//		System.out.println(g.toString());
//	}	
//	/**
//	 * Test del método removeNode donde el nodo no es valido
//	 */
//	@Test
//	public void testRemoveNodeNotValid() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;		
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-1, g.removeNode(null));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeNode donde el nodo no existe
//	 */
//	@Test
//	public void testRemoveNodeDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 12;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-1, g.removeNode(node3));
//		System.out.println(g.toString());
//	}
	/**
	 * Pruebas basicas de nodos
	 */
//	@Test
//	public void basicNodeTest() {
//		g=new Graph<Integer>(3); 
//	    assertFalse(g.existsNode(1)); //false
//	    assertFalse(g.existsNode(2)); //false
//	    assertEquals(0,g.addNode(1)); //0
//		assertEquals(0,g.addNode(2)); //0
//		assertTrue(g.existsNode(1)); //true
//		assertTrue(g.existsNode(2)); //true
//		assertEquals(-1,g.addNode(1)); //-1
//		assertEquals(-1,g.addNode(2)); //-1
//		assertEquals(0,g.addNode(3)); //0
//		assertEquals(-2,g.addNode(4)); //-2
//		assertFalse(g.existsNode(4)); //false
//		assertFalse(g.existsNode(5)); //false
//	}
	
//	@Test
//	public void basicEdgeTest() {
//		g=new Graph<Integer>(3); 
//		assertFalse(g.existsEdge(1,2)); //false
//		assertEquals(-3.0,g.getEdge(1,2),0.1); //-3.0
//		assertEquals(0,g.addNode(1)); //0
//		assertFalse(g.existsEdge(1,2)); //false
//		assertEquals(-2.0,g.getEdge(1,2),0.1); //-2.0
//		assertFalse(g.existsEdge(2,1)); //false
//		assertEquals(-1.0,g.getEdge(2,1),0.1); //-1.0
//		assertEquals(0,g.addNode(2)); //0
//		assertFalse(g.existsEdge(1,2)); //false
//		assertEquals(-4.0,g.getEdge(1,2),0.1); //-4.0
//		assertEquals(0,g.addEdge(1,2,12.12)); //0
//		assertEquals(-4,g.addEdge(1,2,12.1212)); //-4
//		assertEquals(0,g.addNode(3)); //0
//		assertFalse(g.existsEdge(1,3)); //false
//		assertFalse(g.existsEdge(3,2)); //false
//		assertEquals(-4.0,g.getEdge(1,3),0.1); //-4.0
//		assertEquals(-4.0,g.getEdge(3,2),0.1); //-4.0
//		assertEquals(0,g.addEdge(1,1,11.11)); //0
//		assertEquals(-4,g.addEdge(1,2,12.12)); //-4
//		assertEquals(0,g.addEdge(1,3,13.13)); //0
//		assertEquals(0,g.addEdge(2,1,21.21)); //0
//		assertEquals(0,g.addEdge(2,2,22.22)); //0
//		assertEquals(0,g.addEdge(2,3,23.23)); //0
//		assertEquals(0,g.addEdge(3,1,31.31)); //0
//		assertEquals(0,g.addEdge(3,2,32.32)); //0
//		assertEquals(0,g.addEdge(3,3,33.33)); //0
//		assertEquals(-4,g.addEdge(1,1,11.11)); //-4
//		assertEquals(-4,g.addEdge(1,2,12.12)); //-4
//		assertEquals(-4,g.addEdge(1,3,13.13)); //-4
//		assertEquals(-4,g.addEdge(2,1,21.21)); //-4
//		assertEquals(-4,g.addEdge(2,2,22.22)); //-4
//		assertEquals(-4,g.addEdge(2,3,23.23)); //-4
//		assertEquals(-4,g.addEdge(3,1,31.31)); //-4
//		assertEquals(-4,g.addEdge(3,2,32.32)); //-4
//		assertEquals(-4,g.addEdge(3,3,33.33)); //-4
//		g.getEdge(1,1,11.11); //11.11
//		g.getEdge(1,2,12.12); //12.12
//		g.getEdge(1,3,13.13); //13.129999999999999
//		g.getEdge(2,1,21.21); //21.21
//		g.getEdge(2,2,22.22); //22.22
//		g.getEdge(2,3,23.23); //23.23
//		g.getEdge(3,1,31.31); //31.310000000000002
//		g.getEdge(3,2,32.32); //32.32
//		g.getEdge(3,3,33.33); //33.33
//	}
	
	@Test
	public void basicEvolutionTest() {
		1 g.existsNode(1): //false
		2 g.existsNode(2): false
		3 g.addNode(1): 0
		4 g.addNode(2): 0
		5 g.existsNode(1): true
		6 g.existsNode(2): true
		7 g.addNode(1): -1
		8 g.addNode(2): -1
		9 g.addEdge(1,2, 1.2): 0
		10 g.addEdge(2,1, 2.1): 0
		11 g.addEdge(1,1, 1.1): 0
		12 g.getEdge(1,2): 1.2
		13 g.getEdge(2,1): 2.1
		14 g.getEdge(1,1): 1.1
		15 g.getEdge(2,3): -2.0
		16 g.existsEdge(1,2): true
		17 g.existsEdge(2,1): true
		18 g.existsEdge(1,1): true
		19 g.existsEdge(2,2): false
		20 g.removeEdge(2,2): -4
		21 g.addEdge(2,2,2.2): 0
		22 g.getEdge(2,2): 2.2
		23 g.existsEdge(2,2): true
		24 g.removeEdge(2,2): 0
		25 g.removeNode(3): -1
		26 g.addNode(3): 0
		27 g.addNode(4): -2
		28 g.getEdge(1, 3): -4.0
		29 g.addEdge(1,3, 1.3): 0
		30 g.existsEdge(1, 3): //true----------------(false)
		31 g.getEdge(1, 3): 1.3
		32 g.getEdge(1, 4): -2.0
		33 g.getEdge(5,1): -1.0
		34 g.getEdge(5,4): -3.0
		35 g.removeNode(3): 0
		36 g.removeNode(3): //0----------------(-1)
		37 g.existsEdge(1, 3): true
		38 g.getEdge(1, 3): //1.3-------------------(-2.0)
		39 g.removeNode(2): 0
		40 g.removeNode(2): //0---------------------(-1)
		41 g.existsEdge(1, 1): true
		42 g.removeNode(1): 0
		43 g.existsNode(1): //true----------------------(false)
		44 g.existsNode(2): true
		45 g.existsNode(3): true
		46 g.existsNode(4): false
		47 g.addNode(4): 0
		48 g.existsNode(4): true
		49 g.addEdge(4,4, 4.4): 0
		50 g.existsEdge(4, 4): //true--------------------
		51 g.getEdge(4, 4): 4.4
		52 g.removeNode(4): 0
		53 g.removeNode(4): 0
		54 g.existsEdge(4, 4): true
		55 g.addNode(7): 0
		56 g.removeNode(2): 0
		57 g.removeNode(3): 0
		58 g.removeNode(4): -1
		59 g.existsEdge(7, 7): false
		60 g.addEdge(7,7, 7.7): 0
		61 g.addEdge(7,7, 17.17): -4
		62 g.getEdge(7, 7): 7.7
		63 g.addNode(8): 0
		64 g.addNode(9): 0
		65 g.existsEdge(7, 8): false
		66 g.existsEdge(8, 7): false
		67 g.existsEdge(8, 8): false
		68 g.existsEdge(8, 9): true
		69 g.existsEdge(9, 8): true
		70 g.existsEdge(9, 9): false
		71 g.addEdge(7,8, 7.8): 0
		72 g.addEdge(8,7, 8.7): 0
		73 g.addEdge(8,8, 8.8): 0
		74 g.addEdge(8,9, 8.9): -4
		75 g.addEdge(9,8, 9.8): -4
		76 g.addEdge(9,9, 9.9): 0
		77 g.addEdge(7,9, 7.9): 0
		78 g.addEdge(9,7, 9.7): 0
		79 g.getEdge(7, 7) --> -4.0
		80 g.getEdge(7, 8) --> 7.8
		81 g.getEdge(7, 9) --> 7.9
		82 g.getEdge(8, 7) --> 8.7
		83 g.getEdge(8, 8) --> 8.8
		84 g.getEdge(8, 9) --> 1.2
		85 g.getEdge(9, 7) --> 9.7
		86 g.getEdge(9, 8) --> 2.1
		87 g.getEdge(9, 9) --> 9.9
		88 g.removeNode(7): 0
		89 g.removeNode(7): 0
		90 g.getEdge(7, 7) --> -4.0
		91 g.getEdge(7, 8) --> 7.8
		92 g.getEdge(7, 9) --> 7.9
		93 g.getEdge(8, 7) --> 8.7
		94 g.getEdge(8, 8) --> 8.8
		95 g.getEdge(8, 9) --> 1.2
		96 g.getEdge(9, 7) --> 9.7
		97 g.getEdge(9, 8) --> 2.1
		98 g.getEdge(9, 9) --> 9.9
		99 g.removeNode(null): -1
		100 g.addNode(null): -4
		101 g.addNode(10): 0
		102 g.getEdge(8, 10) --> 8.7
		103 g.getEdge(10, 9) --> 7.9
		104 g.addNode(null): -6
		105 g.addEdge(8,8,-8.8): -12
		106 g.addEdge(7,8,-7.8): -9
		107 g.addEdge(8,7,-8.7): -10
		108 g.addEdge(7,7,-7.7): -11
		109 g.addEdge(null,8,0.8): -1
		110 g.addEdge(8,null,0.8): -2
		111 g.addEdge(null,null,0.8): -3
		112 g.getEdge(null,10): -1.0
		113 g.getEdge(10,null): -2.0
		114 g.getEdge(null,null): -3.0
		115 g.existsNode(null): false
		116 g.existsEdge(null,null): false
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-10-06 00:59:57.441
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-10-06 00:59:57.442
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-10-06 00:59:58.440
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package p2Grafos;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import org.junit.Test;

/**
 * Titulo: Clase GraphTests
 * 
 * @author UO281847
 * @version 24/09/2021
 */
public class GraphTests {
	private Graph<Integer> g;
///*
// * Pruebas del método addNode:	
// */
//	/**
//	 * Test del método addNode sin errores
//	 */
//	@Test
//	public void testAddNodeFirst() {
//		Graph<Integer> g = new Graph<Integer>(3);
//		int node = 12;
//		assertEquals(0, g.addNode(node));
//		System.out.println(g.toString());	
//	}	
//	/**
//	 * Test del método addNode con nodo no valido
//	 */
//	@Test
//	public void testAddNodeNotValid() {
//		Graph<Integer> g = new Graph<Integer>(3);
//		int node = 1;
//		int node2 = 18;
//		assertEquals(0, g.addNode(node));
//		assertEquals(0, g.addNode(node2));
//		assertEquals(-5, g.addNode(null));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addNode cuando ya esta lleno
//	 */
//	@Test
//	public void testAddNodeFull() {
//		Graph<Integer> g = new Graph<Integer>(3);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 39;
//		int node4= 2;
//		assertEquals(0, g.addNode(node));
//		assertEquals(0, g.addNode(node2));
//		assertEquals(0, g.addNode(node3));
//		assertEquals(-2, g.addNode(node4));		
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addNode cuando ya existe
//	 */
//	@Test
//	public void testAddNodeAlreadyExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 39;
//		int node4 = 19;
//		int node5= 19;
//		assertEquals(0, g.addNode(node));
//		assertEquals(0, g.addNode(node2));
//		assertEquals(0, g.addNode(node3));
//		assertEquals(0, g.addNode(node4));
//		assertEquals(-1, g.addNode(node5));	
//		System.out.println(g.toString());	
//	}
//	
///*
// * Pruebas del método getNode:
// */
//	/**
//	 * Test del método getNode que devuelve la posición
//	 */
//	@Test
//	public void testGetNodeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		g.addNode(node);
//		assertEquals(0, g.getNode(node));
//	}
//	/**
//	 * Test del método getNode que devuelve la posición ya añadido
//	 */
//	@Test
//	public void testGetNodeVarious() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 23;
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(1, g.getNode(node2));
//	}
//	/**
//	 * Test del método getNode que devuelve -1
//	 */
//	@Test
//	public void testGetNodeDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 23;
//		g.addNode(node);
//		assertEquals(-1, g.getNode(node2));
//	}
//
///**
// * Pruebas del método existsNode:
// */
//	/**
//	 * Test del método existsNode que devuelve true
//	 */
//	@Test
//	public void testExistsNodeOne() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		g.addNode(node);
//		assertTrue(g.existsNode(node));
//	}
//	/**
//	 * Test del método existsNode que devuelve true
//	 */
//	@Test
//	public void testExistsNodeVarious() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 23;
//		g.addNode(node);
//		g.addNode(node2);
//		assertTrue(g.existsNode(node2));
//	}
//	/**
//	 * Test del método existsNode que devuelve true
//	 */
//	@Test
//	public void testExistsNodeFalse() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 23;
//		g.addNode(node);
//		assertFalse(g.existsNode(node2));
//	}
//
///*
// * Pruebas del método addEdge:
// */
//	/**
//	 * Test del método addEdge que no tiene errores
//	 */
//	@Test
//	public void testAddEdgeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;		
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(0, g.addEdge(node, node2, 12));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde no existe el nodo origen
//	 */
//	@Test
//	public void testAddEdgeSourceDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 23;
//		g.addNode(node);
//		g.addNode(node2);		
//		assertEquals(-1, g.addEdge(node3, node2, 12));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde no existe el nodo destino
//	 */
//	@Test
//	public void testAddEdgeTargetDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 23;
//		g.addNode(node);
//		g.addNode(node2);		
//		assertEquals(-2, g.addEdge(node, node3, 12));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde ya existe la arista
//	 */
//	@Test
//	public void testAddEdgeEdgeExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 12);
//		assertEquals(-4, g.addEdge(node, node2, 12));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde el peso no es valido
//	 */
//	@Test
//	public void testAddEdgeEdgeWightError() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(-8, g.addEdge(node, node2, -4));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde no existen los nodos 
//	 */
//	@Test
//	public void testAddEdgeSourceTargetError() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 12;
//		int node4 = 56;
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(-3, g.addEdge(node3, node4, 4));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde ya existe la arista y el peso no es valido
//	 */
//	@Test
//	public void testAddEdgeEdgeExistsEdgeWeightError() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-12, g.addEdge(node, node2, -4));
//		System.out.println(g.toString());	
//	}
//	
///*
// * Pruebas del método getEdge:
// */
//	/**
//	 * Test del método getEdge que no tiene errores
//	 */
//	@Test
//	public void testGetEdgeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(4, g.getEdge(node, node2),0.1);
//	}
//	/**
//	 * Test del método getEdge donde no existe el nodo origen
//	 */
//	@Test
//	public void testGetEdgeSourceDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 4;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-1, g.getEdge(node3, node2),0.1);
//	}
//	/**
//	 * Test del método getEdge donde no existe el nodo destino
//	 */
//	@Test
//	public void testGetEdgeTargetDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 4;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-2, g.getEdge(node, node3),0.1);
//	}
//	/**
//	 * Test del método getEdge donde existen los nodos y no la arista
//	 */
//	@Test
//	public void testGetEdgeEdgeDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(-4, g.getEdge(node, node2),0.1);
//	}
//	/**
//	 * Test del método getEdge donde no existen los nodos
//	 */
//	@Test
//	public void testGetEdgeBothDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 4;
//		int node4 = 6;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-3, g.getEdge(node3, node4),0.1);
//	}
//	
///*
// * Pruebas del método existsEdge:
// */
//	/**
//	 * Test del método existsEdge que no tiene errores
//	 */
//	@Test
//	public void testExistsEdgeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertTrue(g.existsEdge(node, node2));
//	}
//	/**
//	 * Test del método existsEdge donde no existe el nodo origen
//	 */
//	@Test
//	public void testExistsEdgeSourceDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3= 8;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertFalse(g.existsEdge(node3, node2));
//	}
//	/**
//	 * Test del método existsEdge donde no existe el nodo destino
//	 */
//	@Test
//	public void testExistsEdgeTargetDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3= 8;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertFalse(g.existsEdge(node, node3));
//	}
//	/**
//	 * Test del método existsEdge donde no existen los nodos
//	 */
//	@Test
//	public void testExistsEdgeBothDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		int node4 = 12;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertFalse(g.existsEdge(node3, node4));
//	}
//	
///*
// * Pruebas del método removeEdge:
// */
//	/**
//	 * Test del método removeEdge que no tiene errores 
//	 */
//	@Test
//	public void testRemoveEdgeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		int node4 = 12;
//		g.addNode(node);
//		g.addNode(node2); 
//		g.addNode(node3);
//		g.addNode(node4);
//		g.addEdge(node, node2, 4);
//		g.addEdge(node3, node4, 12);
//		assertEquals(0, g.removeEdge(node3, node4));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeEdge donde no existe el nodo origen
//	 */
//	@Test
//	public void testRemoveEdgeSourceDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		g.addNode(node);
//		g.addNode(node2); 
//		g.addEdge(node, node2, 4);
//		assertEquals(-1, g.removeEdge(node3, node2));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeEdge donde no existe el nodo destino
//	 */
//	@Test
//	public void testRemoveEdgeTargetDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		g.addNode(node);
//		g.addNode(node2); 
//		g.addEdge(node, node2, 4);
//		assertEquals(-2, g.removeEdge(node2, node3));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeEdge donde existen los nodos y no la arista
//	 */
//	@Test
//	public void testRemoveEdgeEdgeDontExistsNodesExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2); 
//		g.addEdge(node, node2, 4);
//		assertEquals(-4, g.removeEdge(node2, node));
//		System.out.println(g.toString());
//	}	
//	/**
//	 * Test del método removeEdge donde no existen los nodos
//	 */
//	@Test
//	public void testRemoveEdgeNodesDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		int node4 = 12;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-3, g.removeEdge(node3, node4));
//		System.out.println(g.toString());
//	}
///*
// * Pruebas del método removeNode:
// */
//	/**
//	 * Test del método removeNode que no tiene errores
//	 */
//	@Test
//	public void testRemoveNodeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;		
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(0, g.removeNode(node));
//		assertFalse(g.existsNode(node));
//		assertFalse(g.existsEdge(node, node2));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeNode que no tiene errores y borra toda la matriz
//	 */
//	@Test
//	public void testRemoveNodeVarious() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		int node4 = 12;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		g.addEdge(node, node, 12);
//		g.addEdge(node3, node, 7);
//		g.addEdge(node, node4, 15);
//		g.addEdge(node, node3, 9);
//		assertEquals(0, g.removeNode(node));
//		assertFalse(g.existsNode(node));
//		assertFalse(g.existsEdge(node, node2));
//		assertFalse(g.existsEdge(node, node));
//		assertFalse(g.existsEdge(node3, node));
//		assertFalse(g.existsEdge(node, node4));
//		assertFalse(g.existsEdge(node, node3));
//		System.out.println(g.toString());
//	}	
//	/**
//	 * Test del método removeNode donde el nodo no es valido
//	 */
//	@Test
//	public void testRemoveNodeNotValid() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;		
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-1, g.removeNode(null));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeNode donde el nodo no existe
//	 */
//	@Test
//	public void testRemoveNodeDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 12;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-1, g.removeNode(node3));
//		System.out.println(g.toString());
//	}
	/**
	 * Pruebas basicas de nodos
	 */
//	@Test
//	public void basicNodeTest() {
//		g=new Graph<Integer>(3); 
//	    assertFalse(g.existsNode(1)); //false
//	    assertFalse(g.existsNode(2)); //false
//	    assertEquals(0,g.addNode(1)); //0
//		assertEquals(0,g.addNode(2)); //0
//		assertTrue(g.existsNode(1)); //true
//		assertTrue(g.existsNode(2)); //true
//		assertEquals(-1,g.addNode(1)); //-1
//		assertEquals(-1,g.addNode(2)); //-1
//		assertEquals(0,g.addNode(3)); //0
//		assertEquals(-2,g.addNode(4)); //-2
//		assertFalse(g.existsNode(4)); //false
//		assertFalse(g.existsNode(5)); //false
//	}
	
//	@Test
//	public void basicEdgeTest() {
//		g=new Graph<Integer>(3); 
//		assertFalse(g.existsEdge(1,2)); //false
//		assertEquals(-3.0,g.getEdge(1,2),0.1); //-3.0
//		assertEquals(0,g.addNode(1)); //0
//		assertFalse(g.existsEdge(1,2)); //false
//		assertEquals(-2.0,g.getEdge(1,2),0.1); //-2.0
//		assertFalse(g.existsEdge(2,1)); //false
//		assertEquals(-1.0,g.getEdge(2,1),0.1); //-1.0
//		assertEquals(0,g.addNode(2)); //0
//		assertFalse(g.existsEdge(1,2)); //false
//		assertEquals(-4.0,g.getEdge(1,2),0.1); //-4.0
//		assertEquals(0,g.addEdge(1,2,12.12)); //0
//		assertEquals(-4,g.addEdge(1,2,12.1212)); //-4
//		assertEquals(0,g.addNode(3)); //0
//		assertFalse(g.existsEdge(1,3)); //false
//		assertFalse(g.existsEdge(3,2)); //false
//		assertEquals(-4.0,g.getEdge(1,3),0.1); //-4.0
//		assertEquals(-4.0,g.getEdge(3,2),0.1); //-4.0
//		assertEquals(0,g.addEdge(1,1,11.11)); //0
//		assertEquals(-4,g.addEdge(1,2,12.12)); //-4
//		assertEquals(0,g.addEdge(1,3,13.13)); //0
//		assertEquals(0,g.addEdge(2,1,21.21)); //0
//		assertEquals(0,g.addEdge(2,2,22.22)); //0
//		assertEquals(0,g.addEdge(2,3,23.23)); //0
//		assertEquals(0,g.addEdge(3,1,31.31)); //0
//		assertEquals(0,g.addEdge(3,2,32.32)); //0
//		assertEquals(0,g.addEdge(3,3,33.33)); //0
//		assertEquals(-4,g.addEdge(1,1,11.11)); //-4
//		assertEquals(-4,g.addEdge(1,2,12.12)); //-4
//		assertEquals(-4,g.addEdge(1,3,13.13)); //-4
//		assertEquals(-4,g.addEdge(2,1,21.21)); //-4
//		assertEquals(-4,g.addEdge(2,2,22.22)); //-4
//		assertEquals(-4,g.addEdge(2,3,23.23)); //-4
//		assertEquals(-4,g.addEdge(3,1,31.31)); //-4
//		assertEquals(-4,g.addEdge(3,2,32.32)); //-4
//		assertEquals(-4,g.addEdge(3,3,33.33)); //-4
//		g.getEdge(1,1,11.11); //11.11
//		g.getEdge(1,2,12.12); //12.12
//		g.getEdge(1,3,13.13); //13.129999999999999
//		g.getEdge(2,1,21.21); //21.21
//		g.getEdge(2,2,22.22); //22.22
//		g.getEdge(2,3,23.23); //23.23
//		g.getEdge(3,1,31.31); //31.310000000000002
//		g.getEdge(3,2,32.32); //32.32
//		g.getEdge(3,3,33.33); //33.33
//	}
	
	@Test
	public void basicEvolutionTest() {
		1 g.existsNode(1): //false
		2 g.existsNode(2): false
		3 g.addNode(1): 0
		4 g.addNode(2): 0
		5 g.existsNode(1): true
		6 g.existsNode(2): true
		7 g.addNode(1): -1
		8 g.addNode(2): -1
		9 g.addEdge(1,2, 1.2): 0
		10 g.addEdge(2,1, 2.1): 0
		11 g.addEdge(1,1, 1.1): 0
		12 g.getEdge(1,2): 1.2
		13 g.getEdge(2,1): 2.1
		14 g.getEdge(1,1): 1.1
		15 g.getEdge(2,3): -2.0
		16 g.existsEdge(1,2): true
		17 g.existsEdge(2,1): true
		18 g.existsEdge(1,1): true
		19 g.existsEdge(2,2): false
		20 g.removeEdge(2,2): -4
		21 g.addEdge(2,2,2.2): 0
		22 g.getEdge(2,2): 2.2
		23 g.existsEdge(2,2): true
		24 g.removeEdge(2,2): 0
		25 g.removeNode(3): -1
		26 g.addNode(3): 0
		27 g.addNode(4): -2
		28 g.getEdge(1, 3): -4.0
		29 g.addEdge(1,3, 1.3): 0
		30 g.existsEdge(1, 3): //true----------------(false)
		31 g.getEdge(1, 3): 1.3
		32 g.getEdge(1, 4): -2.0
		33 g.getEdge(5,1): -1.0
		34 g.getEdge(5,4): -3.0
		35 g.removeNode(3): 0
		36 g.removeNode(3): //0----------------(-1)
		37 g.existsEdge(1, 3): true
		38 g.getEdge(1, 3): //1.3-------------------(-2.0)
		39 g.removeNode(2): 0
		40 g.removeNode(2): //0---------------------(-1)
		41 g.existsEdge(1, 1): true
		42 g.removeNode(1): 0
		43 g.existsNode(1): //true----------------------(false)
		44 g.existsNode(2): true
		45 g.existsNode(3): true
		46 g.existsNode(4): false
		47 g.addNode(4): 0
		48 g.existsNode(4): true
		49 g.addEdge(4,4, 4.4): 0
		50 g.existsEdge(4, 4): //true--------------------)
		51 g.getEdge(4, 4): 4.4
		52 g.removeNode(4): 0
		53 g.removeNode(4): 0
		54 g.existsEdge(4, 4): true
		55 g.addNode(7): 0
		56 g.removeNode(2): 0
		57 g.removeNode(3): 0
		58 g.removeNode(4): -1
		59 g.existsEdge(7, 7): false
		60 g.addEdge(7,7, 7.7): 0
		61 g.addEdge(7,7, 17.17): -4
		62 g.getEdge(7, 7): 7.7
		63 g.addNode(8): 0
		64 g.addNode(9): 0
		65 g.existsEdge(7, 8): false
		66 g.existsEdge(8, 7): false
		67 g.existsEdge(8, 8): false
		68 g.existsEdge(8, 9): true
		69 g.existsEdge(9, 8): true
		70 g.existsEdge(9, 9): false
		71 g.addEdge(7,8, 7.8): 0
		72 g.addEdge(8,7, 8.7): 0
		73 g.addEdge(8,8, 8.8): 0
		74 g.addEdge(8,9, 8.9): -4
		75 g.addEdge(9,8, 9.8): -4
		76 g.addEdge(9,9, 9.9): 0
		77 g.addEdge(7,9, 7.9): 0
		78 g.addEdge(9,7, 9.7): 0
		79 g.getEdge(7, 7) --> -4.0
		80 g.getEdge(7, 8) --> 7.8
		81 g.getEdge(7, 9) --> 7.9
		82 g.getEdge(8, 7) --> 8.7
		83 g.getEdge(8, 8) --> 8.8
		84 g.getEdge(8, 9) --> 1.2
		85 g.getEdge(9, 7) --> 9.7
		86 g.getEdge(9, 8) --> 2.1
		87 g.getEdge(9, 9) --> 9.9
		88 g.removeNode(7): 0
		89 g.removeNode(7): 0
		90 g.getEdge(7, 7) --> -4.0
		91 g.getEdge(7, 8) --> 7.8
		92 g.getEdge(7, 9) --> 7.9
		93 g.getEdge(8, 7) --> 8.7
		94 g.getEdge(8, 8) --> 8.8
		95 g.getEdge(8, 9) --> 1.2
		96 g.getEdge(9, 7) --> 9.7
		97 g.getEdge(9, 8) --> 2.1
		98 g.getEdge(9, 9) --> 9.9
		99 g.removeNode(null): -1
		100 g.addNode(null): -4
		101 g.addNode(10): 0
		102 g.getEdge(8, 10) --> 8.7
		103 g.getEdge(10, 9) --> 7.9
		104 g.addNode(null): -6
		105 g.addEdge(8,8,-8.8): -12
		106 g.addEdge(7,8,-7.8): -9
		107 g.addEdge(8,7,-8.7): -10
		108 g.addEdge(7,7,-7.7): -11
		109 g.addEdge(null,8,0.8): -1
		110 g.addEdge(8,null,0.8): -2
		111 g.addEdge(null,null,0.8): -3
		112 g.getEdge(null,10): -1.0
		113 g.getEdge(10,null): -2.0
		114 g.getEdge(null,null): -3.0
		115 g.existsNode(null): false
		116 g.existsEdge(null,null): false
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-10-06 00:59:58.442
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-10-06 00:59:58.444
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-10-06 00:59:58.483
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package p2Grafos;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import org.junit.Test;

/**
 * Titulo: Clase GraphTests
 * 
 * @author UO281847
 * @version 24/09/2021
 */
public class GraphTests {
	private Graph<Integer> g;
///*
// * Pruebas del método addNode:	
// */
//	/**
//	 * Test del método addNode sin errores
//	 */
//	@Test
//	public void testAddNodeFirst() {
//		Graph<Integer> g = new Graph<Integer>(3);
//		int node = 12;
//		assertEquals(0, g.addNode(node));
//		System.out.println(g.toString());	
//	}	
//	/**
//	 * Test del método addNode con nodo no valido
//	 */
//	@Test
//	public void testAddNodeNotValid() {
//		Graph<Integer> g = new Graph<Integer>(3);
//		int node = 1;
//		int node2 = 18;
//		assertEquals(0, g.addNode(node));
//		assertEquals(0, g.addNode(node2));
//		assertEquals(-5, g.addNode(null));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addNode cuando ya esta lleno
//	 */
//	@Test
//	public void testAddNodeFull() {
//		Graph<Integer> g = new Graph<Integer>(3);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 39;
//		int node4= 2;
//		assertEquals(0, g.addNode(node));
//		assertEquals(0, g.addNode(node2));
//		assertEquals(0, g.addNode(node3));
//		assertEquals(-2, g.addNode(node4));		
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addNode cuando ya existe
//	 */
//	@Test
//	public void testAddNodeAlreadyExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 39;
//		int node4 = 19;
//		int node5= 19;
//		assertEquals(0, g.addNode(node));
//		assertEquals(0, g.addNode(node2));
//		assertEquals(0, g.addNode(node3));
//		assertEquals(0, g.addNode(node4));
//		assertEquals(-1, g.addNode(node5));	
//		System.out.println(g.toString());	
//	}
//	
///*
// * Pruebas del método getNode:
// */
//	/**
//	 * Test del método getNode que devuelve la posición
//	 */
//	@Test
//	public void testGetNodeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		g.addNode(node);
//		assertEquals(0, g.getNode(node));
//	}
//	/**
//	 * Test del método getNode que devuelve la posición ya añadido
//	 */
//	@Test
//	public void testGetNodeVarious() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 23;
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(1, g.getNode(node2));
//	}
//	/**
//	 * Test del método getNode que devuelve -1
//	 */
//	@Test
//	public void testGetNodeDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 23;
//		g.addNode(node);
//		assertEquals(-1, g.getNode(node2));
//	}
//
///**
// * Pruebas del método existsNode:
// */
//	/**
//	 * Test del método existsNode que devuelve true
//	 */
//	@Test
//	public void testExistsNodeOne() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		g.addNode(node);
//		assertTrue(g.existsNode(node));
//	}
//	/**
//	 * Test del método existsNode que devuelve true
//	 */
//	@Test
//	public void testExistsNodeVarious() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 23;
//		g.addNode(node);
//		g.addNode(node2);
//		assertTrue(g.existsNode(node2));
//	}
//	/**
//	 * Test del método existsNode que devuelve true
//	 */
//	@Test
//	public void testExistsNodeFalse() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 23;
//		g.addNode(node);
//		assertFalse(g.existsNode(node2));
//	}
//
///*
// * Pruebas del método addEdge:
// */
//	/**
//	 * Test del método addEdge que no tiene errores
//	 */
//	@Test
//	public void testAddEdgeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;		
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(0, g.addEdge(node, node2, 12));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde no existe el nodo origen
//	 */
//	@Test
//	public void testAddEdgeSourceDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 23;
//		g.addNode(node);
//		g.addNode(node2);		
//		assertEquals(-1, g.addEdge(node3, node2, 12));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde no existe el nodo destino
//	 */
//	@Test
//	public void testAddEdgeTargetDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 23;
//		g.addNode(node);
//		g.addNode(node2);		
//		assertEquals(-2, g.addEdge(node, node3, 12));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde ya existe la arista
//	 */
//	@Test
//	public void testAddEdgeEdgeExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 12);
//		assertEquals(-4, g.addEdge(node, node2, 12));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde el peso no es valido
//	 */
//	@Test
//	public void testAddEdgeEdgeWightError() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(-8, g.addEdge(node, node2, -4));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde no existen los nodos 
//	 */
//	@Test
//	public void testAddEdgeSourceTargetError() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 12;
//		int node4 = 56;
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(-3, g.addEdge(node3, node4, 4));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde ya existe la arista y el peso no es valido
//	 */
//	@Test
//	public void testAddEdgeEdgeExistsEdgeWeightError() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-12, g.addEdge(node, node2, -4));
//		System.out.println(g.toString());	
//	}
//	
///*
// * Pruebas del método getEdge:
// */
//	/**
//	 * Test del método getEdge que no tiene errores
//	 */
//	@Test
//	public void testGetEdgeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(4, g.getEdge(node, node2),0.1);
//	}
//	/**
//	 * Test del método getEdge donde no existe el nodo origen
//	 */
//	@Test
//	public void testGetEdgeSourceDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 4;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-1, g.getEdge(node3, node2),0.1);
//	}
//	/**
//	 * Test del método getEdge donde no existe el nodo destino
//	 */
//	@Test
//	public void testGetEdgeTargetDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 4;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-2, g.getEdge(node, node3),0.1);
//	}
//	/**
//	 * Test del método getEdge donde existen los nodos y no la arista
//	 */
//	@Test
//	public void testGetEdgeEdgeDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(-4, g.getEdge(node, node2),0.1);
//	}
//	/**
//	 * Test del método getEdge donde no existen los nodos
//	 */
//	@Test
//	public void testGetEdgeBothDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 4;
//		int node4 = 6;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-3, g.getEdge(node3, node4),0.1);
//	}
//	
///*
// * Pruebas del método existsEdge:
// */
//	/**
//	 * Test del método existsEdge que no tiene errores
//	 */
//	@Test
//	public void testExistsEdgeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertTrue(g.existsEdge(node, node2));
//	}
//	/**
//	 * Test del método existsEdge donde no existe el nodo origen
//	 */
//	@Test
//	public void testExistsEdgeSourceDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3= 8;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertFalse(g.existsEdge(node3, node2));
//	}
//	/**
//	 * Test del método existsEdge donde no existe el nodo destino
//	 */
//	@Test
//	public void testExistsEdgeTargetDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3= 8;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertFalse(g.existsEdge(node, node3));
//	}
//	/**
//	 * Test del método existsEdge donde no existen los nodos
//	 */
//	@Test
//	public void testExistsEdgeBothDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		int node4 = 12;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertFalse(g.existsEdge(node3, node4));
//	}
//	
///*
// * Pruebas del método removeEdge:
// */
//	/**
//	 * Test del método removeEdge que no tiene errores 
//	 */
//	@Test
//	public void testRemoveEdgeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		int node4 = 12;
//		g.addNode(node);
//		g.addNode(node2); 
//		g.addNode(node3);
//		g.addNode(node4);
//		g.addEdge(node, node2, 4);
//		g.addEdge(node3, node4, 12);
//		assertEquals(0, g.removeEdge(node3, node4));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeEdge donde no existe el nodo origen
//	 */
//	@Test
//	public void testRemoveEdgeSourceDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		g.addNode(node);
//		g.addNode(node2); 
//		g.addEdge(node, node2, 4);
//		assertEquals(-1, g.removeEdge(node3, node2));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeEdge donde no existe el nodo destino
//	 */
//	@Test
//	public void testRemoveEdgeTargetDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		g.addNode(node);
//		g.addNode(node2); 
//		g.addEdge(node, node2, 4);
//		assertEquals(-2, g.removeEdge(node2, node3));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeEdge donde existen los nodos y no la arista
//	 */
//	@Test
//	public void testRemoveEdgeEdgeDontExistsNodesExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2); 
//		g.addEdge(node, node2, 4);
//		assertEquals(-4, g.removeEdge(node2, node));
//		System.out.println(g.toString());
//	}	
//	/**
//	 * Test del método removeEdge donde no existen los nodos
//	 */
//	@Test
//	public void testRemoveEdgeNodesDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		int node4 = 12;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-3, g.removeEdge(node3, node4));
//		System.out.println(g.toString());
//	}
///*
// * Pruebas del método removeNode:
// */
//	/**
//	 * Test del método removeNode que no tiene errores
//	 */
//	@Test
//	public void testRemoveNodeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;		
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(0, g.removeNode(node));
//		assertFalse(g.existsNode(node));
//		assertFalse(g.existsEdge(node, node2));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeNode que no tiene errores y borra toda la matriz
//	 */
//	@Test
//	public void testRemoveNodeVarious() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		int node4 = 12;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		g.addEdge(node, node, 12);
//		g.addEdge(node3, node, 7);
//		g.addEdge(node, node4, 15);
//		g.addEdge(node, node3, 9);
//		assertEquals(0, g.removeNode(node));
//		assertFalse(g.existsNode(node));
//		assertFalse(g.existsEdge(node, node2));
//		assertFalse(g.existsEdge(node, node));
//		assertFalse(g.existsEdge(node3, node));
//		assertFalse(g.existsEdge(node, node4));
//		assertFalse(g.existsEdge(node, node3));
//		System.out.println(g.toString());
//	}	
//	/**
//	 * Test del método removeNode donde el nodo no es valido
//	 */
//	@Test
//	public void testRemoveNodeNotValid() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;		
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-1, g.removeNode(null));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeNode donde el nodo no existe
//	 */
//	@Test
//	public void testRemoveNodeDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 12;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-1, g.removeNode(node3));
//		System.out.println(g.toString());
//	}
	/**
	 * Pruebas basicas de nodos
	 */
//	@Test
//	public void basicNodeTest() {
//		g=new Graph<Integer>(3); 
//	    assertFalse(g.existsNode(1)); //false
//	    assertFalse(g.existsNode(2)); //false
//	    assertEquals(0,g.addNode(1)); //0
//		assertEquals(0,g.addNode(2)); //0
//		assertTrue(g.existsNode(1)); //true
//		assertTrue(g.existsNode(2)); //true
//		assertEquals(-1,g.addNode(1)); //-1
//		assertEquals(-1,g.addNode(2)); //-1
//		assertEquals(0,g.addNode(3)); //0
//		assertEquals(-2,g.addNode(4)); //-2
//		assertFalse(g.existsNode(4)); //false
//		assertFalse(g.existsNode(5)); //false
//	}
	
//	@Test
//	public void basicEdgeTest() {
//		g=new Graph<Integer>(3); 
//		assertFalse(g.existsEdge(1,2)); //false
//		assertEquals(-3.0,g.getEdge(1,2),0.1); //-3.0
//		assertEquals(0,g.addNode(1)); //0
//		assertFalse(g.existsEdge(1,2)); //false
//		assertEquals(-2.0,g.getEdge(1,2),0.1); //-2.0
//		assertFalse(g.existsEdge(2,1)); //false
//		assertEquals(-1.0,g.getEdge(2,1),0.1); //-1.0
//		assertEquals(0,g.addNode(2)); //0
//		assertFalse(g.existsEdge(1,2)); //false
//		assertEquals(-4.0,g.getEdge(1,2),0.1); //-4.0
//		assertEquals(0,g.addEdge(1,2,12.12)); //0
//		assertEquals(-4,g.addEdge(1,2,12.1212)); //-4
//		assertEquals(0,g.addNode(3)); //0
//		assertFalse(g.existsEdge(1,3)); //false
//		assertFalse(g.existsEdge(3,2)); //false
//		assertEquals(-4.0,g.getEdge(1,3),0.1); //-4.0
//		assertEquals(-4.0,g.getEdge(3,2),0.1); //-4.0
//		assertEquals(0,g.addEdge(1,1,11.11)); //0
//		assertEquals(-4,g.addEdge(1,2,12.12)); //-4
//		assertEquals(0,g.addEdge(1,3,13.13)); //0
//		assertEquals(0,g.addEdge(2,1,21.21)); //0
//		assertEquals(0,g.addEdge(2,2,22.22)); //0
//		assertEquals(0,g.addEdge(2,3,23.23)); //0
//		assertEquals(0,g.addEdge(3,1,31.31)); //0
//		assertEquals(0,g.addEdge(3,2,32.32)); //0
//		assertEquals(0,g.addEdge(3,3,33.33)); //0
//		assertEquals(-4,g.addEdge(1,1,11.11)); //-4
//		assertEquals(-4,g.addEdge(1,2,12.12)); //-4
//		assertEquals(-4,g.addEdge(1,3,13.13)); //-4
//		assertEquals(-4,g.addEdge(2,1,21.21)); //-4
//		assertEquals(-4,g.addEdge(2,2,22.22)); //-4
//		assertEquals(-4,g.addEdge(2,3,23.23)); //-4
//		assertEquals(-4,g.addEdge(3,1,31.31)); //-4
//		assertEquals(-4,g.addEdge(3,2,32.32)); //-4
//		assertEquals(-4,g.addEdge(3,3,33.33)); //-4
//		g.getEdge(1,1,11.11); //11.11
//		g.getEdge(1,2,12.12); //12.12
//		g.getEdge(1,3,13.13); //13.129999999999999
//		g.getEdge(2,1,21.21); //21.21
//		g.getEdge(2,2,22.22); //22.22
//		g.getEdge(2,3,23.23); //23.23
//		g.getEdge(3,1,31.31); //31.310000000000002
//		g.getEdge(3,2,32.32); //32.32
//		g.getEdge(3,3,33.33); //33.33
//	}
	
	@Test
	public void basicEvolutionTest() {
		1 g.existsNode(1): //false
		2 g.existsNode(2): false
		3 g.addNode(1): 0
		4 g.addNode(2): 0
		5 g.existsNode(1): true
		6 g.existsNode(2): true
		7 g.addNode(1): -1
		8 g.addNode(2): -1
		9 g.addEdge(1,2, 1.2): 0
		10 g.addEdge(2,1, 2.1): 0
		11 g.addEdge(1,1, 1.1): 0
		12 g.getEdge(1,2): 1.2
		13 g.getEdge(2,1): 2.1
		14 g.getEdge(1,1): 1.1
		15 g.getEdge(2,3): -2.0
		16 g.existsEdge(1,2): true
		17 g.existsEdge(2,1): true
		18 g.existsEdge(1,1): true
		19 g.existsEdge(2,2): false
		20 g.removeEdge(2,2): -4
		21 g.addEdge(2,2,2.2): 0
		22 g.getEdge(2,2): 2.2
		23 g.existsEdge(2,2): true
		24 g.removeEdge(2,2): 0
		25 g.removeNode(3): -1
		26 g.addNode(3): 0
		27 g.addNode(4): -2
		28 g.getEdge(1, 3): -4.0
		29 g.addEdge(1,3, 1.3): 0
		30 g.existsEdge(1, 3): //true----------------(false)
		31 g.getEdge(1, 3): 1.3
		32 g.getEdge(1, 4): -2.0
		33 g.getEdge(5,1): -1.0
		34 g.getEdge(5,4): -3.0
		35 g.removeNode(3): 0
		36 g.removeNode(3): //0----------------(-1)
		37 g.existsEdge(1, 3): true
		38 g.getEdge(1, 3): //1.3-------------------(-2.0)
		39 g.removeNode(2): 0
		40 g.removeNode(2): //0---------------------(-1)
		41 g.existsEdge(1, 1): true
		42 g.removeNode(1): 0
		43 g.existsNode(1): //true----------------------(false)
		44 g.existsNode(2): true
		45 g.existsNode(3): true
		46 g.existsNode(4): false
		47 g.addNode(4): 0
		48 g.existsNode(4): true
		49 g.addEdge(4,4, 4.4): 0
		50 g.existsEdge(4, 4): //true--------------------)
		51 g.getEdge(4, 4): 4.4
		52 g.removeNode(4): 0
		53 g.removeNode(4): 0
		54 g.existsEdge(4, 4): true
		55 g.addNode(7): 0
		56 g.removeNode(2): 0
		57 g.removeNode(3): 0
		58 g.removeNode(4): -1
		59 g.existsEdge(7, 7): false
		60 g.addEdge(7,7, 7.7): 0
		61 g.addEdge(7,7, 17.17): -4
		62 g.getEdge(7, 7): 7.7
		63 g.addNode(8): 0
		64 g.addNode(9): 0
		65 g.existsEdge(7, 8): false
		66 g.existsEdge(8, 7): false
		67 g.existsEdge(8, 8): false
		68 g.existsEdge(8, 9): true
		69 g.existsEdge(9, 8): true
		70 g.existsEdge(9, 9): false
		71 g.addEdge(7,8, 7.8): 0
		72 g.addEdge(8,7, 8.7): 0
		73 g.addEdge(8,8, 8.8): 0
		74 g.addEdge(8,9, 8.9): -4
		75 g.addEdge(9,8, 9.8): -4
		76 g.addEdge(9,9, 9.9): 0
		77 g.addEdge(7,9, 7.9): 0
		78 g.addEdge(9,7, 9.7): 0
		79 g.getEdge(7, 7) --> -4.0
		80 g.getEdge(7, 8) --> 7.8
		81 g.getEdge(7, 9) --> 7.9
		82 g.getEdge(8, 7) --> 8.7
		83 g.getEdge(8, 8) --> 8.8
		84 g.getEdge(8, 9) --> 1.2
		85 g.getEdge(9, 7) --> 9.7
		86 g.getEdge(9, 8) --> 2.1
		87 g.getEdge(9, 9) --> 9.9
		88 g.removeNode(7): 0
		89 g.removeNode(7): 0
		90 g.getEdge(7, 7) --> -4.0
		91 g.getEdge(7, 8) --> 7.8
		92 g.getEdge(7, 9) --> 7.9
		93 g.getEdge(8, 7) --> 8.7
		94 g.getEdge(8, 8) --> 8.8
		95 g.getEdge(8, 9) --> 1.2
		96 g.getEdge(9, 7) --> 9.7
		97 g.getEdge(9, 8) --> 2.1
		98 g.getEdge(9, 9) --> 9.9
		99 g.removeNode(null): -1
		100 g.addNode(null): -4
		101 g.addNode(10): 0
		102 g.getEdge(8, 10) --> 8.7
		103 g.getEdge(10, 9) --> 7.9
		104 g.addNode(null): -6
		105 g.addEdge(8,8,-8.8): -12
		106 g.addEdge(7,8,-7.8): -9
		107 g.addEdge(8,7,-8.7): -10
		108 g.addEdge(7,7,-7.7): -11
		109 g.addEdge(null,8,0.8): -1
		110 g.addEdge(8,null,0.8): -2
		111 g.addEdge(null,null,0.8): -3
		112 g.getEdge(null,10): -1.0
		113 g.getEdge(10,null): -2.0
		114 g.getEdge(null,null): -3.0
		115 g.existsNode(null): false
		116 g.existsEdge(null,null): false
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-10-06 00:59:58.484
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-10-06 00:59:58.486
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-10-06 01:00:02.985
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package p2Grafos;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import org.junit.Test;

/**
 * Titulo: Clase GraphTests
 * 
 * @author UO281847
 * @version 24/09/2021
 */
public class GraphTests {
	private Graph<Integer> g;
///*
// * Pruebas del método addNode:	
// */
//	/**
//	 * Test del método addNode sin errores
//	 */
//	@Test
//	public void testAddNodeFirst() {
//		Graph<Integer> g = new Graph<Integer>(3);
//		int node = 12;
//		assertEquals(0, g.addNode(node));
//		System.out.println(g.toString());	
//	}	
//	/**
//	 * Test del método addNode con nodo no valido
//	 */
//	@Test
//	public void testAddNodeNotValid() {
//		Graph<Integer> g = new Graph<Integer>(3);
//		int node = 1;
//		int node2 = 18;
//		assertEquals(0, g.addNode(node));
//		assertEquals(0, g.addNode(node2));
//		assertEquals(-5, g.addNode(null));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addNode cuando ya esta lleno
//	 */
//	@Test
//	public void testAddNodeFull() {
//		Graph<Integer> g = new Graph<Integer>(3);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 39;
//		int node4= 2;
//		assertEquals(0, g.addNode(node));
//		assertEquals(0, g.addNode(node2));
//		assertEquals(0, g.addNode(node3));
//		assertEquals(-2, g.addNode(node4));		
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addNode cuando ya existe
//	 */
//	@Test
//	public void testAddNodeAlreadyExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 39;
//		int node4 = 19;
//		int node5= 19;
//		assertEquals(0, g.addNode(node));
//		assertEquals(0, g.addNode(node2));
//		assertEquals(0, g.addNode(node3));
//		assertEquals(0, g.addNode(node4));
//		assertEquals(-1, g.addNode(node5));	
//		System.out.println(g.toString());	
//	}
//	
///*
// * Pruebas del método getNode:
// */
//	/**
//	 * Test del método getNode que devuelve la posición
//	 */
//	@Test
//	public void testGetNodeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		g.addNode(node);
//		assertEquals(0, g.getNode(node));
//	}
//	/**
//	 * Test del método getNode que devuelve la posición ya añadido
//	 */
//	@Test
//	public void testGetNodeVarious() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 23;
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(1, g.getNode(node2));
//	}
//	/**
//	 * Test del método getNode que devuelve -1
//	 */
//	@Test
//	public void testGetNodeDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 23;
//		g.addNode(node);
//		assertEquals(-1, g.getNode(node2));
//	}
//
///**
// * Pruebas del método existsNode:
// */
//	/**
//	 * Test del método existsNode que devuelve true
//	 */
//	@Test
//	public void testExistsNodeOne() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		g.addNode(node);
//		assertTrue(g.existsNode(node));
//	}
//	/**
//	 * Test del método existsNode que devuelve true
//	 */
//	@Test
//	public void testExistsNodeVarious() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 23;
//		g.addNode(node);
//		g.addNode(node2);
//		assertTrue(g.existsNode(node2));
//	}
//	/**
//	 * Test del método existsNode que devuelve true
//	 */
//	@Test
//	public void testExistsNodeFalse() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 23;
//		g.addNode(node);
//		assertFalse(g.existsNode(node2));
//	}
//
///*
// * Pruebas del método addEdge:
// */
//	/**
//	 * Test del método addEdge que no tiene errores
//	 */
//	@Test
//	public void testAddEdgeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;		
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(0, g.addEdge(node, node2, 12));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde no existe el nodo origen
//	 */
//	@Test
//	public void testAddEdgeSourceDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 23;
//		g.addNode(node);
//		g.addNode(node2);		
//		assertEquals(-1, g.addEdge(node3, node2, 12));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde no existe el nodo destino
//	 */
//	@Test
//	public void testAddEdgeTargetDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 23;
//		g.addNode(node);
//		g.addNode(node2);		
//		assertEquals(-2, g.addEdge(node, node3, 12));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde ya existe la arista
//	 */
//	@Test
//	public void testAddEdgeEdgeExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 12);
//		assertEquals(-4, g.addEdge(node, node2, 12));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde el peso no es valido
//	 */
//	@Test
//	public void testAddEdgeEdgeWightError() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(-8, g.addEdge(node, node2, -4));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde no existen los nodos 
//	 */
//	@Test
//	public void testAddEdgeSourceTargetError() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 12;
//		int node4 = 56;
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(-3, g.addEdge(node3, node4, 4));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde ya existe la arista y el peso no es valido
//	 */
//	@Test
//	public void testAddEdgeEdgeExistsEdgeWeightError() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-12, g.addEdge(node, node2, -4));
//		System.out.println(g.toString());	
//	}
//	
///*
// * Pruebas del método getEdge:
// */
//	/**
//	 * Test del método getEdge que no tiene errores
//	 */
//	@Test
//	public void testGetEdgeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(4, g.getEdge(node, node2),0.1);
//	}
//	/**
//	 * Test del método getEdge donde no existe el nodo origen
//	 */
//	@Test
//	public void testGetEdgeSourceDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 4;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-1, g.getEdge(node3, node2),0.1);
//	}
//	/**
//	 * Test del método getEdge donde no existe el nodo destino
//	 */
//	@Test
//	public void testGetEdgeTargetDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 4;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-2, g.getEdge(node, node3),0.1);
//	}
//	/**
//	 * Test del método getEdge donde existen los nodos y no la arista
//	 */
//	@Test
//	public void testGetEdgeEdgeDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(-4, g.getEdge(node, node2),0.1);
//	}
//	/**
//	 * Test del método getEdge donde no existen los nodos
//	 */
//	@Test
//	public void testGetEdgeBothDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 4;
//		int node4 = 6;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-3, g.getEdge(node3, node4),0.1);
//	}
//	
///*
// * Pruebas del método existsEdge:
// */
//	/**
//	 * Test del método existsEdge que no tiene errores
//	 */
//	@Test
//	public void testExistsEdgeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertTrue(g.existsEdge(node, node2));
//	}
//	/**
//	 * Test del método existsEdge donde no existe el nodo origen
//	 */
//	@Test
//	public void testExistsEdgeSourceDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3= 8;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertFalse(g.existsEdge(node3, node2));
//	}
//	/**
//	 * Test del método existsEdge donde no existe el nodo destino
//	 */
//	@Test
//	public void testExistsEdgeTargetDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3= 8;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertFalse(g.existsEdge(node, node3));
//	}
//	/**
//	 * Test del método existsEdge donde no existen los nodos
//	 */
//	@Test
//	public void testExistsEdgeBothDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		int node4 = 12;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertFalse(g.existsEdge(node3, node4));
//	}
//	
///*
// * Pruebas del método removeEdge:
// */
//	/**
//	 * Test del método removeEdge que no tiene errores 
//	 */
//	@Test
//	public void testRemoveEdgeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		int node4 = 12;
//		g.addNode(node);
//		g.addNode(node2); 
//		g.addNode(node3);
//		g.addNode(node4);
//		g.addEdge(node, node2, 4);
//		g.addEdge(node3, node4, 12);
//		assertEquals(0, g.removeEdge(node3, node4));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeEdge donde no existe el nodo origen
//	 */
//	@Test
//	public void testRemoveEdgeSourceDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		g.addNode(node);
//		g.addNode(node2); 
//		g.addEdge(node, node2, 4);
//		assertEquals(-1, g.removeEdge(node3, node2));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeEdge donde no existe el nodo destino
//	 */
//	@Test
//	public void testRemoveEdgeTargetDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		g.addNode(node);
//		g.addNode(node2); 
//		g.addEdge(node, node2, 4);
//		assertEquals(-2, g.removeEdge(node2, node3));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeEdge donde existen los nodos y no la arista
//	 */
//	@Test
//	public void testRemoveEdgeEdgeDontExistsNodesExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2); 
//		g.addEdge(node, node2, 4);
//		assertEquals(-4, g.removeEdge(node2, node));
//		System.out.println(g.toString());
//	}	
//	/**
//	 * Test del método removeEdge donde no existen los nodos
//	 */
//	@Test
//	public void testRemoveEdgeNodesDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		int node4 = 12;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-3, g.removeEdge(node3, node4));
//		System.out.println(g.toString());
//	}
///*
// * Pruebas del método removeNode:
// */
//	/**
//	 * Test del método removeNode que no tiene errores
//	 */
//	@Test
//	public void testRemoveNodeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;		
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(0, g.removeNode(node));
//		assertFalse(g.existsNode(node));
//		assertFalse(g.existsEdge(node, node2));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeNode que no tiene errores y borra toda la matriz
//	 */
//	@Test
//	public void testRemoveNodeVarious() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		int node4 = 12;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		g.addEdge(node, node, 12);
//		g.addEdge(node3, node, 7);
//		g.addEdge(node, node4, 15);
//		g.addEdge(node, node3, 9);
//		assertEquals(0, g.removeNode(node));
//		assertFalse(g.existsNode(node));
//		assertFalse(g.existsEdge(node, node2));
//		assertFalse(g.existsEdge(node, node));
//		assertFalse(g.existsEdge(node3, node));
//		assertFalse(g.existsEdge(node, node4));
//		assertFalse(g.existsEdge(node, node3));
//		System.out.println(g.toString());
//	}	
//	/**
//	 * Test del método removeNode donde el nodo no es valido
//	 */
//	@Test
//	public void testRemoveNodeNotValid() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;		
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-1, g.removeNode(null));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeNode donde el nodo no existe
//	 */
//	@Test
//	public void testRemoveNodeDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 12;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-1, g.removeNode(node3));
//		System.out.println(g.toString());
//	}
	/**
	 * Pruebas basicas de nodos
	 */
//	@Test
//	public void basicNodeTest() {
//		g=new Graph<Integer>(3); 
//	    assertFalse(g.existsNode(1)); //false
//	    assertFalse(g.existsNode(2)); //false
//	    assertEquals(0,g.addNode(1)); //0
//		assertEquals(0,g.addNode(2)); //0
//		assertTrue(g.existsNode(1)); //true
//		assertTrue(g.existsNode(2)); //true
//		assertEquals(-1,g.addNode(1)); //-1
//		assertEquals(-1,g.addNode(2)); //-1
//		assertEquals(0,g.addNode(3)); //0
//		assertEquals(-2,g.addNode(4)); //-2
//		assertFalse(g.existsNode(4)); //false
//		assertFalse(g.existsNode(5)); //false
//	}
	
//	@Test
//	public void basicEdgeTest() {
//		g=new Graph<Integer>(3); 
//		assertFalse(g.existsEdge(1,2)); //false
//		assertEquals(-3.0,g.getEdge(1,2),0.1); //-3.0
//		assertEquals(0,g.addNode(1)); //0
//		assertFalse(g.existsEdge(1,2)); //false
//		assertEquals(-2.0,g.getEdge(1,2),0.1); //-2.0
//		assertFalse(g.existsEdge(2,1)); //false
//		assertEquals(-1.0,g.getEdge(2,1),0.1); //-1.0
//		assertEquals(0,g.addNode(2)); //0
//		assertFalse(g.existsEdge(1,2)); //false
//		assertEquals(-4.0,g.getEdge(1,2),0.1); //-4.0
//		assertEquals(0,g.addEdge(1,2,12.12)); //0
//		assertEquals(-4,g.addEdge(1,2,12.1212)); //-4
//		assertEquals(0,g.addNode(3)); //0
//		assertFalse(g.existsEdge(1,3)); //false
//		assertFalse(g.existsEdge(3,2)); //false
//		assertEquals(-4.0,g.getEdge(1,3),0.1); //-4.0
//		assertEquals(-4.0,g.getEdge(3,2),0.1); //-4.0
//		assertEquals(0,g.addEdge(1,1,11.11)); //0
//		assertEquals(-4,g.addEdge(1,2,12.12)); //-4
//		assertEquals(0,g.addEdge(1,3,13.13)); //0
//		assertEquals(0,g.addEdge(2,1,21.21)); //0
//		assertEquals(0,g.addEdge(2,2,22.22)); //0
//		assertEquals(0,g.addEdge(2,3,23.23)); //0
//		assertEquals(0,g.addEdge(3,1,31.31)); //0
//		assertEquals(0,g.addEdge(3,2,32.32)); //0
//		assertEquals(0,g.addEdge(3,3,33.33)); //0
//		assertEquals(-4,g.addEdge(1,1,11.11)); //-4
//		assertEquals(-4,g.addEdge(1,2,12.12)); //-4
//		assertEquals(-4,g.addEdge(1,3,13.13)); //-4
//		assertEquals(-4,g.addEdge(2,1,21.21)); //-4
//		assertEquals(-4,g.addEdge(2,2,22.22)); //-4
//		assertEquals(-4,g.addEdge(2,3,23.23)); //-4
//		assertEquals(-4,g.addEdge(3,1,31.31)); //-4
//		assertEquals(-4,g.addEdge(3,2,32.32)); //-4
//		assertEquals(-4,g.addEdge(3,3,33.33)); //-4
//		g.getEdge(1,1,11.11); //11.11
//		g.getEdge(1,2,12.12); //12.12
//		g.getEdge(1,3,13.13); //13.129999999999999
//		g.getEdge(2,1,21.21); //21.21
//		g.getEdge(2,2,22.22); //22.22
//		g.getEdge(2,3,23.23); //23.23
//		g.getEdge(3,1,31.31); //31.310000000000002
//		g.getEdge(3,2,32.32); //32.32
//		g.getEdge(3,3,33.33); //33.33
//	}
	
	@Test
	public void basicEvolutionTest() {
		1 g.existsNode(1): //false
		2 g.existsNode(2): false
		3 g.addNode(1): 0
		4 g.addNode(2): 0
		5 g.existsNode(1): true
		6 g.existsNode(2): true
		7 g.addNode(1): -1
		8 g.addNode(2): -1
		9 g.addEdge(1,2, 1.2): 0
		10 g.addEdge(2,1, 2.1): 0
		11 g.addEdge(1,1, 1.1): 0
		12 g.getEdge(1,2): 1.2
		13 g.getEdge(2,1): 2.1
		14 g.getEdge(1,1): 1.1
		15 g.getEdge(2,3): -2.0
		16 g.existsEdge(1,2): true
		17 g.existsEdge(2,1): true
		18 g.existsEdge(1,1): true
		19 g.existsEdge(2,2): false
		20 g.removeEdge(2,2): -4
		21 g.addEdge(2,2,2.2): 0
		22 g.getEdge(2,2): 2.2
		23 g.existsEdge(2,2): true
		24 g.removeEdge(2,2): 0
		25 g.removeNode(3): -1
		26 g.addNode(3): 0
		27 g.addNode(4): -2
		28 g.getEdge(1, 3): -4.0
		29 g.addEdge(1,3, 1.3): 0
		30 g.existsEdge(1, 3): //true----------------(false)
		31 g.getEdge(1, 3): 1.3
		32 g.getEdge(1, 4): -2.0
		33 g.getEdge(5,1): -1.0
		34 g.getEdge(5,4): -3.0
		35 g.removeNode(3): 0
		36 g.removeNode(3): //0----------------(-1)
		37 g.existsEdge(1, 3): true
		38 g.getEdge(1, 3): //1.3-------------------(-2.0)
		39 g.removeNode(2): 0
		40 g.removeNode(2): //0---------------------(-1)
		41 g.existsEdge(1, 1): true
		42 g.removeNode(1): 0
		43 g.existsNode(1): //true----------------------(false)
		44 g.existsNode(2): true
		45 g.existsNode(3): true
		46 g.existsNode(4): false
		47 g.addNode(4): 0
		48 g.existsNode(4): true
		49 g.addEdge(4,4, 4.4): 0
		50 g.existsEdge(4, 4): //true--------------------(false
		51 g.getEdge(4, 4): 4.4
		52 g.removeNode(4): 0
		53 g.removeNode(4): 0
		54 g.existsEdge(4, 4): true
		55 g.addNode(7): 0
		56 g.removeNode(2): 0
		57 g.removeNode(3): 0
		58 g.removeNode(4): -1
		59 g.existsEdge(7, 7): false
		60 g.addEdge(7,7, 7.7): 0
		61 g.addEdge(7,7, 17.17): -4
		62 g.getEdge(7, 7): 7.7
		63 g.addNode(8): 0
		64 g.addNode(9): 0
		65 g.existsEdge(7, 8): false
		66 g.existsEdge(8, 7): false
		67 g.existsEdge(8, 8): false
		68 g.existsEdge(8, 9): true
		69 g.existsEdge(9, 8): true
		70 g.existsEdge(9, 9): false
		71 g.addEdge(7,8, 7.8): 0
		72 g.addEdge(8,7, 8.7): 0
		73 g.addEdge(8,8, 8.8): 0
		74 g.addEdge(8,9, 8.9): -4
		75 g.addEdge(9,8, 9.8): -4
		76 g.addEdge(9,9, 9.9): 0
		77 g.addEdge(7,9, 7.9): 0
		78 g.addEdge(9,7, 9.7): 0
		79 g.getEdge(7, 7) --> -4.0
		80 g.getEdge(7, 8) --> 7.8
		81 g.getEdge(7, 9) --> 7.9
		82 g.getEdge(8, 7) --> 8.7
		83 g.getEdge(8, 8) --> 8.8
		84 g.getEdge(8, 9) --> 1.2
		85 g.getEdge(9, 7) --> 9.7
		86 g.getEdge(9, 8) --> 2.1
		87 g.getEdge(9, 9) --> 9.9
		88 g.removeNode(7): 0
		89 g.removeNode(7): 0
		90 g.getEdge(7, 7) --> -4.0
		91 g.getEdge(7, 8) --> 7.8
		92 g.getEdge(7, 9) --> 7.9
		93 g.getEdge(8, 7) --> 8.7
		94 g.getEdge(8, 8) --> 8.8
		95 g.getEdge(8, 9) --> 1.2
		96 g.getEdge(9, 7) --> 9.7
		97 g.getEdge(9, 8) --> 2.1
		98 g.getEdge(9, 9) --> 9.9
		99 g.removeNode(null): -1
		100 g.addNode(null): -4
		101 g.addNode(10): 0
		102 g.getEdge(8, 10) --> 8.7
		103 g.getEdge(10, 9) --> 7.9
		104 g.addNode(null): -6
		105 g.addEdge(8,8,-8.8): -12
		106 g.addEdge(7,8,-7.8): -9
		107 g.addEdge(8,7,-8.7): -10
		108 g.addEdge(7,7,-7.7): -11
		109 g.addEdge(null,8,0.8): -1
		110 g.addEdge(8,null,0.8): -2
		111 g.addEdge(null,null,0.8): -3
		112 g.getEdge(null,10): -1.0
		113 g.getEdge(10,null): -2.0
		114 g.getEdge(null,null): -3.0
		115 g.existsNode(null): false
		116 g.existsEdge(null,null): false
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-10-06 01:00:02.987
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-10-06 01:00:02.988
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-10-06 01:00:03.028
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package p2Grafos;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import org.junit.Test;

/**
 * Titulo: Clase GraphTests
 * 
 * @author UO281847
 * @version 24/09/2021
 */
public class GraphTests {
	private Graph<Integer> g;
///*
// * Pruebas del método addNode:	
// */
//	/**
//	 * Test del método addNode sin errores
//	 */
//	@Test
//	public void testAddNodeFirst() {
//		Graph<Integer> g = new Graph<Integer>(3);
//		int node = 12;
//		assertEquals(0, g.addNode(node));
//		System.out.println(g.toString());	
//	}	
//	/**
//	 * Test del método addNode con nodo no valido
//	 */
//	@Test
//	public void testAddNodeNotValid() {
//		Graph<Integer> g = new Graph<Integer>(3);
//		int node = 1;
//		int node2 = 18;
//		assertEquals(0, g.addNode(node));
//		assertEquals(0, g.addNode(node2));
//		assertEquals(-5, g.addNode(null));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addNode cuando ya esta lleno
//	 */
//	@Test
//	public void testAddNodeFull() {
//		Graph<Integer> g = new Graph<Integer>(3);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 39;
//		int node4= 2;
//		assertEquals(0, g.addNode(node));
//		assertEquals(0, g.addNode(node2));
//		assertEquals(0, g.addNode(node3));
//		assertEquals(-2, g.addNode(node4));		
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addNode cuando ya existe
//	 */
//	@Test
//	public void testAddNodeAlreadyExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 39;
//		int node4 = 19;
//		int node5= 19;
//		assertEquals(0, g.addNode(node));
//		assertEquals(0, g.addNode(node2));
//		assertEquals(0, g.addNode(node3));
//		assertEquals(0, g.addNode(node4));
//		assertEquals(-1, g.addNode(node5));	
//		System.out.println(g.toString());	
//	}
//	
///*
// * Pruebas del método getNode:
// */
//	/**
//	 * Test del método getNode que devuelve la posición
//	 */
//	@Test
//	public void testGetNodeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		g.addNode(node);
//		assertEquals(0, g.getNode(node));
//	}
//	/**
//	 * Test del método getNode que devuelve la posición ya añadido
//	 */
//	@Test
//	public void testGetNodeVarious() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 23;
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(1, g.getNode(node2));
//	}
//	/**
//	 * Test del método getNode que devuelve -1
//	 */
//	@Test
//	public void testGetNodeDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 23;
//		g.addNode(node);
//		assertEquals(-1, g.getNode(node2));
//	}
//
///**
// * Pruebas del método existsNode:
// */
//	/**
//	 * Test del método existsNode que devuelve true
//	 */
//	@Test
//	public void testExistsNodeOne() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		g.addNode(node);
//		assertTrue(g.existsNode(node));
//	}
//	/**
//	 * Test del método existsNode que devuelve true
//	 */
//	@Test
//	public void testExistsNodeVarious() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 23;
//		g.addNode(node);
//		g.addNode(node2);
//		assertTrue(g.existsNode(node2));
//	}
//	/**
//	 * Test del método existsNode que devuelve true
//	 */
//	@Test
//	public void testExistsNodeFalse() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 23;
//		g.addNode(node);
//		assertFalse(g.existsNode(node2));
//	}
//
///*
// * Pruebas del método addEdge:
// */
//	/**
//	 * Test del método addEdge que no tiene errores
//	 */
//	@Test
//	public void testAddEdgeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;		
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(0, g.addEdge(node, node2, 12));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde no existe el nodo origen
//	 */
//	@Test
//	public void testAddEdgeSourceDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 23;
//		g.addNode(node);
//		g.addNode(node2);		
//		assertEquals(-1, g.addEdge(node3, node2, 12));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde no existe el nodo destino
//	 */
//	@Test
//	public void testAddEdgeTargetDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 23;
//		g.addNode(node);
//		g.addNode(node2);		
//		assertEquals(-2, g.addEdge(node, node3, 12));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde ya existe la arista
//	 */
//	@Test
//	public void testAddEdgeEdgeExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 12);
//		assertEquals(-4, g.addEdge(node, node2, 12));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde el peso no es valido
//	 */
//	@Test
//	public void testAddEdgeEdgeWightError() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(-8, g.addEdge(node, node2, -4));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde no existen los nodos 
//	 */
//	@Test
//	public void testAddEdgeSourceTargetError() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 12;
//		int node4 = 56;
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(-3, g.addEdge(node3, node4, 4));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde ya existe la arista y el peso no es valido
//	 */
//	@Test
//	public void testAddEdgeEdgeExistsEdgeWeightError() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-12, g.addEdge(node, node2, -4));
//		System.out.println(g.toString());	
//	}
//	
///*
// * Pruebas del método getEdge:
// */
//	/**
//	 * Test del método getEdge que no tiene errores
//	 */
//	@Test
//	public void testGetEdgeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(4, g.getEdge(node, node2),0.1);
//	}
//	/**
//	 * Test del método getEdge donde no existe el nodo origen
//	 */
//	@Test
//	public void testGetEdgeSourceDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 4;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-1, g.getEdge(node3, node2),0.1);
//	}
//	/**
//	 * Test del método getEdge donde no existe el nodo destino
//	 */
//	@Test
//	public void testGetEdgeTargetDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 4;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-2, g.getEdge(node, node3),0.1);
//	}
//	/**
//	 * Test del método getEdge donde existen los nodos y no la arista
//	 */
//	@Test
//	public void testGetEdgeEdgeDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(-4, g.getEdge(node, node2),0.1);
//	}
//	/**
//	 * Test del método getEdge donde no existen los nodos
//	 */
//	@Test
//	public void testGetEdgeBothDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 4;
//		int node4 = 6;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-3, g.getEdge(node3, node4),0.1);
//	}
//	
///*
// * Pruebas del método existsEdge:
// */
//	/**
//	 * Test del método existsEdge que no tiene errores
//	 */
//	@Test
//	public void testExistsEdgeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertTrue(g.existsEdge(node, node2));
//	}
//	/**
//	 * Test del método existsEdge donde no existe el nodo origen
//	 */
//	@Test
//	public void testExistsEdgeSourceDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3= 8;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertFalse(g.existsEdge(node3, node2));
//	}
//	/**
//	 * Test del método existsEdge donde no existe el nodo destino
//	 */
//	@Test
//	public void testExistsEdgeTargetDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3= 8;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertFalse(g.existsEdge(node, node3));
//	}
//	/**
//	 * Test del método existsEdge donde no existen los nodos
//	 */
//	@Test
//	public void testExistsEdgeBothDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		int node4 = 12;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertFalse(g.existsEdge(node3, node4));
//	}
//	
///*
// * Pruebas del método removeEdge:
// */
//	/**
//	 * Test del método removeEdge que no tiene errores 
//	 */
//	@Test
//	public void testRemoveEdgeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		int node4 = 12;
//		g.addNode(node);
//		g.addNode(node2); 
//		g.addNode(node3);
//		g.addNode(node4);
//		g.addEdge(node, node2, 4);
//		g.addEdge(node3, node4, 12);
//		assertEquals(0, g.removeEdge(node3, node4));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeEdge donde no existe el nodo origen
//	 */
//	@Test
//	public void testRemoveEdgeSourceDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		g.addNode(node);
//		g.addNode(node2); 
//		g.addEdge(node, node2, 4);
//		assertEquals(-1, g.removeEdge(node3, node2));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeEdge donde no existe el nodo destino
//	 */
//	@Test
//	public void testRemoveEdgeTargetDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		g.addNode(node);
//		g.addNode(node2); 
//		g.addEdge(node, node2, 4);
//		assertEquals(-2, g.removeEdge(node2, node3));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeEdge donde existen los nodos y no la arista
//	 */
//	@Test
//	public void testRemoveEdgeEdgeDontExistsNodesExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2); 
//		g.addEdge(node, node2, 4);
//		assertEquals(-4, g.removeEdge(node2, node));
//		System.out.println(g.toString());
//	}	
//	/**
//	 * Test del método removeEdge donde no existen los nodos
//	 */
//	@Test
//	public void testRemoveEdgeNodesDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		int node4 = 12;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-3, g.removeEdge(node3, node4));
//		System.out.println(g.toString());
//	}
///*
// * Pruebas del método removeNode:
// */
//	/**
//	 * Test del método removeNode que no tiene errores
//	 */
//	@Test
//	public void testRemoveNodeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;		
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(0, g.removeNode(node));
//		assertFalse(g.existsNode(node));
//		assertFalse(g.existsEdge(node, node2));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeNode que no tiene errores y borra toda la matriz
//	 */
//	@Test
//	public void testRemoveNodeVarious() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		int node4 = 12;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		g.addEdge(node, node, 12);
//		g.addEdge(node3, node, 7);
//		g.addEdge(node, node4, 15);
//		g.addEdge(node, node3, 9);
//		assertEquals(0, g.removeNode(node));
//		assertFalse(g.existsNode(node));
//		assertFalse(g.existsEdge(node, node2));
//		assertFalse(g.existsEdge(node, node));
//		assertFalse(g.existsEdge(node3, node));
//		assertFalse(g.existsEdge(node, node4));
//		assertFalse(g.existsEdge(node, node3));
//		System.out.println(g.toString());
//	}	
//	/**
//	 * Test del método removeNode donde el nodo no es valido
//	 */
//	@Test
//	public void testRemoveNodeNotValid() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;		
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-1, g.removeNode(null));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeNode donde el nodo no existe
//	 */
//	@Test
//	public void testRemoveNodeDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 12;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-1, g.removeNode(node3));
//		System.out.println(g.toString());
//	}
	/**
	 * Pruebas basicas de nodos
	 */
//	@Test
//	public void basicNodeTest() {
//		g=new Graph<Integer>(3); 
//	    assertFalse(g.existsNode(1)); //false
//	    assertFalse(g.existsNode(2)); //false
//	    assertEquals(0,g.addNode(1)); //0
//		assertEquals(0,g.addNode(2)); //0
//		assertTrue(g.existsNode(1)); //true
//		assertTrue(g.existsNode(2)); //true
//		assertEquals(-1,g.addNode(1)); //-1
//		assertEquals(-1,g.addNode(2)); //-1
//		assertEquals(0,g.addNode(3)); //0
//		assertEquals(-2,g.addNode(4)); //-2
//		assertFalse(g.existsNode(4)); //false
//		assertFalse(g.existsNode(5)); //false
//	}
	
//	@Test
//	public void basicEdgeTest() {
//		g=new Graph<Integer>(3); 
//		assertFalse(g.existsEdge(1,2)); //false
//		assertEquals(-3.0,g.getEdge(1,2),0.1); //-3.0
//		assertEquals(0,g.addNode(1)); //0
//		assertFalse(g.existsEdge(1,2)); //false
//		assertEquals(-2.0,g.getEdge(1,2),0.1); //-2.0
//		assertFalse(g.existsEdge(2,1)); //false
//		assertEquals(-1.0,g.getEdge(2,1),0.1); //-1.0
//		assertEquals(0,g.addNode(2)); //0
//		assertFalse(g.existsEdge(1,2)); //false
//		assertEquals(-4.0,g.getEdge(1,2),0.1); //-4.0
//		assertEquals(0,g.addEdge(1,2,12.12)); //0
//		assertEquals(-4,g.addEdge(1,2,12.1212)); //-4
//		assertEquals(0,g.addNode(3)); //0
//		assertFalse(g.existsEdge(1,3)); //false
//		assertFalse(g.existsEdge(3,2)); //false
//		assertEquals(-4.0,g.getEdge(1,3),0.1); //-4.0
//		assertEquals(-4.0,g.getEdge(3,2),0.1); //-4.0
//		assertEquals(0,g.addEdge(1,1,11.11)); //0
//		assertEquals(-4,g.addEdge(1,2,12.12)); //-4
//		assertEquals(0,g.addEdge(1,3,13.13)); //0
//		assertEquals(0,g.addEdge(2,1,21.21)); //0
//		assertEquals(0,g.addEdge(2,2,22.22)); //0
//		assertEquals(0,g.addEdge(2,3,23.23)); //0
//		assertEquals(0,g.addEdge(3,1,31.31)); //0
//		assertEquals(0,g.addEdge(3,2,32.32)); //0
//		assertEquals(0,g.addEdge(3,3,33.33)); //0
//		assertEquals(-4,g.addEdge(1,1,11.11)); //-4
//		assertEquals(-4,g.addEdge(1,2,12.12)); //-4
//		assertEquals(-4,g.addEdge(1,3,13.13)); //-4
//		assertEquals(-4,g.addEdge(2,1,21.21)); //-4
//		assertEquals(-4,g.addEdge(2,2,22.22)); //-4
//		assertEquals(-4,g.addEdge(2,3,23.23)); //-4
//		assertEquals(-4,g.addEdge(3,1,31.31)); //-4
//		assertEquals(-4,g.addEdge(3,2,32.32)); //-4
//		assertEquals(-4,g.addEdge(3,3,33.33)); //-4
//		g.getEdge(1,1,11.11); //11.11
//		g.getEdge(1,2,12.12); //12.12
//		g.getEdge(1,3,13.13); //13.129999999999999
//		g.getEdge(2,1,21.21); //21.21
//		g.getEdge(2,2,22.22); //22.22
//		g.getEdge(2,3,23.23); //23.23
//		g.getEdge(3,1,31.31); //31.310000000000002
//		g.getEdge(3,2,32.32); //32.32
//		g.getEdge(3,3,33.33); //33.33
//	}
	
	@Test
	public void basicEvolutionTest() {
		1 g.existsNode(1): //false
		2 g.existsNode(2): false
		3 g.addNode(1): 0
		4 g.addNode(2): 0
		5 g.existsNode(1): true
		6 g.existsNode(2): true
		7 g.addNode(1): -1
		8 g.addNode(2): -1
		9 g.addEdge(1,2, 1.2): 0
		10 g.addEdge(2,1, 2.1): 0
		11 g.addEdge(1,1, 1.1): 0
		12 g.getEdge(1,2): 1.2
		13 g.getEdge(2,1): 2.1
		14 g.getEdge(1,1): 1.1
		15 g.getEdge(2,3): -2.0
		16 g.existsEdge(1,2): true
		17 g.existsEdge(2,1): true
		18 g.existsEdge(1,1): true
		19 g.existsEdge(2,2): false
		20 g.removeEdge(2,2): -4
		21 g.addEdge(2,2,2.2): 0
		22 g.getEdge(2,2): 2.2
		23 g.existsEdge(2,2): true
		24 g.removeEdge(2,2): 0
		25 g.removeNode(3): -1
		26 g.addNode(3): 0
		27 g.addNode(4): -2
		28 g.getEdge(1, 3): -4.0
		29 g.addEdge(1,3, 1.3): 0
		30 g.existsEdge(1, 3): //true----------------(false)
		31 g.getEdge(1, 3): 1.3
		32 g.getEdge(1, 4): -2.0
		33 g.getEdge(5,1): -1.0
		34 g.getEdge(5,4): -3.0
		35 g.removeNode(3): 0
		36 g.removeNode(3): //0----------------(-1)
		37 g.existsEdge(1, 3): true
		38 g.getEdge(1, 3): //1.3-------------------(-2.0)
		39 g.removeNode(2): 0
		40 g.removeNode(2): //0---------------------(-1)
		41 g.existsEdge(1, 1): true
		42 g.removeNode(1): 0
		43 g.existsNode(1): //true----------------------(false)
		44 g.existsNode(2): true
		45 g.existsNode(3): true
		46 g.existsNode(4): false
		47 g.addNode(4): 0
		48 g.existsNode(4): true
		49 g.addEdge(4,4, 4.4): 0
		50 g.existsEdge(4, 4): //true--------------------(false
		51 g.getEdge(4, 4): 4.4
		52 g.removeNode(4): 0
		53 g.removeNode(4): 0
		54 g.existsEdge(4, 4): true
		55 g.addNode(7): 0
		56 g.removeNode(2): 0
		57 g.removeNode(3): 0
		58 g.removeNode(4): -1
		59 g.existsEdge(7, 7): false
		60 g.addEdge(7,7, 7.7): 0
		61 g.addEdge(7,7, 17.17): -4
		62 g.getEdge(7, 7): 7.7
		63 g.addNode(8): 0
		64 g.addNode(9): 0
		65 g.existsEdge(7, 8): false
		66 g.existsEdge(8, 7): false
		67 g.existsEdge(8, 8): false
		68 g.existsEdge(8, 9): true
		69 g.existsEdge(9, 8): true
		70 g.existsEdge(9, 9): false
		71 g.addEdge(7,8, 7.8): 0
		72 g.addEdge(8,7, 8.7): 0
		73 g.addEdge(8,8, 8.8): 0
		74 g.addEdge(8,9, 8.9): -4
		75 g.addEdge(9,8, 9.8): -4
		76 g.addEdge(9,9, 9.9): 0
		77 g.addEdge(7,9, 7.9): 0
		78 g.addEdge(9,7, 9.7): 0
		79 g.getEdge(7, 7) --> -4.0
		80 g.getEdge(7, 8) --> 7.8
		81 g.getEdge(7, 9) --> 7.9
		82 g.getEdge(8, 7) --> 8.7
		83 g.getEdge(8, 8) --> 8.8
		84 g.getEdge(8, 9) --> 1.2
		85 g.getEdge(9, 7) --> 9.7
		86 g.getEdge(9, 8) --> 2.1
		87 g.getEdge(9, 9) --> 9.9
		88 g.removeNode(7): 0
		89 g.removeNode(7): 0
		90 g.getEdge(7, 7) --> -4.0
		91 g.getEdge(7, 8) --> 7.8
		92 g.getEdge(7, 9) --> 7.9
		93 g.getEdge(8, 7) --> 8.7
		94 g.getEdge(8, 8) --> 8.8
		95 g.getEdge(8, 9) --> 1.2
		96 g.getEdge(9, 7) --> 9.7
		97 g.getEdge(9, 8) --> 2.1
		98 g.getEdge(9, 9) --> 9.9
		99 g.removeNode(null): -1
		100 g.addNode(null): -4
		101 g.addNode(10): 0
		102 g.getEdge(8, 10) --> 8.7
		103 g.getEdge(10, 9) --> 7.9
		104 g.addNode(null): -6
		105 g.addEdge(8,8,-8.8): -12
		106 g.addEdge(7,8,-7.8): -9
		107 g.addEdge(8,7,-8.7): -10
		108 g.addEdge(7,7,-7.7): -11
		109 g.addEdge(null,8,0.8): -1
		110 g.addEdge(8,null,0.8): -2
		111 g.addEdge(null,null,0.8): -3
		112 g.getEdge(null,10): -1.0
		113 g.getEdge(10,null): -2.0
		114 g.getEdge(null,null): -3.0
		115 g.existsNode(null): false
		116 g.existsEdge(null,null): false
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-10-06 01:00:03.030
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-10-06 01:00:03.032
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-10-06 01:00:09.529
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package p2Grafos;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import org.junit.Test;

/**
 * Titulo: Clase GraphTests
 * 
 * @author UO281847
 * @version 24/09/2021
 */
public class GraphTests {
	private Graph<Integer> g;
///*
// * Pruebas del método addNode:	
// */
//	/**
//	 * Test del método addNode sin errores
//	 */
//	@Test
//	public void testAddNodeFirst() {
//		Graph<Integer> g = new Graph<Integer>(3);
//		int node = 12;
//		assertEquals(0, g.addNode(node));
//		System.out.println(g.toString());	
//	}	
//	/**
//	 * Test del método addNode con nodo no valido
//	 */
//	@Test
//	public void testAddNodeNotValid() {
//		Graph<Integer> g = new Graph<Integer>(3);
//		int node = 1;
//		int node2 = 18;
//		assertEquals(0, g.addNode(node));
//		assertEquals(0, g.addNode(node2));
//		assertEquals(-5, g.addNode(null));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addNode cuando ya esta lleno
//	 */
//	@Test
//	public void testAddNodeFull() {
//		Graph<Integer> g = new Graph<Integer>(3);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 39;
//		int node4= 2;
//		assertEquals(0, g.addNode(node));
//		assertEquals(0, g.addNode(node2));
//		assertEquals(0, g.addNode(node3));
//		assertEquals(-2, g.addNode(node4));		
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addNode cuando ya existe
//	 */
//	@Test
//	public void testAddNodeAlreadyExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 39;
//		int node4 = 19;
//		int node5= 19;
//		assertEquals(0, g.addNode(node));
//		assertEquals(0, g.addNode(node2));
//		assertEquals(0, g.addNode(node3));
//		assertEquals(0, g.addNode(node4));
//		assertEquals(-1, g.addNode(node5));	
//		System.out.println(g.toString());	
//	}
//	
///*
// * Pruebas del método getNode:
// */
//	/**
//	 * Test del método getNode que devuelve la posición
//	 */
//	@Test
//	public void testGetNodeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		g.addNode(node);
//		assertEquals(0, g.getNode(node));
//	}
//	/**
//	 * Test del método getNode que devuelve la posición ya añadido
//	 */
//	@Test
//	public void testGetNodeVarious() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 23;
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(1, g.getNode(node2));
//	}
//	/**
//	 * Test del método getNode que devuelve -1
//	 */
//	@Test
//	public void testGetNodeDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 23;
//		g.addNode(node);
//		assertEquals(-1, g.getNode(node2));
//	}
//
///**
// * Pruebas del método existsNode:
// */
//	/**
//	 * Test del método existsNode que devuelve true
//	 */
//	@Test
//	public void testExistsNodeOne() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		g.addNode(node);
//		assertTrue(g.existsNode(node));
//	}
//	/**
//	 * Test del método existsNode que devuelve true
//	 */
//	@Test
//	public void testExistsNodeVarious() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 23;
//		g.addNode(node);
//		g.addNode(node2);
//		assertTrue(g.existsNode(node2));
//	}
//	/**
//	 * Test del método existsNode que devuelve true
//	 */
//	@Test
//	public void testExistsNodeFalse() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 23;
//		g.addNode(node);
//		assertFalse(g.existsNode(node2));
//	}
//
///*
// * Pruebas del método addEdge:
// */
//	/**
//	 * Test del método addEdge que no tiene errores
//	 */
//	@Test
//	public void testAddEdgeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;		
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(0, g.addEdge(node, node2, 12));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde no existe el nodo origen
//	 */
//	@Test
//	public void testAddEdgeSourceDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 23;
//		g.addNode(node);
//		g.addNode(node2);		
//		assertEquals(-1, g.addEdge(node3, node2, 12));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde no existe el nodo destino
//	 */
//	@Test
//	public void testAddEdgeTargetDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 23;
//		g.addNode(node);
//		g.addNode(node2);		
//		assertEquals(-2, g.addEdge(node, node3, 12));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde ya existe la arista
//	 */
//	@Test
//	public void testAddEdgeEdgeExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 12);
//		assertEquals(-4, g.addEdge(node, node2, 12));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde el peso no es valido
//	 */
//	@Test
//	public void testAddEdgeEdgeWightError() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(-8, g.addEdge(node, node2, -4));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde no existen los nodos 
//	 */
//	@Test
//	public void testAddEdgeSourceTargetError() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 12;
//		int node4 = 56;
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(-3, g.addEdge(node3, node4, 4));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde ya existe la arista y el peso no es valido
//	 */
//	@Test
//	public void testAddEdgeEdgeExistsEdgeWeightError() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-12, g.addEdge(node, node2, -4));
//		System.out.println(g.toString());	
//	}
//	
///*
// * Pruebas del método getEdge:
// */
//	/**
//	 * Test del método getEdge que no tiene errores
//	 */
//	@Test
//	public void testGetEdgeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(4, g.getEdge(node, node2),0.1);
//	}
//	/**
//	 * Test del método getEdge donde no existe el nodo origen
//	 */
//	@Test
//	public void testGetEdgeSourceDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 4;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-1, g.getEdge(node3, node2),0.1);
//	}
//	/**
//	 * Test del método getEdge donde no existe el nodo destino
//	 */
//	@Test
//	public void testGetEdgeTargetDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 4;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-2, g.getEdge(node, node3),0.1);
//	}
//	/**
//	 * Test del método getEdge donde existen los nodos y no la arista
//	 */
//	@Test
//	public void testGetEdgeEdgeDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(-4, g.getEdge(node, node2),0.1);
//	}
//	/**
//	 * Test del método getEdge donde no existen los nodos
//	 */
//	@Test
//	public void testGetEdgeBothDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 4;
//		int node4 = 6;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-3, g.getEdge(node3, node4),0.1);
//	}
//	
///*
// * Pruebas del método existsEdge:
// */
//	/**
//	 * Test del método existsEdge que no tiene errores
//	 */
//	@Test
//	public void testExistsEdgeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertTrue(g.existsEdge(node, node2));
//	}
//	/**
//	 * Test del método existsEdge donde no existe el nodo origen
//	 */
//	@Test
//	public void testExistsEdgeSourceDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3= 8;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertFalse(g.existsEdge(node3, node2));
//	}
//	/**
//	 * Test del método existsEdge donde no existe el nodo destino
//	 */
//	@Test
//	public void testExistsEdgeTargetDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3= 8;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertFalse(g.existsEdge(node, node3));
//	}
//	/**
//	 * Test del método existsEdge donde no existen los nodos
//	 */
//	@Test
//	public void testExistsEdgeBothDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		int node4 = 12;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertFalse(g.existsEdge(node3, node4));
//	}
//	
///*
// * Pruebas del método removeEdge:
// */
//	/**
//	 * Test del método removeEdge que no tiene errores 
//	 */
//	@Test
//	public void testRemoveEdgeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		int node4 = 12;
//		g.addNode(node);
//		g.addNode(node2); 
//		g.addNode(node3);
//		g.addNode(node4);
//		g.addEdge(node, node2, 4);
//		g.addEdge(node3, node4, 12);
//		assertEquals(0, g.removeEdge(node3, node4));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeEdge donde no existe el nodo origen
//	 */
//	@Test
//	public void testRemoveEdgeSourceDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		g.addNode(node);
//		g.addNode(node2); 
//		g.addEdge(node, node2, 4);
//		assertEquals(-1, g.removeEdge(node3, node2));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeEdge donde no existe el nodo destino
//	 */
//	@Test
//	public void testRemoveEdgeTargetDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		g.addNode(node);
//		g.addNode(node2); 
//		g.addEdge(node, node2, 4);
//		assertEquals(-2, g.removeEdge(node2, node3));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeEdge donde existen los nodos y no la arista
//	 */
//	@Test
//	public void testRemoveEdgeEdgeDontExistsNodesExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2); 
//		g.addEdge(node, node2, 4);
//		assertEquals(-4, g.removeEdge(node2, node));
//		System.out.println(g.toString());
//	}	
//	/**
//	 * Test del método removeEdge donde no existen los nodos
//	 */
//	@Test
//	public void testRemoveEdgeNodesDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		int node4 = 12;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-3, g.removeEdge(node3, node4));
//		System.out.println(g.toString());
//	}
///*
// * Pruebas del método removeNode:
// */
//	/**
//	 * Test del método removeNode que no tiene errores
//	 */
//	@Test
//	public void testRemoveNodeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;		
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(0, g.removeNode(node));
//		assertFalse(g.existsNode(node));
//		assertFalse(g.existsEdge(node, node2));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeNode que no tiene errores y borra toda la matriz
//	 */
//	@Test
//	public void testRemoveNodeVarious() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		int node4 = 12;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		g.addEdge(node, node, 12);
//		g.addEdge(node3, node, 7);
//		g.addEdge(node, node4, 15);
//		g.addEdge(node, node3, 9);
//		assertEquals(0, g.removeNode(node));
//		assertFalse(g.existsNode(node));
//		assertFalse(g.existsEdge(node, node2));
//		assertFalse(g.existsEdge(node, node));
//		assertFalse(g.existsEdge(node3, node));
//		assertFalse(g.existsEdge(node, node4));
//		assertFalse(g.existsEdge(node, node3));
//		System.out.println(g.toString());
//	}	
//	/**
//	 * Test del método removeNode donde el nodo no es valido
//	 */
//	@Test
//	public void testRemoveNodeNotValid() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;		
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-1, g.removeNode(null));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeNode donde el nodo no existe
//	 */
//	@Test
//	public void testRemoveNodeDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 12;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-1, g.removeNode(node3));
//		System.out.println(g.toString());
//	}
	/**
	 * Pruebas basicas de nodos
	 */
//	@Test
//	public void basicNodeTest() {
//		g=new Graph<Integer>(3); 
//	    assertFalse(g.existsNode(1)); //false
//	    assertFalse(g.existsNode(2)); //false
//	    assertEquals(0,g.addNode(1)); //0
//		assertEquals(0,g.addNode(2)); //0
//		assertTrue(g.existsNode(1)); //true
//		assertTrue(g.existsNode(2)); //true
//		assertEquals(-1,g.addNode(1)); //-1
//		assertEquals(-1,g.addNode(2)); //-1
//		assertEquals(0,g.addNode(3)); //0
//		assertEquals(-2,g.addNode(4)); //-2
//		assertFalse(g.existsNode(4)); //false
//		assertFalse(g.existsNode(5)); //false
//	}
	
//	@Test
//	public void basicEdgeTest() {
//		g=new Graph<Integer>(3); 
//		assertFalse(g.existsEdge(1,2)); //false
//		assertEquals(-3.0,g.getEdge(1,2),0.1); //-3.0
//		assertEquals(0,g.addNode(1)); //0
//		assertFalse(g.existsEdge(1,2)); //false
//		assertEquals(-2.0,g.getEdge(1,2),0.1); //-2.0
//		assertFalse(g.existsEdge(2,1)); //false
//		assertEquals(-1.0,g.getEdge(2,1),0.1); //-1.0
//		assertEquals(0,g.addNode(2)); //0
//		assertFalse(g.existsEdge(1,2)); //false
//		assertEquals(-4.0,g.getEdge(1,2),0.1); //-4.0
//		assertEquals(0,g.addEdge(1,2,12.12)); //0
//		assertEquals(-4,g.addEdge(1,2,12.1212)); //-4
//		assertEquals(0,g.addNode(3)); //0
//		assertFalse(g.existsEdge(1,3)); //false
//		assertFalse(g.existsEdge(3,2)); //false
//		assertEquals(-4.0,g.getEdge(1,3),0.1); //-4.0
//		assertEquals(-4.0,g.getEdge(3,2),0.1); //-4.0
//		assertEquals(0,g.addEdge(1,1,11.11)); //0
//		assertEquals(-4,g.addEdge(1,2,12.12)); //-4
//		assertEquals(0,g.addEdge(1,3,13.13)); //0
//		assertEquals(0,g.addEdge(2,1,21.21)); //0
//		assertEquals(0,g.addEdge(2,2,22.22)); //0
//		assertEquals(0,g.addEdge(2,3,23.23)); //0
//		assertEquals(0,g.addEdge(3,1,31.31)); //0
//		assertEquals(0,g.addEdge(3,2,32.32)); //0
//		assertEquals(0,g.addEdge(3,3,33.33)); //0
//		assertEquals(-4,g.addEdge(1,1,11.11)); //-4
//		assertEquals(-4,g.addEdge(1,2,12.12)); //-4
//		assertEquals(-4,g.addEdge(1,3,13.13)); //-4
//		assertEquals(-4,g.addEdge(2,1,21.21)); //-4
//		assertEquals(-4,g.addEdge(2,2,22.22)); //-4
//		assertEquals(-4,g.addEdge(2,3,23.23)); //-4
//		assertEquals(-4,g.addEdge(3,1,31.31)); //-4
//		assertEquals(-4,g.addEdge(3,2,32.32)); //-4
//		assertEquals(-4,g.addEdge(3,3,33.33)); //-4
//		g.getEdge(1,1,11.11); //11.11
//		g.getEdge(1,2,12.12); //12.12
//		g.getEdge(1,3,13.13); //13.129999999999999
//		g.getEdge(2,1,21.21); //21.21
//		g.getEdge(2,2,22.22); //22.22
//		g.getEdge(2,3,23.23); //23.23
//		g.getEdge(3,1,31.31); //31.310000000000002
//		g.getEdge(3,2,32.32); //32.32
//		g.getEdge(3,3,33.33); //33.33
//	}
	
	@Test
	public void basicEvolutionTest() {
		1 g.existsNode(1): //false
		2 g.existsNode(2): false
		3 g.addNode(1): 0
		4 g.addNode(2): 0
		5 g.existsNode(1): true
		6 g.existsNode(2): true
		7 g.addNode(1): -1
		8 g.addNode(2): -1
		9 g.addEdge(1,2, 1.2): 0
		10 g.addEdge(2,1, 2.1): 0
		11 g.addEdge(1,1, 1.1): 0
		12 g.getEdge(1,2): 1.2
		13 g.getEdge(2,1): 2.1
		14 g.getEdge(1,1): 1.1
		15 g.getEdge(2,3): -2.0
		16 g.existsEdge(1,2): true
		17 g.existsEdge(2,1): true
		18 g.existsEdge(1,1): true
		19 g.existsEdge(2,2): false
		20 g.removeEdge(2,2): -4
		21 g.addEdge(2,2,2.2): 0
		22 g.getEdge(2,2): 2.2
		23 g.existsEdge(2,2): true
		24 g.removeEdge(2,2): 0
		25 g.removeNode(3): -1
		26 g.addNode(3): 0
		27 g.addNode(4): -2
		28 g.getEdge(1, 3): -4.0
		29 g.addEdge(1,3, 1.3): 0
		30 g.existsEdge(1, 3): //true----------------(false)
		31 g.getEdge(1, 3): 1.3
		32 g.getEdge(1, 4): -2.0
		33 g.getEdge(5,1): -1.0
		34 g.getEdge(5,4): -3.0
		35 g.removeNode(3): 0
		36 g.removeNode(3): //0----------------(-1)
		37 g.existsEdge(1, 3): true
		38 g.getEdge(1, 3): //1.3-------------------(-2.0)
		39 g.removeNode(2): 0
		40 g.removeNode(2): //0---------------------(-1)
		41 g.existsEdge(1, 1): true
		42 g.removeNode(1): 0
		43 g.existsNode(1): //true----------------------(false)
		44 g.existsNode(2): true
		45 g.existsNode(3): true
		46 g.existsNode(4): false
		47 g.addNode(4): 0
		48 g.existsNode(4): true
		49 g.addEdge(4,4, 4.4): 0
		50 g.existsEdge(4, 4): //true--------------------(false)
		51 g.getEdge(4, 4): 4.4
		52 g.removeNode(4): 0
		53 g.removeNode(4): 0
		54 g.existsEdge(4, 4): true
		55 g.addNode(7): 0
		56 g.removeNode(2): 0
		57 g.removeNode(3): 0
		58 g.removeNode(4): -1
		59 g.existsEdge(7, 7): false
		60 g.addEdge(7,7, 7.7): 0
		61 g.addEdge(7,7, 17.17): -4
		62 g.getEdge(7, 7): 7.7
		63 g.addNode(8): 0
		64 g.addNode(9): 0
		65 g.existsEdge(7, 8): false
		66 g.existsEdge(8, 7): false
		67 g.existsEdge(8, 8): false
		68 g.existsEdge(8, 9): true
		69 g.existsEdge(9, 8): true
		70 g.existsEdge(9, 9): false
		71 g.addEdge(7,8, 7.8): 0
		72 g.addEdge(8,7, 8.7): 0
		73 g.addEdge(8,8, 8.8): 0
		74 g.addEdge(8,9, 8.9): -4
		75 g.addEdge(9,8, 9.8): -4
		76 g.addEdge(9,9, 9.9): 0
		77 g.addEdge(7,9, 7.9): 0
		78 g.addEdge(9,7, 9.7): 0
		79 g.getEdge(7, 7) --> -4.0
		80 g.getEdge(7, 8) --> 7.8
		81 g.getEdge(7, 9) --> 7.9
		82 g.getEdge(8, 7) --> 8.7
		83 g.getEdge(8, 8) --> 8.8
		84 g.getEdge(8, 9) --> 1.2
		85 g.getEdge(9, 7) --> 9.7
		86 g.getEdge(9, 8) --> 2.1
		87 g.getEdge(9, 9) --> 9.9
		88 g.removeNode(7): 0
		89 g.removeNode(7): 0
		90 g.getEdge(7, 7) --> -4.0
		91 g.getEdge(7, 8) --> 7.8
		92 g.getEdge(7, 9) --> 7.9
		93 g.getEdge(8, 7) --> 8.7
		94 g.getEdge(8, 8) --> 8.8
		95 g.getEdge(8, 9) --> 1.2
		96 g.getEdge(9, 7) --> 9.7
		97 g.getEdge(9, 8) --> 2.1
		98 g.getEdge(9, 9) --> 9.9
		99 g.removeNode(null): -1
		100 g.addNode(null): -4
		101 g.addNode(10): 0
		102 g.getEdge(8, 10) --> 8.7
		103 g.getEdge(10, 9) --> 7.9
		104 g.addNode(null): -6
		105 g.addEdge(8,8,-8.8): -12
		106 g.addEdge(7,8,-7.8): -9
		107 g.addEdge(8,7,-8.7): -10
		108 g.addEdge(7,7,-7.7): -11
		109 g.addEdge(null,8,0.8): -1
		110 g.addEdge(8,null,0.8): -2
		111 g.addEdge(null,null,0.8): -3
		112 g.getEdge(null,10): -1.0
		113 g.getEdge(10,null): -2.0
		114 g.getEdge(null,null): -3.0
		115 g.existsNode(null): false
		116 g.existsEdge(null,null): false
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-10-06 01:00:09.531
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-10-06 01:00:09.533
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-10-06 01:00:09.571
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package p2Grafos;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import org.junit.Test;

/**
 * Titulo: Clase GraphTests
 * 
 * @author UO281847
 * @version 24/09/2021
 */
public class GraphTests {
	private Graph<Integer> g;
///*
// * Pruebas del método addNode:	
// */
//	/**
//	 * Test del método addNode sin errores
//	 */
//	@Test
//	public void testAddNodeFirst() {
//		Graph<Integer> g = new Graph<Integer>(3);
//		int node = 12;
//		assertEquals(0, g.addNode(node));
//		System.out.println(g.toString());	
//	}	
//	/**
//	 * Test del método addNode con nodo no valido
//	 */
//	@Test
//	public void testAddNodeNotValid() {
//		Graph<Integer> g = new Graph<Integer>(3);
//		int node = 1;
//		int node2 = 18;
//		assertEquals(0, g.addNode(node));
//		assertEquals(0, g.addNode(node2));
//		assertEquals(-5, g.addNode(null));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addNode cuando ya esta lleno
//	 */
//	@Test
//	public void testAddNodeFull() {
//		Graph<Integer> g = new Graph<Integer>(3);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 39;
//		int node4= 2;
//		assertEquals(0, g.addNode(node));
//		assertEquals(0, g.addNode(node2));
//		assertEquals(0, g.addNode(node3));
//		assertEquals(-2, g.addNode(node4));		
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addNode cuando ya existe
//	 */
//	@Test
//	public void testAddNodeAlreadyExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 39;
//		int node4 = 19;
//		int node5= 19;
//		assertEquals(0, g.addNode(node));
//		assertEquals(0, g.addNode(node2));
//		assertEquals(0, g.addNode(node3));
//		assertEquals(0, g.addNode(node4));
//		assertEquals(-1, g.addNode(node5));	
//		System.out.println(g.toString());	
//	}
//	
///*
// * Pruebas del método getNode:
// */
//	/**
//	 * Test del método getNode que devuelve la posición
//	 */
//	@Test
//	public void testGetNodeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		g.addNode(node);
//		assertEquals(0, g.getNode(node));
//	}
//	/**
//	 * Test del método getNode que devuelve la posición ya añadido
//	 */
//	@Test
//	public void testGetNodeVarious() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 23;
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(1, g.getNode(node2));
//	}
//	/**
//	 * Test del método getNode que devuelve -1
//	 */
//	@Test
//	public void testGetNodeDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 23;
//		g.addNode(node);
//		assertEquals(-1, g.getNode(node2));
//	}
//
///**
// * Pruebas del método existsNode:
// */
//	/**
//	 * Test del método existsNode que devuelve true
//	 */
//	@Test
//	public void testExistsNodeOne() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		g.addNode(node);
//		assertTrue(g.existsNode(node));
//	}
//	/**
//	 * Test del método existsNode que devuelve true
//	 */
//	@Test
//	public void testExistsNodeVarious() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 23;
//		g.addNode(node);
//		g.addNode(node2);
//		assertTrue(g.existsNode(node2));
//	}
//	/**
//	 * Test del método existsNode que devuelve true
//	 */
//	@Test
//	public void testExistsNodeFalse() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 23;
//		g.addNode(node);
//		assertFalse(g.existsNode(node2));
//	}
//
///*
// * Pruebas del método addEdge:
// */
//	/**
//	 * Test del método addEdge que no tiene errores
//	 */
//	@Test
//	public void testAddEdgeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;		
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(0, g.addEdge(node, node2, 12));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde no existe el nodo origen
//	 */
//	@Test
//	public void testAddEdgeSourceDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 23;
//		g.addNode(node);
//		g.addNode(node2);		
//		assertEquals(-1, g.addEdge(node3, node2, 12));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde no existe el nodo destino
//	 */
//	@Test
//	public void testAddEdgeTargetDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 23;
//		g.addNode(node);
//		g.addNode(node2);		
//		assertEquals(-2, g.addEdge(node, node3, 12));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde ya existe la arista
//	 */
//	@Test
//	public void testAddEdgeEdgeExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 12);
//		assertEquals(-4, g.addEdge(node, node2, 12));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde el peso no es valido
//	 */
//	@Test
//	public void testAddEdgeEdgeWightError() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(-8, g.addEdge(node, node2, -4));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde no existen los nodos 
//	 */
//	@Test
//	public void testAddEdgeSourceTargetError() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 12;
//		int node4 = 56;
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(-3, g.addEdge(node3, node4, 4));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde ya existe la arista y el peso no es valido
//	 */
//	@Test
//	public void testAddEdgeEdgeExistsEdgeWeightError() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-12, g.addEdge(node, node2, -4));
//		System.out.println(g.toString());	
//	}
//	
///*
// * Pruebas del método getEdge:
// */
//	/**
//	 * Test del método getEdge que no tiene errores
//	 */
//	@Test
//	public void testGetEdgeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(4, g.getEdge(node, node2),0.1);
//	}
//	/**
//	 * Test del método getEdge donde no existe el nodo origen
//	 */
//	@Test
//	public void testGetEdgeSourceDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 4;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-1, g.getEdge(node3, node2),0.1);
//	}
//	/**
//	 * Test del método getEdge donde no existe el nodo destino
//	 */
//	@Test
//	public void testGetEdgeTargetDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 4;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-2, g.getEdge(node, node3),0.1);
//	}
//	/**
//	 * Test del método getEdge donde existen los nodos y no la arista
//	 */
//	@Test
//	public void testGetEdgeEdgeDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(-4, g.getEdge(node, node2),0.1);
//	}
//	/**
//	 * Test del método getEdge donde no existen los nodos
//	 */
//	@Test
//	public void testGetEdgeBothDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 4;
//		int node4 = 6;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-3, g.getEdge(node3, node4),0.1);
//	}
//	
///*
// * Pruebas del método existsEdge:
// */
//	/**
//	 * Test del método existsEdge que no tiene errores
//	 */
//	@Test
//	public void testExistsEdgeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertTrue(g.existsEdge(node, node2));
//	}
//	/**
//	 * Test del método existsEdge donde no existe el nodo origen
//	 */
//	@Test
//	public void testExistsEdgeSourceDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3= 8;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertFalse(g.existsEdge(node3, node2));
//	}
//	/**
//	 * Test del método existsEdge donde no existe el nodo destino
//	 */
//	@Test
//	public void testExistsEdgeTargetDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3= 8;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertFalse(g.existsEdge(node, node3));
//	}
//	/**
//	 * Test del método existsEdge donde no existen los nodos
//	 */
//	@Test
//	public void testExistsEdgeBothDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		int node4 = 12;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertFalse(g.existsEdge(node3, node4));
//	}
//	
///*
// * Pruebas del método removeEdge:
// */
//	/**
//	 * Test del método removeEdge que no tiene errores 
//	 */
//	@Test
//	public void testRemoveEdgeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		int node4 = 12;
//		g.addNode(node);
//		g.addNode(node2); 
//		g.addNode(node3);
//		g.addNode(node4);
//		g.addEdge(node, node2, 4);
//		g.addEdge(node3, node4, 12);
//		assertEquals(0, g.removeEdge(node3, node4));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeEdge donde no existe el nodo origen
//	 */
//	@Test
//	public void testRemoveEdgeSourceDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		g.addNode(node);
//		g.addNode(node2); 
//		g.addEdge(node, node2, 4);
//		assertEquals(-1, g.removeEdge(node3, node2));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeEdge donde no existe el nodo destino
//	 */
//	@Test
//	public void testRemoveEdgeTargetDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		g.addNode(node);
//		g.addNode(node2); 
//		g.addEdge(node, node2, 4);
//		assertEquals(-2, g.removeEdge(node2, node3));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeEdge donde existen los nodos y no la arista
//	 */
//	@Test
//	public void testRemoveEdgeEdgeDontExistsNodesExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2); 
//		g.addEdge(node, node2, 4);
//		assertEquals(-4, g.removeEdge(node2, node));
//		System.out.println(g.toString());
//	}	
//	/**
//	 * Test del método removeEdge donde no existen los nodos
//	 */
//	@Test
//	public void testRemoveEdgeNodesDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		int node4 = 12;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-3, g.removeEdge(node3, node4));
//		System.out.println(g.toString());
//	}
///*
// * Pruebas del método removeNode:
// */
//	/**
//	 * Test del método removeNode que no tiene errores
//	 */
//	@Test
//	public void testRemoveNodeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;		
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(0, g.removeNode(node));
//		assertFalse(g.existsNode(node));
//		assertFalse(g.existsEdge(node, node2));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeNode que no tiene errores y borra toda la matriz
//	 */
//	@Test
//	public void testRemoveNodeVarious() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		int node4 = 12;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		g.addEdge(node, node, 12);
//		g.addEdge(node3, node, 7);
//		g.addEdge(node, node4, 15);
//		g.addEdge(node, node3, 9);
//		assertEquals(0, g.removeNode(node));
//		assertFalse(g.existsNode(node));
//		assertFalse(g.existsEdge(node, node2));
//		assertFalse(g.existsEdge(node, node));
//		assertFalse(g.existsEdge(node3, node));
//		assertFalse(g.existsEdge(node, node4));
//		assertFalse(g.existsEdge(node, node3));
//		System.out.println(g.toString());
//	}	
//	/**
//	 * Test del método removeNode donde el nodo no es valido
//	 */
//	@Test
//	public void testRemoveNodeNotValid() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;		
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-1, g.removeNode(null));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeNode donde el nodo no existe
//	 */
//	@Test
//	public void testRemoveNodeDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 12;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-1, g.removeNode(node3));
//		System.out.println(g.toString());
//	}
	/**
	 * Pruebas basicas de nodos
	 */
//	@Test
//	public void basicNodeTest() {
//		g=new Graph<Integer>(3); 
//	    assertFalse(g.existsNode(1)); //false
//	    assertFalse(g.existsNode(2)); //false
//	    assertEquals(0,g.addNode(1)); //0
//		assertEquals(0,g.addNode(2)); //0
//		assertTrue(g.existsNode(1)); //true
//		assertTrue(g.existsNode(2)); //true
//		assertEquals(-1,g.addNode(1)); //-1
//		assertEquals(-1,g.addNode(2)); //-1
//		assertEquals(0,g.addNode(3)); //0
//		assertEquals(-2,g.addNode(4)); //-2
//		assertFalse(g.existsNode(4)); //false
//		assertFalse(g.existsNode(5)); //false
//	}
	
//	@Test
//	public void basicEdgeTest() {
//		g=new Graph<Integer>(3); 
//		assertFalse(g.existsEdge(1,2)); //false
//		assertEquals(-3.0,g.getEdge(1,2),0.1); //-3.0
//		assertEquals(0,g.addNode(1)); //0
//		assertFalse(g.existsEdge(1,2)); //false
//		assertEquals(-2.0,g.getEdge(1,2),0.1); //-2.0
//		assertFalse(g.existsEdge(2,1)); //false
//		assertEquals(-1.0,g.getEdge(2,1),0.1); //-1.0
//		assertEquals(0,g.addNode(2)); //0
//		assertFalse(g.existsEdge(1,2)); //false
//		assertEquals(-4.0,g.getEdge(1,2),0.1); //-4.0
//		assertEquals(0,g.addEdge(1,2,12.12)); //0
//		assertEquals(-4,g.addEdge(1,2,12.1212)); //-4
//		assertEquals(0,g.addNode(3)); //0
//		assertFalse(g.existsEdge(1,3)); //false
//		assertFalse(g.existsEdge(3,2)); //false
//		assertEquals(-4.0,g.getEdge(1,3),0.1); //-4.0
//		assertEquals(-4.0,g.getEdge(3,2),0.1); //-4.0
//		assertEquals(0,g.addEdge(1,1,11.11)); //0
//		assertEquals(-4,g.addEdge(1,2,12.12)); //-4
//		assertEquals(0,g.addEdge(1,3,13.13)); //0
//		assertEquals(0,g.addEdge(2,1,21.21)); //0
//		assertEquals(0,g.addEdge(2,2,22.22)); //0
//		assertEquals(0,g.addEdge(2,3,23.23)); //0
//		assertEquals(0,g.addEdge(3,1,31.31)); //0
//		assertEquals(0,g.addEdge(3,2,32.32)); //0
//		assertEquals(0,g.addEdge(3,3,33.33)); //0
//		assertEquals(-4,g.addEdge(1,1,11.11)); //-4
//		assertEquals(-4,g.addEdge(1,2,12.12)); //-4
//		assertEquals(-4,g.addEdge(1,3,13.13)); //-4
//		assertEquals(-4,g.addEdge(2,1,21.21)); //-4
//		assertEquals(-4,g.addEdge(2,2,22.22)); //-4
//		assertEquals(-4,g.addEdge(2,3,23.23)); //-4
//		assertEquals(-4,g.addEdge(3,1,31.31)); //-4
//		assertEquals(-4,g.addEdge(3,2,32.32)); //-4
//		assertEquals(-4,g.addEdge(3,3,33.33)); //-4
//		g.getEdge(1,1,11.11); //11.11
//		g.getEdge(1,2,12.12); //12.12
//		g.getEdge(1,3,13.13); //13.129999999999999
//		g.getEdge(2,1,21.21); //21.21
//		g.getEdge(2,2,22.22); //22.22
//		g.getEdge(2,3,23.23); //23.23
//		g.getEdge(3,1,31.31); //31.310000000000002
//		g.getEdge(3,2,32.32); //32.32
//		g.getEdge(3,3,33.33); //33.33
//	}
	
	@Test
	public void basicEvolutionTest() {
		1 g.existsNode(1): //false
		2 g.existsNode(2): false
		3 g.addNode(1): 0
		4 g.addNode(2): 0
		5 g.existsNode(1): true
		6 g.existsNode(2): true
		7 g.addNode(1): -1
		8 g.addNode(2): -1
		9 g.addEdge(1,2, 1.2): 0
		10 g.addEdge(2,1, 2.1): 0
		11 g.addEdge(1,1, 1.1): 0
		12 g.getEdge(1,2): 1.2
		13 g.getEdge(2,1): 2.1
		14 g.getEdge(1,1): 1.1
		15 g.getEdge(2,3): -2.0
		16 g.existsEdge(1,2): true
		17 g.existsEdge(2,1): true
		18 g.existsEdge(1,1): true
		19 g.existsEdge(2,2): false
		20 g.removeEdge(2,2): -4
		21 g.addEdge(2,2,2.2): 0
		22 g.getEdge(2,2): 2.2
		23 g.existsEdge(2,2): true
		24 g.removeEdge(2,2): 0
		25 g.removeNode(3): -1
		26 g.addNode(3): 0
		27 g.addNode(4): -2
		28 g.getEdge(1, 3): -4.0
		29 g.addEdge(1,3, 1.3): 0
		30 g.existsEdge(1, 3): //true----------------(false)
		31 g.getEdge(1, 3): 1.3
		32 g.getEdge(1, 4): -2.0
		33 g.getEdge(5,1): -1.0
		34 g.getEdge(5,4): -3.0
		35 g.removeNode(3): 0
		36 g.removeNode(3): //0----------------(-1)
		37 g.existsEdge(1, 3): true
		38 g.getEdge(1, 3): //1.3-------------------(-2.0)
		39 g.removeNode(2): 0
		40 g.removeNode(2): //0---------------------(-1)
		41 g.existsEdge(1, 1): true
		42 g.removeNode(1): 0
		43 g.existsNode(1): //true----------------------(false)
		44 g.existsNode(2): true
		45 g.existsNode(3): true
		46 g.existsNode(4): false
		47 g.addNode(4): 0
		48 g.existsNode(4): true
		49 g.addEdge(4,4, 4.4): 0
		50 g.existsEdge(4, 4): //true--------------------(false)
		51 g.getEdge(4, 4): 4.4
		52 g.removeNode(4): 0
		53 g.removeNode(4): 0
		54 g.existsEdge(4, 4): true
		55 g.addNode(7): 0
		56 g.removeNode(2): 0
		57 g.removeNode(3): 0
		58 g.removeNode(4): -1
		59 g.existsEdge(7, 7): false
		60 g.addEdge(7,7, 7.7): 0
		61 g.addEdge(7,7, 17.17): -4
		62 g.getEdge(7, 7): 7.7
		63 g.addNode(8): 0
		64 g.addNode(9): 0
		65 g.existsEdge(7, 8): false
		66 g.existsEdge(8, 7): false
		67 g.existsEdge(8, 8): false
		68 g.existsEdge(8, 9): true
		69 g.existsEdge(9, 8): true
		70 g.existsEdge(9, 9): false
		71 g.addEdge(7,8, 7.8): 0
		72 g.addEdge(8,7, 8.7): 0
		73 g.addEdge(8,8, 8.8): 0
		74 g.addEdge(8,9, 8.9): -4
		75 g.addEdge(9,8, 9.8): -4
		76 g.addEdge(9,9, 9.9): 0
		77 g.addEdge(7,9, 7.9): 0
		78 g.addEdge(9,7, 9.7): 0
		79 g.getEdge(7, 7) --> -4.0
		80 g.getEdge(7, 8) --> 7.8
		81 g.getEdge(7, 9) --> 7.9
		82 g.getEdge(8, 7) --> 8.7
		83 g.getEdge(8, 8) --> 8.8
		84 g.getEdge(8, 9) --> 1.2
		85 g.getEdge(9, 7) --> 9.7
		86 g.getEdge(9, 8) --> 2.1
		87 g.getEdge(9, 9) --> 9.9
		88 g.removeNode(7): 0
		89 g.removeNode(7): 0
		90 g.getEdge(7, 7) --> -4.0
		91 g.getEdge(7, 8) --> 7.8
		92 g.getEdge(7, 9) --> 7.9
		93 g.getEdge(8, 7) --> 8.7
		94 g.getEdge(8, 8) --> 8.8
		95 g.getEdge(8, 9) --> 1.2
		96 g.getEdge(9, 7) --> 9.7
		97 g.getEdge(9, 8) --> 2.1
		98 g.getEdge(9, 9) --> 9.9
		99 g.removeNode(null): -1
		100 g.addNode(null): -4
		101 g.addNode(10): 0
		102 g.getEdge(8, 10) --> 8.7
		103 g.getEdge(10, 9) --> 7.9
		104 g.addNode(null): -6
		105 g.addEdge(8,8,-8.8): -12
		106 g.addEdge(7,8,-7.8): -9
		107 g.addEdge(8,7,-8.7): -10
		108 g.addEdge(7,7,-7.7): -11
		109 g.addEdge(null,8,0.8): -1
		110 g.addEdge(8,null,0.8): -2
		111 g.addEdge(null,null,0.8): -3
		112 g.getEdge(null,10): -1.0
		113 g.getEdge(10,null): -2.0
		114 g.getEdge(null,null): -3.0
		115 g.existsNode(null): false
		116 g.existsEdge(null,null): false
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-10-06 01:00:09.573
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-10-06 01:00:09.574
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-10-06 01:00:31.828
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package p2Grafos;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import org.junit.Test;

/**
 * Titulo: Clase GraphTests
 * 
 * @author UO281847
 * @version 24/09/2021
 */
public class GraphTests {
	private Graph<Integer> g;
///*
// * Pruebas del método addNode:	
// */
//	/**
//	 * Test del método addNode sin errores
//	 */
//	@Test
//	public void testAddNodeFirst() {
//		Graph<Integer> g = new Graph<Integer>(3);
//		int node = 12;
//		assertEquals(0, g.addNode(node));
//		System.out.println(g.toString());	
//	}	
//	/**
//	 * Test del método addNode con nodo no valido
//	 */
//	@Test
//	public void testAddNodeNotValid() {
//		Graph<Integer> g = new Graph<Integer>(3);
//		int node = 1;
//		int node2 = 18;
//		assertEquals(0, g.addNode(node));
//		assertEquals(0, g.addNode(node2));
//		assertEquals(-5, g.addNode(null));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addNode cuando ya esta lleno
//	 */
//	@Test
//	public void testAddNodeFull() {
//		Graph<Integer> g = new Graph<Integer>(3);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 39;
//		int node4= 2;
//		assertEquals(0, g.addNode(node));
//		assertEquals(0, g.addNode(node2));
//		assertEquals(0, g.addNode(node3));
//		assertEquals(-2, g.addNode(node4));		
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addNode cuando ya existe
//	 */
//	@Test
//	public void testAddNodeAlreadyExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 39;
//		int node4 = 19;
//		int node5= 19;
//		assertEquals(0, g.addNode(node));
//		assertEquals(0, g.addNode(node2));
//		assertEquals(0, g.addNode(node3));
//		assertEquals(0, g.addNode(node4));
//		assertEquals(-1, g.addNode(node5));	
//		System.out.println(g.toString());	
//	}
//	
///*
// * Pruebas del método getNode:
// */
//	/**
//	 * Test del método getNode que devuelve la posición
//	 */
//	@Test
//	public void testGetNodeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		g.addNode(node);
//		assertEquals(0, g.getNode(node));
//	}
//	/**
//	 * Test del método getNode que devuelve la posición ya añadido
//	 */
//	@Test
//	public void testGetNodeVarious() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 23;
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(1, g.getNode(node2));
//	}
//	/**
//	 * Test del método getNode que devuelve -1
//	 */
//	@Test
//	public void testGetNodeDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 23;
//		g.addNode(node);
//		assertEquals(-1, g.getNode(node2));
//	}
//
///**
// * Pruebas del método existsNode:
// */
//	/**
//	 * Test del método existsNode que devuelve true
//	 */
//	@Test
//	public void testExistsNodeOne() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		g.addNode(node);
//		assertTrue(g.existsNode(node));
//	}
//	/**
//	 * Test del método existsNode que devuelve true
//	 */
//	@Test
//	public void testExistsNodeVarious() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 23;
//		g.addNode(node);
//		g.addNode(node2);
//		assertTrue(g.existsNode(node2));
//	}
//	/**
//	 * Test del método existsNode que devuelve true
//	 */
//	@Test
//	public void testExistsNodeFalse() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 23;
//		g.addNode(node);
//		assertFalse(g.existsNode(node2));
//	}
//
///*
// * Pruebas del método addEdge:
// */
//	/**
//	 * Test del método addEdge que no tiene errores
//	 */
//	@Test
//	public void testAddEdgeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;		
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(0, g.addEdge(node, node2, 12));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde no existe el nodo origen
//	 */
//	@Test
//	public void testAddEdgeSourceDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 23;
//		g.addNode(node);
//		g.addNode(node2);		
//		assertEquals(-1, g.addEdge(node3, node2, 12));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde no existe el nodo destino
//	 */
//	@Test
//	public void testAddEdgeTargetDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 23;
//		g.addNode(node);
//		g.addNode(node2);		
//		assertEquals(-2, g.addEdge(node, node3, 12));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde ya existe la arista
//	 */
//	@Test
//	public void testAddEdgeEdgeExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 12);
//		assertEquals(-4, g.addEdge(node, node2, 12));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde el peso no es valido
//	 */
//	@Test
//	public void testAddEdgeEdgeWightError() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(-8, g.addEdge(node, node2, -4));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde no existen los nodos 
//	 */
//	@Test
//	public void testAddEdgeSourceTargetError() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 12;
//		int node4 = 56;
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(-3, g.addEdge(node3, node4, 4));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde ya existe la arista y el peso no es valido
//	 */
//	@Test
//	public void testAddEdgeEdgeExistsEdgeWeightError() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-12, g.addEdge(node, node2, -4));
//		System.out.println(g.toString());	
//	}
//	
///*
// * Pruebas del método getEdge:
// */
//	/**
//	 * Test del método getEdge que no tiene errores
//	 */
//	@Test
//	public void testGetEdgeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(4, g.getEdge(node, node2),0.1);
//	}
//	/**
//	 * Test del método getEdge donde no existe el nodo origen
//	 */
//	@Test
//	public void testGetEdgeSourceDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 4;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-1, g.getEdge(node3, node2),0.1);
//	}
//	/**
//	 * Test del método getEdge donde no existe el nodo destino
//	 */
//	@Test
//	public void testGetEdgeTargetDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 4;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-2, g.getEdge(node, node3),0.1);
//	}
//	/**
//	 * Test del método getEdge donde existen los nodos y no la arista
//	 */
//	@Test
//	public void testGetEdgeEdgeDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(-4, g.getEdge(node, node2),0.1);
//	}
//	/**
//	 * Test del método getEdge donde no existen los nodos
//	 */
//	@Test
//	public void testGetEdgeBothDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 4;
//		int node4 = 6;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-3, g.getEdge(node3, node4),0.1);
//	}
//	
///*
// * Pruebas del método existsEdge:
// */
//	/**
//	 * Test del método existsEdge que no tiene errores
//	 */
//	@Test
//	public void testExistsEdgeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertTrue(g.existsEdge(node, node2));
//	}
//	/**
//	 * Test del método existsEdge donde no existe el nodo origen
//	 */
//	@Test
//	public void testExistsEdgeSourceDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3= 8;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertFalse(g.existsEdge(node3, node2));
//	}
//	/**
//	 * Test del método existsEdge donde no existe el nodo destino
//	 */
//	@Test
//	public void testExistsEdgeTargetDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3= 8;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertFalse(g.existsEdge(node, node3));
//	}
//	/**
//	 * Test del método existsEdge donde no existen los nodos
//	 */
//	@Test
//	public void testExistsEdgeBothDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		int node4 = 12;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertFalse(g.existsEdge(node3, node4));
//	}
//	
///*
// * Pruebas del método removeEdge:
// */
//	/**
//	 * Test del método removeEdge que no tiene errores 
//	 */
//	@Test
//	public void testRemoveEdgeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		int node4 = 12;
//		g.addNode(node);
//		g.addNode(node2); 
//		g.addNode(node3);
//		g.addNode(node4);
//		g.addEdge(node, node2, 4);
//		g.addEdge(node3, node4, 12);
//		assertEquals(0, g.removeEdge(node3, node4));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeEdge donde no existe el nodo origen
//	 */
//	@Test
//	public void testRemoveEdgeSourceDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		g.addNode(node);
//		g.addNode(node2); 
//		g.addEdge(node, node2, 4);
//		assertEquals(-1, g.removeEdge(node3, node2));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeEdge donde no existe el nodo destino
//	 */
//	@Test
//	public void testRemoveEdgeTargetDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		g.addNode(node);
//		g.addNode(node2); 
//		g.addEdge(node, node2, 4);
//		assertEquals(-2, g.removeEdge(node2, node3));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeEdge donde existen los nodos y no la arista
//	 */
//	@Test
//	public void testRemoveEdgeEdgeDontExistsNodesExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2); 
//		g.addEdge(node, node2, 4);
//		assertEquals(-4, g.removeEdge(node2, node));
//		System.out.println(g.toString());
//	}	
//	/**
//	 * Test del método removeEdge donde no existen los nodos
//	 */
//	@Test
//	public void testRemoveEdgeNodesDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		int node4 = 12;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-3, g.removeEdge(node3, node4));
//		System.out.println(g.toString());
//	}
///*
// * Pruebas del método removeNode:
// */
//	/**
//	 * Test del método removeNode que no tiene errores
//	 */
//	@Test
//	public void testRemoveNodeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;		
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(0, g.removeNode(node));
//		assertFalse(g.existsNode(node));
//		assertFalse(g.existsEdge(node, node2));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeNode que no tiene errores y borra toda la matriz
//	 */
//	@Test
//	public void testRemoveNodeVarious() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		int node4 = 12;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		g.addEdge(node, node, 12);
//		g.addEdge(node3, node, 7);
//		g.addEdge(node, node4, 15);
//		g.addEdge(node, node3, 9);
//		assertEquals(0, g.removeNode(node));
//		assertFalse(g.existsNode(node));
//		assertFalse(g.existsEdge(node, node2));
//		assertFalse(g.existsEdge(node, node));
//		assertFalse(g.existsEdge(node3, node));
//		assertFalse(g.existsEdge(node, node4));
//		assertFalse(g.existsEdge(node, node3));
//		System.out.println(g.toString());
//	}	
//	/**
//	 * Test del método removeNode donde el nodo no es valido
//	 */
//	@Test
//	public void testRemoveNodeNotValid() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;		
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-1, g.removeNode(null));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeNode donde el nodo no existe
//	 */
//	@Test
//	public void testRemoveNodeDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 12;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-1, g.removeNode(node3));
//		System.out.println(g.toString());
//	}
	/**
	 * Pruebas basicas de nodos
	 */
//	@Test
//	public void basicNodeTest() {
//		g=new Graph<Integer>(3); 
//	    assertFalse(g.existsNode(1)); //false
//	    assertFalse(g.existsNode(2)); //false
//	    assertEquals(0,g.addNode(1)); //0
//		assertEquals(0,g.addNode(2)); //0
//		assertTrue(g.existsNode(1)); //true
//		assertTrue(g.existsNode(2)); //true
//		assertEquals(-1,g.addNode(1)); //-1
//		assertEquals(-1,g.addNode(2)); //-1
//		assertEquals(0,g.addNode(3)); //0
//		assertEquals(-2,g.addNode(4)); //-2
//		assertFalse(g.existsNode(4)); //false
//		assertFalse(g.existsNode(5)); //false
//	}
	
//	@Test
//	public void basicEdgeTest() {
//		g=new Graph<Integer>(3); 
//		assertFalse(g.existsEdge(1,2)); //false
//		assertEquals(-3.0,g.getEdge(1,2),0.1); //-3.0
//		assertEquals(0,g.addNode(1)); //0
//		assertFalse(g.existsEdge(1,2)); //false
//		assertEquals(-2.0,g.getEdge(1,2),0.1); //-2.0
//		assertFalse(g.existsEdge(2,1)); //false
//		assertEquals(-1.0,g.getEdge(2,1),0.1); //-1.0
//		assertEquals(0,g.addNode(2)); //0
//		assertFalse(g.existsEdge(1,2)); //false
//		assertEquals(-4.0,g.getEdge(1,2),0.1); //-4.0
//		assertEquals(0,g.addEdge(1,2,12.12)); //0
//		assertEquals(-4,g.addEdge(1,2,12.1212)); //-4
//		assertEquals(0,g.addNode(3)); //0
//		assertFalse(g.existsEdge(1,3)); //false
//		assertFalse(g.existsEdge(3,2)); //false
//		assertEquals(-4.0,g.getEdge(1,3),0.1); //-4.0
//		assertEquals(-4.0,g.getEdge(3,2),0.1); //-4.0
//		assertEquals(0,g.addEdge(1,1,11.11)); //0
//		assertEquals(-4,g.addEdge(1,2,12.12)); //-4
//		assertEquals(0,g.addEdge(1,3,13.13)); //0
//		assertEquals(0,g.addEdge(2,1,21.21)); //0
//		assertEquals(0,g.addEdge(2,2,22.22)); //0
//		assertEquals(0,g.addEdge(2,3,23.23)); //0
//		assertEquals(0,g.addEdge(3,1,31.31)); //0
//		assertEquals(0,g.addEdge(3,2,32.32)); //0
//		assertEquals(0,g.addEdge(3,3,33.33)); //0
//		assertEquals(-4,g.addEdge(1,1,11.11)); //-4
//		assertEquals(-4,g.addEdge(1,2,12.12)); //-4
//		assertEquals(-4,g.addEdge(1,3,13.13)); //-4
//		assertEquals(-4,g.addEdge(2,1,21.21)); //-4
//		assertEquals(-4,g.addEdge(2,2,22.22)); //-4
//		assertEquals(-4,g.addEdge(2,3,23.23)); //-4
//		assertEquals(-4,g.addEdge(3,1,31.31)); //-4
//		assertEquals(-4,g.addEdge(3,2,32.32)); //-4
//		assertEquals(-4,g.addEdge(3,3,33.33)); //-4
//		g.getEdge(1,1,11.11); //11.11
//		g.getEdge(1,2,12.12); //12.12
//		g.getEdge(1,3,13.13); //13.129999999999999
//		g.getEdge(2,1,21.21); //21.21
//		g.getEdge(2,2,22.22); //22.22
//		g.getEdge(2,3,23.23); //23.23
//		g.getEdge(3,1,31.31); //31.310000000000002
//		g.getEdge(3,2,32.32); //32.32
//		g.getEdge(3,3,33.33); //33.33
//	}
	
	@Test
	public void basicEvolutionTest() {
		1 g.existsNode(1): //false
		2 g.existsNode(2): false
		3 g.addNode(1): 0
		4 g.addNode(2): 0
		5 g.existsNode(1): true
		6 g.existsNode(2): true
		7 g.addNode(1): -1
		8 g.addNode(2): -1
		9 g.addEdge(1,2, 1.2): 0
		10 g.addEdge(2,1, 2.1): 0
		11 g.addEdge(1,1, 1.1): 0
		12 g.getEdge(1,2): 1.2
		13 g.getEdge(2,1): 2.1
		14 g.getEdge(1,1): 1.1
		15 g.getEdge(2,3): -2.0
		16 g.existsEdge(1,2): true
		17 g.existsEdge(2,1): true
		18 g.existsEdge(1,1): true
		19 g.existsEdge(2,2): false
		20 g.removeEdge(2,2): -4
		21 g.addEdge(2,2,2.2): 0
		22 g.getEdge(2,2): 2.2
		23 g.existsEdge(2,2): true
		24 g.removeEdge(2,2): 0
		25 g.removeNode(3): -1
		26 g.addNode(3): 0
		27 g.addNode(4): -2
		28 g.getEdge(1, 3): -4.0
		29 g.addEdge(1,3, 1.3): 0
		30 g.existsEdge(1, 3): //true----------------(false)
		31 g.getEdge(1, 3): 1.3
		32 g.getEdge(1, 4): -2.0
		33 g.getEdge(5,1): -1.0
		34 g.getEdge(5,4): -3.0
		35 g.removeNode(3): 0
		36 g.removeNode(3): //0----------------(-1)
		37 g.existsEdge(1, 3): true
		38 g.getEdge(1, 3): //1.3-------------------(-2.0)
		39 g.removeNode(2): 0
		40 g.removeNode(2): //0---------------------(-1)
		41 g.existsEdge(1, 1): true
		42 g.removeNode(1): 0
		43 g.existsNode(1): //true----------------------(false)
		44 g.existsNode(2): true
		45 g.existsNode(3): true
		46 g.existsNode(4): false
		47 g.addNode(4): 0
		48 g.existsNode(4): true
		49 g.addEdge(4,4, 4.4): 0
		50 g.existsEdge(4, 4): //true--------------------(false)
		51 g.getEdge(4, 4): 4.4
		52 g.removeNode(4): 0
		53 g.removeNode(4): 0
		54 g.existsEdge(4, 4): true
		55 g.addNode(7): 0
		56 g.removeNode(2): 0
		57 g.removeNode(3): 0
		58 g.removeNode(4): -1
		59 g.existsEdge(7, 7): false
		60 g.addEdge(7,7, 7.7): 0
		61 g.addEdge(7,7, 17.17): -4
		62 g.getEdge(7, 7): 7.7
		63 g.addNode(8): 0
		64 g.addNode(9): 0
		65 g.existsEdge(7, 8): false
		66 g.existsEdge(8, 7): false
		67 g.existsEdge(8, 8): false
		68 g.existsEdge(8, 9): true
		69 g.existsEdge(9, 8): true
		70 g.existsEdge(9, 9): false
		71 g.addEdge(7,8, 7.8): 0
		72 g.addEdge(8,7, 8.7): 0
		73 g.addEdge(8,8, 8.8): 0
		74 g.addEdge(8,9, 8.9): -4
		75 g.addEdge(9,8, 9.8): -4
		76 g.addEdge(9,9, 9.9): 0
		77 g.addEdge(7,9, 7.9): 0
		78 g.addEdge(9,7, 9.7): 0
		79 g.getEdge(7, 7) --> -4.0
		80 g.getEdge(7, 8) --> 7.8
		81 g.getEdge(7, 9) --> 7.9
		82 g.getEdge(8, 7) --> 8.7
		83 g.getEdge(8, 8) --> 8.8
		84 g.getEdge(8, 9) --> 1.2
		85 g.getEdge(9, 7) --> 9.7
		86 g.getEdge(9, 8) --> 2.1
		87 g.getEdge(9, 9) --> 9.9
		88 g.removeNode(7): 0
		89 g.removeNode(7): 0
		90 g.getEdge(7, 7) --> -4.0
		91 g.getEdge(7, 8) --> 7.8
		92 g.getEdge(7, 9) --> 7.9
		93 g.getEdge(8, 7) --> 8.7
		94 g.getEdge(8, 8) --> 8.8
		95 g.getEdge(8, 9) --> 1.2
		96 g.getEdge(9, 7) --> 9.7
		97 g.getEdge(9, 8) --> 2.1
		98 g.getEdge(9, 9) --> 9.9
		99 g.removeNode(null): -1
		100 g.addNode(null): -4
		101 g.addNode(10): 0
		102 g.getEdge(8, 10) --> 8.7
		103 g.getEdge(10, 9) --> 7.9
		104 g.addNode(null): -6
		105 g.addEdge(8,8,-8.8): -12
		106 g.addEdge(7,8,-7.8): -9
		107 g.addEdge(8,7,-8.7): -10
		108 g.addEdge(7,7,-7.7): -11
		109 g.addEdge(null,8,0.8): -1
		110 g.addEdge(8,null,0.8): -2
		111 g.addEdge(null,null,0.8): -3
		112 g.getEdge(null,10): -1.0
		113 g.getEdge(10,null): -2.0
		114 g.getEdge(null,null): -3.0
		115 g.existsNode(null): false
		116 g.existsEdge(null,null): false
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-10-06 01:00:31.830
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-10-06 01:00:31.832
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SESSION 2021-10-06 02:13:02.686 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=15.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_ES
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-10-06 02:13:06.466
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-10-06 02:13:06.466
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@58e5fbe5,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@335896bd,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-10-06 02:13:08.988
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\omart'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-10-06 10:53:27.989 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=15.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_ES
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-10-06 10:53:32.225
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-10-06 10:53:32.225
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@147375b3,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6f430ea8,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-10-06 10:53:35.270
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\omart'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.core 4 4 2021-10-06 11:46:18.422
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package p2Grafos;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import org.junit.Test;

/**
 * Titulo: Clase GraphTests
 * 
 * @author UO281847
 * @version 24/09/2021
 */
public class GraphTests {
	private Graph<Integer> g;
///*
// * Pruebas del método addNode:	
// */
//	/**
//	 * Test del método addNode sin errores
//	 */
//	@Test
//	public void testAddNodeFirst() {
//		Graph<Integer> g = new Graph<Integer>(3);
//		int node = 12;
//		assertEquals(0, g.addNode(node));
//		System.out.println(g.toString());	
//	}	
//	/**
//	 * Test del método addNode con nodo no valido
//	 */
//	@Test
//	public void testAddNodeNotValid() {
//		Graph<Integer> g = new Graph<Integer>(3);
//		int node = 1;
//		int node2 = 18;
//		assertEquals(0, g.addNode(node));
//		assertEquals(0, g.addNode(node2));
//		assertEquals(-5, g.addNode(null));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addNode cuando ya esta lleno
//	 */
//	@Test
//	public void testAddNodeFull() {
//		Graph<Integer> g = new Graph<Integer>(3);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 39;
//		int node4= 2;
//		assertEquals(0, g.addNode(node));
//		assertEquals(0, g.addNode(node2));
//		assertEquals(0, g.addNode(node3));
//		assertEquals(-2, g.addNode(node4));		
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addNode cuando ya existe
//	 */
//	@Test
//	public void testAddNodeAlreadyExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 39;
//		int node4 = 19;
//		int node5= 19;
//		assertEquals(0, g.addNode(node));
//		assertEquals(0, g.addNode(node2));
//		assertEquals(0, g.addNode(node3));
//		assertEquals(0, g.addNode(node4));
//		assertEquals(-1, g.addNode(node5));	
//		System.out.println(g.toString());	
//	}
//	
///*
// * Pruebas del método getNode:
// */
//	/**
//	 * Test del método getNode que devuelve la posición
//	 */
//	@Test
//	public void testGetNodeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		g.addNode(node);
//		assertEquals(0, g.getNode(node));
//	}
//	/**
//	 * Test del método getNode que devuelve la posición ya añadido
//	 */
//	@Test
//	public void testGetNodeVarious() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 23;
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(1, g.getNode(node2));
//	}
//	/**
//	 * Test del método getNode que devuelve -1
//	 */
//	@Test
//	public void testGetNodeDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 23;
//		g.addNode(node);
//		assertEquals(-1, g.getNode(node2));
//	}
//
///**
// * Pruebas del método existsNode:
// */
//	/**
//	 * Test del método existsNode que devuelve true
//	 */
//	@Test
//	public void testExistsNodeOne() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		g.addNode(node);
//		assertTrue(g.existsNode(node));
//	}
//	/**
//	 * Test del método existsNode que devuelve true
//	 */
//	@Test
//	public void testExistsNodeVarious() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 23;
//		g.addNode(node);
//		g.addNode(node2);
//		assertTrue(g.existsNode(node2));
//	}
//	/**
//	 * Test del método existsNode que devuelve true
//	 */
//	@Test
//	public void testExistsNodeFalse() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 23;
//		g.addNode(node);
//		assertFalse(g.existsNode(node2));
//	}
//
///*
// * Pruebas del método addEdge:
// */
//	/**
//	 * Test del método addEdge que no tiene errores
//	 */
//	@Test
//	public void testAddEdgeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;		
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(0, g.addEdge(node, node2, 12));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde no existe el nodo origen
//	 */
//	@Test
//	public void testAddEdgeSourceDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 23;
//		g.addNode(node);
//		g.addNode(node2);		
//		assertEquals(-1, g.addEdge(node3, node2, 12));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde no existe el nodo destino
//	 */
//	@Test
//	public void testAddEdgeTargetDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 23;
//		g.addNode(node);
//		g.addNode(node2);		
//		assertEquals(-2, g.addEdge(node, node3, 12));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde ya existe la arista
//	 */
//	@Test
//	public void testAddEdgeEdgeExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 12);
//		assertEquals(-4, g.addEdge(node, node2, 12));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde el peso no es valido
//	 */
//	@Test
//	public void testAddEdgeEdgeWightError() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(-8, g.addEdge(node, node2, -4));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde no existen los nodos 
//	 */
//	@Test
//	public void testAddEdgeSourceTargetError() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 12;
//		int node4 = 56;
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(-3, g.addEdge(node3, node4, 4));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde ya existe la arista y el peso no es valido
//	 */
//	@Test
//	public void testAddEdgeEdgeExistsEdgeWeightError() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-12, g.addEdge(node, node2, -4));
//		System.out.println(g.toString());	
//	}
//	
///*
// * Pruebas del método getEdge:
// */
//	/**
//	 * Test del método getEdge que no tiene errores
//	 */
//	@Test
//	public void testGetEdgeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(4, g.getEdge(node, node2),0.1);
//	}
//	/**
//	 * Test del método getEdge donde no existe el nodo origen
//	 */
//	@Test
//	public void testGetEdgeSourceDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 4;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-1, g.getEdge(node3, node2),0.1);
//	}
//	/**
//	 * Test del método getEdge donde no existe el nodo destino
//	 */
//	@Test
//	public void testGetEdgeTargetDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 4;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-2, g.getEdge(node, node3),0.1);
//	}
//	/**
//	 * Test del método getEdge donde existen los nodos y no la arista
//	 */
//	@Test
//	public void testGetEdgeEdgeDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(-4, g.getEdge(node, node2),0.1);
//	}
//	/**
//	 * Test del método getEdge donde no existen los nodos
//	 */
//	@Test
//	public void testGetEdgeBothDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 4;
//		int node4 = 6;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-3, g.getEdge(node3, node4),0.1);
//	}
//	
///*
// * Pruebas del método existsEdge:
// */
//	/**
//	 * Test del método existsEdge que no tiene errores
//	 */
//	@Test
//	public void testExistsEdgeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertTrue(g.existsEdge(node, node2));
//	}
//	/**
//	 * Test del método existsEdge donde no existe el nodo origen
//	 */
//	@Test
//	public void testExistsEdgeSourceDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3= 8;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertFalse(g.existsEdge(node3, node2));
//	}
//	/**
//	 * Test del método existsEdge donde no existe el nodo destino
//	 */
//	@Test
//	public void testExistsEdgeTargetDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3= 8;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertFalse(g.existsEdge(node, node3));
//	}
//	/**
//	 * Test del método existsEdge donde no existen los nodos
//	 */
//	@Test
//	public void testExistsEdgeBothDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		int node4 = 12;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertFalse(g.existsEdge(node3, node4));
//	}
//	
///*
// * Pruebas del método removeEdge:
// */
//	/**
//	 * Test del método removeEdge que no tiene errores 
//	 */
//	@Test
//	public void testRemoveEdgeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		int node4 = 12;
//		g.addNode(node);
//		g.addNode(node2); 
//		g.addNode(node3);
//		g.addNode(node4);
//		g.addEdge(node, node2, 4);
//		g.addEdge(node3, node4, 12);
//		assertEquals(0, g.removeEdge(node3, node4));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeEdge donde no existe el nodo origen
//	 */
//	@Test
//	public void testRemoveEdgeSourceDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		g.addNode(node);
//		g.addNode(node2); 
//		g.addEdge(node, node2, 4);
//		assertEquals(-1, g.removeEdge(node3, node2));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeEdge donde no existe el nodo destino
//	 */
//	@Test
//	public void testRemoveEdgeTargetDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		g.addNode(node);
//		g.addNode(node2); 
//		g.addEdge(node, node2, 4);
//		assertEquals(-2, g.removeEdge(node2, node3));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeEdge donde existen los nodos y no la arista
//	 */
//	@Test
//	public void testRemoveEdgeEdgeDontExistsNodesExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2); 
//		g.addEdge(node, node2, 4);
//		assertEquals(-4, g.removeEdge(node2, node));
//		System.out.println(g.toString());
//	}	
//	/**
//	 * Test del método removeEdge donde no existen los nodos
//	 */
//	@Test
//	public void testRemoveEdgeNodesDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		int node4 = 12;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-3, g.removeEdge(node3, node4));
//		System.out.println(g.toString());
//	}
///*
// * Pruebas del método removeNode:
// */
//	/**
//	 * Test del método removeNode que no tiene errores
//	 */
//	@Test
//	public void testRemoveNodeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;		
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(0, g.removeNode(node));
//		assertFalse(g.existsNode(node));
//		assertFalse(g.existsEdge(node, node2));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeNode que no tiene errores y borra toda la matriz
//	 */
//	@Test
//	public void testRemoveNodeVarious() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		int node4 = 12;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		g.addEdge(node, node, 12);
//		g.addEdge(node3, node, 7);
//		g.addEdge(node, node4, 15);
//		g.addEdge(node, node3, 9);
//		assertEquals(0, g.removeNode(node));
//		assertFalse(g.existsNode(node));
//		assertFalse(g.existsEdge(node, node2));
//		assertFalse(g.existsEdge(node, node));
//		assertFalse(g.existsEdge(node3, node));
//		assertFalse(g.existsEdge(node, node4));
//		assertFalse(g.existsEdge(node, node3));
//		System.out.println(g.toString());
//	}	
//	/**
//	 * Test del método removeNode donde el nodo no es valido
//	 */
//	@Test
//	public void testRemoveNodeNotValid() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;		
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-1, g.removeNode(null));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeNode donde el nodo no existe
//	 */
//	@Test
//	public void testRemoveNodeDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 12;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-1, g.removeNode(node3));
//		System.out.println(g.toString());
//	}
	/**
	 * Pruebas basicas de nodos
	 */
//	@Test
//	public void basicNodeTest() {
//		g=new Graph<Integer>(3); 
//	    assertFalse(g.existsNode(1)); //false
//	    assertFalse(g.existsNode(2)); //false
//	    assertEquals(0,g.addNode(1)); //0
//		assertEquals(0,g.addNode(2)); //0
//		assertTrue(g.existsNode(1)); //true
//		assertTrue(g.existsNode(2)); //true
//		assertEquals(-1,g.addNode(1)); //-1
//		assertEquals(-1,g.addNode(2)); //-1
//		assertEquals(0,g.addNode(3)); //0
//		assertEquals(-2,g.addNode(4)); //-2
//		assertFalse(g.existsNode(4)); //false
//		assertFalse(g.existsNode(5)); //false
//	}
	
//	@Test
//	public void basicEdgeTest() {
//		g=new Graph<Integer>(3); 
//		assertFalse(g.existsEdge(1,2)); //false
//		assertEquals(-3.0,g.getEdge(1,2),0.1); //-3.0
//		assertEquals(0,g.addNode(1)); //0
//		assertFalse(g.existsEdge(1,2)); //false
//		assertEquals(-2.0,g.getEdge(1,2),0.1); //-2.0
//		assertFalse(g.existsEdge(2,1)); //false
//		assertEquals(-1.0,g.getEdge(2,1),0.1); //-1.0
//		assertEquals(0,g.addNode(2)); //0
//		assertFalse(g.existsEdge(1,2)); //false
//		assertEquals(-4.0,g.getEdge(1,2),0.1); //-4.0
//		assertEquals(0,g.addEdge(1,2,12.12)); //0
//		assertEquals(-4,g.addEdge(1,2,12.1212)); //-4
//		assertEquals(0,g.addNode(3)); //0
//		assertFalse(g.existsEdge(1,3)); //false
//		assertFalse(g.existsEdge(3,2)); //false
//		assertEquals(-4.0,g.getEdge(1,3),0.1); //-4.0
//		assertEquals(-4.0,g.getEdge(3,2),0.1); //-4.0
//		assertEquals(0,g.addEdge(1,1,11.11)); //0
//		assertEquals(-4,g.addEdge(1,2,12.12)); //-4
//		assertEquals(0,g.addEdge(1,3,13.13)); //0
//		assertEquals(0,g.addEdge(2,1,21.21)); //0
//		assertEquals(0,g.addEdge(2,2,22.22)); //0
//		assertEquals(0,g.addEdge(2,3,23.23)); //0
//		assertEquals(0,g.addEdge(3,1,31.31)); //0
//		assertEquals(0,g.addEdge(3,2,32.32)); //0
//		assertEquals(0,g.addEdge(3,3,33.33)); //0
//		assertEquals(-4,g.addEdge(1,1,11.11)); //-4
//		assertEquals(-4,g.addEdge(1,2,12.12)); //-4
//		assertEquals(-4,g.addEdge(1,3,13.13)); //-4
//		assertEquals(-4,g.addEdge(2,1,21.21)); //-4
//		assertEquals(-4,g.addEdge(2,2,22.22)); //-4
//		assertEquals(-4,g.addEdge(2,3,23.23)); //-4
//		assertEquals(-4,g.addEdge(3,1,31.31)); //-4
//		assertEquals(-4,g.addEdge(3,2,32.32)); //-4
//		assertEquals(-4,g.addEdge(3,3,33.33)); //-4
//		g.getEdge(1,1,11.11); //11.11
//		g.getEdge(1,2,12.12); //12.12
//		g.getEdge(1,3,13.13); //13.129999999999999
//		g.getEdge(2,1,21.21); //21.21
//		g.getEdge(2,2,22.22); //22.22
//		g.getEdge(2,3,23.23); //23.23
//		g.getEdge(3,1,31.31); //31.310000000000002
//		g.getEdge(3,2,32.32); //32.32
//		g.getEdge(3,3,33.33); //33.33
//	}
	
	@Test
	public void basicEvolutionTest() {
		g=new Graph<Integer>(3); 
		assertFalse(g.existsNode(1)); //false
		assertFalse(g.existsNode(2)); //false
		assertEquals(0,g.addNode(1)); //0
		assertEquals(0,g.addNode(2)); //0
		assertTrue(g.existsNode(1)); //true
		assertTrue(g.existsNode(2)); //true
		assertEquals(-1,g.addNode(1)); //-1
		assertEquals(-1,g.addNode(2)); //-1
		assertEquals(0,g.addEdge(1,2, 1.2)); //0
		assertEquals(0,g.addEdge(2,1, 2.1));//0
		assertEquals(0,g.addEdge(1,1, 1.1)); //0
		assertEquals(1.2,g.getEdge(1,2),0.1); //1.2
		assertEquals(2.1,g.getEdge(2,1),0.1); //2.1
		assertEquals(1.1,g.getEdge(1,1),0.1); //1.1
		assertEquals(-2.0,g.getEdge(2,3),0.1); //-2.0
		assertTrue(g.existsEdge(1,2)); //true
		assertTrue(g.existsEdge(2,1)); //true
		assertTrue(g.existsEdge(1,1)); //true
		assertFalse(g.existsEdge(2,2)); //false
		assertEquals(-4,g.removeEdge(2,2)); //-4
		assertEquals(0,g.addEdge(2,2,2.2)); //0
		assertEquals(2.2,g.getEdge(2,2),0.1); //2.2
		assertTrue(g.existsEdge(2,2)); //true
		assertEquals(0,g.removeEdge(2,2)); //0
		assertEquals(-1,g.removeNode(3)); //-1
		assertEquals(0,g.addNode(3)); //0		
		assertEquals(-2,g.addNode(4)); //-2
		assertEquals(-4.0,g.getEdge(1, 3),0.1); //-4.0
		assertEquals(0,g.addEdge(1,3, 1.3)); //0	
		assertTrue(g.existsEdge(1, 3)); //true	
		assertEquals(1.3,g.getEdge(1, 3),0.1); //1.3
		assertEquals(-2.0,g.getEdge(1, 4),0.1); //-2.0
		assertEquals(-1.0,g.getEdge(5,1),0.1); //-1.0
		assertEquals(-3.0,g.getEdge(5,4),0.1); //-3.0
		assertEquals(0,g.removeNode(3)); //0
		assertEquals(-1,g.removeNode(3)); //0---------------->(-1)
		assertFalse(g.existsEdge(1, 3)); //true---------------->(false)	
		assertEquals(-2.0,g.getEdge(1, 3),0.1); //1.3------------------->(-2.0)
		assertEquals(0,g.removeNode(2)); //0
		assertEquals(-1,g.removeNode(2)); //0--------------------->(-1)
		assertTrue(g.existsEdge(1, 1)); //true
		assertEquals(0,g.removeNode(1)); //0
		assertFalse(g.existsNode(1)); //true---------------------->(false)
		assertFalse(g.existsNode(2)); //true---------------------->(false)
		assertFalse(g.existsNode(3)); //true---------------------->(false)
		assertFalse(g.existsNode(4)); //false
		assertEquals(0,g.addNode(4)); //0
		assertTrue(g.existsNode(4)); //true
		assertEquals(0,g.addEdge(4,4, 4.4)); //0
		assertTrue(g.existsEdge(4, 4)); //true
		g.getEdge(4, 4): //4.4
		g.removeNode(4): //0
		g.removeNode(4): //0
		g.existsEdge(4, 4): //true-------------------->(false)
		g.addNode(7): //0
		g.removeNode(2): //0
		g.removeNode(3): //0
		g.removeNode(4): //-1
		g.existsEdge(7, 7): //false
		g.addEdge(7,7, 7.7): //0
		g.addEdge(7,7, 17.17): //-4
		g.getEdge(7, 7): //7.7
		g.addNode(8): //0
		g.addNode(9): //0
		g.existsEdge(7, 8): //false
		g.existsEdge(8, 7): //false
		g.existsEdge(8, 8): //false
		g.existsEdge(8, 9): //true
		g.existsEdge(9, 8): //true
	    g.existsEdge(9, 9): //false
		g.addEdge(7,8, 7.8): //0
		g.addEdge(8,7, 8.7): //0
		g.addEdge(8,8, 8.8): //0
		g.addEdge(8,9, 8.9): //-4
		g.addEdge(9,8, 9.8): //-4
		g.addEdge(9,9, 9.9): 0
		g.addEdge(7,9, 7.9): 0
		g.addEdge(9,7, 9.7): 0
		g.getEdge(7, 7) --> -4.0
		g.getEdge(7, 8) --> 7.8
		g.getEdge(7, 9) --> 7.9
		g.getEdge(8, 7) --> 8.7
		g.getEdge(8, 8) --> 8.8
		g.getEdge(8, 9) --> 1.2
		g.getEdge(9, 7) --> 9.7
		g.getEdge(9, 8) --> 2.1
		g.getEdge(9, 9) --> 9.9
		g.removeNode(7): 0
		g.removeNode(7): 0
		g.getEdge(7, 7) --> -4.0
		g.getEdge(7, 8) --> 7.8
		g.getEdge(7, 9) --> 7.9
		g.getEdge(8, 7) --> 8.7
		g.getEdge(8, 8) --> 8.8
		g.getEdge(8, 9) --> 1.2
		g.getEdge(9, 7) --> 9.7
		g.getEdge(9, 8) --> 2.1
		g.getEdge(9, 9) --> 9.9
		g.removeNode(null): -1
		g.addNode(null): -4
		g.addNode(10): 0
		g.getEdge(8, 10) --> 8.7
		g.getEdge(10, 9) --> 7.9
		g.addNode(null): -6
		g.addEdge(8,8,-8.8): -12
		g.addEdge(7,8,-7.8): -9
		g.addEdge(8,7,-8.7): -10
		g.addEdge(7,7,-7.7): -11
		g.addEdge(null,8,0.8): -1
		g.addEdge(8,null,0.8): -2
		g.addEdge(null,null,0.8): -3
		g.getEdge(null,10): -1.0
		g.getEdge(10,null): -2.0
		g.getEdge(null,null): -3.0
		g.existsNode(null): false
		g.existsEdge(null,null): false
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-10-06 11:46:18.425
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-10-06 11:46:18.427
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-10-06 11:46:19.438
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package p2Grafos;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import org.junit.Test;

/**
 * Titulo: Clase GraphTests
 * 
 * @author UO281847
 * @version 24/09/2021
 */
public class GraphTests {
	private Graph<Integer> g;
///*
// * Pruebas del método addNode:	
// */
//	/**
//	 * Test del método addNode sin errores
//	 */
//	@Test
//	public void testAddNodeFirst() {
//		Graph<Integer> g = new Graph<Integer>(3);
//		int node = 12;
//		assertEquals(0, g.addNode(node));
//		System.out.println(g.toString());	
//	}	
//	/**
//	 * Test del método addNode con nodo no valido
//	 */
//	@Test
//	public void testAddNodeNotValid() {
//		Graph<Integer> g = new Graph<Integer>(3);
//		int node = 1;
//		int node2 = 18;
//		assertEquals(0, g.addNode(node));
//		assertEquals(0, g.addNode(node2));
//		assertEquals(-5, g.addNode(null));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addNode cuando ya esta lleno
//	 */
//	@Test
//	public void testAddNodeFull() {
//		Graph<Integer> g = new Graph<Integer>(3);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 39;
//		int node4= 2;
//		assertEquals(0, g.addNode(node));
//		assertEquals(0, g.addNode(node2));
//		assertEquals(0, g.addNode(node3));
//		assertEquals(-2, g.addNode(node4));		
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addNode cuando ya existe
//	 */
//	@Test
//	public void testAddNodeAlreadyExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 39;
//		int node4 = 19;
//		int node5= 19;
//		assertEquals(0, g.addNode(node));
//		assertEquals(0, g.addNode(node2));
//		assertEquals(0, g.addNode(node3));
//		assertEquals(0, g.addNode(node4));
//		assertEquals(-1, g.addNode(node5));	
//		System.out.println(g.toString());	
//	}
//	
///*
// * Pruebas del método getNode:
// */
//	/**
//	 * Test del método getNode que devuelve la posición
//	 */
//	@Test
//	public void testGetNodeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		g.addNode(node);
//		assertEquals(0, g.getNode(node));
//	}
//	/**
//	 * Test del método getNode que devuelve la posición ya añadido
//	 */
//	@Test
//	public void testGetNodeVarious() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 23;
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(1, g.getNode(node2));
//	}
//	/**
//	 * Test del método getNode que devuelve -1
//	 */
//	@Test
//	public void testGetNodeDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 23;
//		g.addNode(node);
//		assertEquals(-1, g.getNode(node2));
//	}
//
///**
// * Pruebas del método existsNode:
// */
//	/**
//	 * Test del método existsNode que devuelve true
//	 */
//	@Test
//	public void testExistsNodeOne() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		g.addNode(node);
//		assertTrue(g.existsNode(node));
//	}
//	/**
//	 * Test del método existsNode que devuelve true
//	 */
//	@Test
//	public void testExistsNodeVarious() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 23;
//		g.addNode(node);
//		g.addNode(node2);
//		assertTrue(g.existsNode(node2));
//	}
//	/**
//	 * Test del método existsNode que devuelve true
//	 */
//	@Test
//	public void testExistsNodeFalse() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 23;
//		g.addNode(node);
//		assertFalse(g.existsNode(node2));
//	}
//
///*
// * Pruebas del método addEdge:
// */
//	/**
//	 * Test del método addEdge que no tiene errores
//	 */
//	@Test
//	public void testAddEdgeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;		
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(0, g.addEdge(node, node2, 12));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde no existe el nodo origen
//	 */
//	@Test
//	public void testAddEdgeSourceDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 23;
//		g.addNode(node);
//		g.addNode(node2);		
//		assertEquals(-1, g.addEdge(node3, node2, 12));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde no existe el nodo destino
//	 */
//	@Test
//	public void testAddEdgeTargetDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 23;
//		g.addNode(node);
//		g.addNode(node2);		
//		assertEquals(-2, g.addEdge(node, node3, 12));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde ya existe la arista
//	 */
//	@Test
//	public void testAddEdgeEdgeExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 12);
//		assertEquals(-4, g.addEdge(node, node2, 12));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde el peso no es valido
//	 */
//	@Test
//	public void testAddEdgeEdgeWightError() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(-8, g.addEdge(node, node2, -4));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde no existen los nodos 
//	 */
//	@Test
//	public void testAddEdgeSourceTargetError() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 12;
//		int node4 = 56;
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(-3, g.addEdge(node3, node4, 4));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde ya existe la arista y el peso no es valido
//	 */
//	@Test
//	public void testAddEdgeEdgeExistsEdgeWeightError() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-12, g.addEdge(node, node2, -4));
//		System.out.println(g.toString());	
//	}
//	
///*
// * Pruebas del método getEdge:
// */
//	/**
//	 * Test del método getEdge que no tiene errores
//	 */
//	@Test
//	public void testGetEdgeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(4, g.getEdge(node, node2),0.1);
//	}
//	/**
//	 * Test del método getEdge donde no existe el nodo origen
//	 */
//	@Test
//	public void testGetEdgeSourceDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 4;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-1, g.getEdge(node3, node2),0.1);
//	}
//	/**
//	 * Test del método getEdge donde no existe el nodo destino
//	 */
//	@Test
//	public void testGetEdgeTargetDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 4;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-2, g.getEdge(node, node3),0.1);
//	}
//	/**
//	 * Test del método getEdge donde existen los nodos y no la arista
//	 */
//	@Test
//	public void testGetEdgeEdgeDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(-4, g.getEdge(node, node2),0.1);
//	}
//	/**
//	 * Test del método getEdge donde no existen los nodos
//	 */
//	@Test
//	public void testGetEdgeBothDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 4;
//		int node4 = 6;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-3, g.getEdge(node3, node4),0.1);
//	}
//	
///*
// * Pruebas del método existsEdge:
// */
//	/**
//	 * Test del método existsEdge que no tiene errores
//	 */
//	@Test
//	public void testExistsEdgeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertTrue(g.existsEdge(node, node2));
//	}
//	/**
//	 * Test del método existsEdge donde no existe el nodo origen
//	 */
//	@Test
//	public void testExistsEdgeSourceDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3= 8;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertFalse(g.existsEdge(node3, node2));
//	}
//	/**
//	 * Test del método existsEdge donde no existe el nodo destino
//	 */
//	@Test
//	public void testExistsEdgeTargetDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3= 8;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertFalse(g.existsEdge(node, node3));
//	}
//	/**
//	 * Test del método existsEdge donde no existen los nodos
//	 */
//	@Test
//	public void testExistsEdgeBothDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		int node4 = 12;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertFalse(g.existsEdge(node3, node4));
//	}
//	
///*
// * Pruebas del método removeEdge:
// */
//	/**
//	 * Test del método removeEdge que no tiene errores 
//	 */
//	@Test
//	public void testRemoveEdgeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		int node4 = 12;
//		g.addNode(node);
//		g.addNode(node2); 
//		g.addNode(node3);
//		g.addNode(node4);
//		g.addEdge(node, node2, 4);
//		g.addEdge(node3, node4, 12);
//		assertEquals(0, g.removeEdge(node3, node4));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeEdge donde no existe el nodo origen
//	 */
//	@Test
//	public void testRemoveEdgeSourceDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		g.addNode(node);
//		g.addNode(node2); 
//		g.addEdge(node, node2, 4);
//		assertEquals(-1, g.removeEdge(node3, node2));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeEdge donde no existe el nodo destino
//	 */
//	@Test
//	public void testRemoveEdgeTargetDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		g.addNode(node);
//		g.addNode(node2); 
//		g.addEdge(node, node2, 4);
//		assertEquals(-2, g.removeEdge(node2, node3));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeEdge donde existen los nodos y no la arista
//	 */
//	@Test
//	public void testRemoveEdgeEdgeDontExistsNodesExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2); 
//		g.addEdge(node, node2, 4);
//		assertEquals(-4, g.removeEdge(node2, node));
//		System.out.println(g.toString());
//	}	
//	/**
//	 * Test del método removeEdge donde no existen los nodos
//	 */
//	@Test
//	public void testRemoveEdgeNodesDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		int node4 = 12;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-3, g.removeEdge(node3, node4));
//		System.out.println(g.toString());
//	}
///*
// * Pruebas del método removeNode:
// */
//	/**
//	 * Test del método removeNode que no tiene errores
//	 */
//	@Test
//	public void testRemoveNodeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;		
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(0, g.removeNode(node));
//		assertFalse(g.existsNode(node));
//		assertFalse(g.existsEdge(node, node2));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeNode que no tiene errores y borra toda la matriz
//	 */
//	@Test
//	public void testRemoveNodeVarious() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		int node4 = 12;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		g.addEdge(node, node, 12);
//		g.addEdge(node3, node, 7);
//		g.addEdge(node, node4, 15);
//		g.addEdge(node, node3, 9);
//		assertEquals(0, g.removeNode(node));
//		assertFalse(g.existsNode(node));
//		assertFalse(g.existsEdge(node, node2));
//		assertFalse(g.existsEdge(node, node));
//		assertFalse(g.existsEdge(node3, node));
//		assertFalse(g.existsEdge(node, node4));
//		assertFalse(g.existsEdge(node, node3));
//		System.out.println(g.toString());
//	}	
//	/**
//	 * Test del método removeNode donde el nodo no es valido
//	 */
//	@Test
//	public void testRemoveNodeNotValid() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;		
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-1, g.removeNode(null));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeNode donde el nodo no existe
//	 */
//	@Test
//	public void testRemoveNodeDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 12;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-1, g.removeNode(node3));
//		System.out.println(g.toString());
//	}
	/**
	 * Pruebas basicas de nodos
	 */
//	@Test
//	public void basicNodeTest() {
//		g=new Graph<Integer>(3); 
//	    assertFalse(g.existsNode(1)); //false
//	    assertFalse(g.existsNode(2)); //false
//	    assertEquals(0,g.addNode(1)); //0
//		assertEquals(0,g.addNode(2)); //0
//		assertTrue(g.existsNode(1)); //true
//		assertTrue(g.existsNode(2)); //true
//		assertEquals(-1,g.addNode(1)); //-1
//		assertEquals(-1,g.addNode(2)); //-1
//		assertEquals(0,g.addNode(3)); //0
//		assertEquals(-2,g.addNode(4)); //-2
//		assertFalse(g.existsNode(4)); //false
//		assertFalse(g.existsNode(5)); //false
//	}
	
//	@Test
//	public void basicEdgeTest() {
//		g=new Graph<Integer>(3); 
//		assertFalse(g.existsEdge(1,2)); //false
//		assertEquals(-3.0,g.getEdge(1,2),0.1); //-3.0
//		assertEquals(0,g.addNode(1)); //0
//		assertFalse(g.existsEdge(1,2)); //false
//		assertEquals(-2.0,g.getEdge(1,2),0.1); //-2.0
//		assertFalse(g.existsEdge(2,1)); //false
//		assertEquals(-1.0,g.getEdge(2,1),0.1); //-1.0
//		assertEquals(0,g.addNode(2)); //0
//		assertFalse(g.existsEdge(1,2)); //false
//		assertEquals(-4.0,g.getEdge(1,2),0.1); //-4.0
//		assertEquals(0,g.addEdge(1,2,12.12)); //0
//		assertEquals(-4,g.addEdge(1,2,12.1212)); //-4
//		assertEquals(0,g.addNode(3)); //0
//		assertFalse(g.existsEdge(1,3)); //false
//		assertFalse(g.existsEdge(3,2)); //false
//		assertEquals(-4.0,g.getEdge(1,3),0.1); //-4.0
//		assertEquals(-4.0,g.getEdge(3,2),0.1); //-4.0
//		assertEquals(0,g.addEdge(1,1,11.11)); //0
//		assertEquals(-4,g.addEdge(1,2,12.12)); //-4
//		assertEquals(0,g.addEdge(1,3,13.13)); //0
//		assertEquals(0,g.addEdge(2,1,21.21)); //0
//		assertEquals(0,g.addEdge(2,2,22.22)); //0
//		assertEquals(0,g.addEdge(2,3,23.23)); //0
//		assertEquals(0,g.addEdge(3,1,31.31)); //0
//		assertEquals(0,g.addEdge(3,2,32.32)); //0
//		assertEquals(0,g.addEdge(3,3,33.33)); //0
//		assertEquals(-4,g.addEdge(1,1,11.11)); //-4
//		assertEquals(-4,g.addEdge(1,2,12.12)); //-4
//		assertEquals(-4,g.addEdge(1,3,13.13)); //-4
//		assertEquals(-4,g.addEdge(2,1,21.21)); //-4
//		assertEquals(-4,g.addEdge(2,2,22.22)); //-4
//		assertEquals(-4,g.addEdge(2,3,23.23)); //-4
//		assertEquals(-4,g.addEdge(3,1,31.31)); //-4
//		assertEquals(-4,g.addEdge(3,2,32.32)); //-4
//		assertEquals(-4,g.addEdge(3,3,33.33)); //-4
//		g.getEdge(1,1,11.11); //11.11
//		g.getEdge(1,2,12.12); //12.12
//		g.getEdge(1,3,13.13); //13.129999999999999
//		g.getEdge(2,1,21.21); //21.21
//		g.getEdge(2,2,22.22); //22.22
//		g.getEdge(2,3,23.23); //23.23
//		g.getEdge(3,1,31.31); //31.310000000000002
//		g.getEdge(3,2,32.32); //32.32
//		g.getEdge(3,3,33.33); //33.33
//	}
	
	@Test
	public void basicEvolutionTest() {
		g=new Graph<Integer>(3); 
		assertFalse(g.existsNode(1)); //false
		assertFalse(g.existsNode(2)); //false
		assertEquals(0,g.addNode(1)); //0
		assertEquals(0,g.addNode(2)); //0
		assertTrue(g.existsNode(1)); //true
		assertTrue(g.existsNode(2)); //true
		assertEquals(-1,g.addNode(1)); //-1
		assertEquals(-1,g.addNode(2)); //-1
		assertEquals(0,g.addEdge(1,2, 1.2)); //0
		assertEquals(0,g.addEdge(2,1, 2.1));//0
		assertEquals(0,g.addEdge(1,1, 1.1)); //0
		assertEquals(1.2,g.getEdge(1,2),0.1); //1.2
		assertEquals(2.1,g.getEdge(2,1),0.1); //2.1
		assertEquals(1.1,g.getEdge(1,1),0.1); //1.1
		assertEquals(-2.0,g.getEdge(2,3),0.1); //-2.0
		assertTrue(g.existsEdge(1,2)); //true
		assertTrue(g.existsEdge(2,1)); //true
		assertTrue(g.existsEdge(1,1)); //true
		assertFalse(g.existsEdge(2,2)); //false
		assertEquals(-4,g.removeEdge(2,2)); //-4
		assertEquals(0,g.addEdge(2,2,2.2)); //0
		assertEquals(2.2,g.getEdge(2,2),0.1); //2.2
		assertTrue(g.existsEdge(2,2)); //true
		assertEquals(0,g.removeEdge(2,2)); //0
		assertEquals(-1,g.removeNode(3)); //-1
		assertEquals(0,g.addNode(3)); //0		
		assertEquals(-2,g.addNode(4)); //-2
		assertEquals(-4.0,g.getEdge(1, 3),0.1); //-4.0
		assertEquals(0,g.addEdge(1,3, 1.3)); //0	
		assertTrue(g.existsEdge(1, 3)); //true	
		assertEquals(1.3,g.getEdge(1, 3),0.1); //1.3
		assertEquals(-2.0,g.getEdge(1, 4),0.1); //-2.0
		assertEquals(-1.0,g.getEdge(5,1),0.1); //-1.0
		assertEquals(-3.0,g.getEdge(5,4),0.1); //-3.0
		assertEquals(0,g.removeNode(3)); //0
		assertEquals(-1,g.removeNode(3)); //0---------------->(-1)
		assertFalse(g.existsEdge(1, 3)); //true---------------->(false)	
		assertEquals(-2.0,g.getEdge(1, 3),0.1); //1.3------------------->(-2.0)
		assertEquals(0,g.removeNode(2)); //0
		assertEquals(-1,g.removeNode(2)); //0--------------------->(-1)
		assertTrue(g.existsEdge(1, 1)); //true
		assertEquals(0,g.removeNode(1)); //0
		assertFalse(g.existsNode(1)); //true---------------------->(false)
		assertFalse(g.existsNode(2)); //true---------------------->(false)
		assertFalse(g.existsNode(3)); //true---------------------->(false)
		assertFalse(g.existsNode(4)); //false
		assertEquals(0,g.addNode(4)); //0
		assertTrue(g.existsNode(4)); //true
		assertEquals(0,g.addEdge(4,4, 4.4)); //0
		assertTrue(g.existsEdge(4, 4)); //true
		g.getEdge(4, 4): //4.4
		g.removeNode(4): //0
		g.removeNode(4): //0
		g.existsEdge(4, 4): //true-------------------->(false)
		g.addNode(7): //0
		g.removeNode(2): //0
		g.removeNode(3): //0
		g.removeNode(4): //-1
		g.existsEdge(7, 7): //false
		g.addEdge(7,7, 7.7): //0
		g.addEdge(7,7, 17.17): //-4
		g.getEdge(7, 7): //7.7
		g.addNode(8): //0
		g.addNode(9): //0
		g.existsEdge(7, 8): //false
		g.existsEdge(8, 7): //false
		g.existsEdge(8, 8): //false
		g.existsEdge(8, 9): //true
		g.existsEdge(9, 8): //true
	    g.existsEdge(9, 9): //false
		g.addEdge(7,8, 7.8): //0
		g.addEdge(8,7, 8.7): //0
		g.addEdge(8,8, 8.8): //0
		g.addEdge(8,9, 8.9): //-4
		g.addEdge(9,8, 9.8): //-4
		g.addEdge(9,9, 9.9): //0
		g.addEdge(7,9, 7.9): 0
		g.addEdge(9,7, 9.7): 0
		g.getEdge(7, 7) --> -4.0
		g.getEdge(7, 8) --> 7.8
		g.getEdge(7, 9) --> 7.9
		g.getEdge(8, 7) --> 8.7
		g.getEdge(8, 8) --> 8.8
		g.getEdge(8, 9) --> 1.2
		g.getEdge(9, 7) --> 9.7
		g.getEdge(9, 8) --> 2.1
		g.getEdge(9, 9) --> 9.9
		g.removeNode(7): 0
		g.removeNode(7): 0
		g.getEdge(7, 7) --> -4.0
		g.getEdge(7, 8) --> 7.8
		g.getEdge(7, 9) --> 7.9
		g.getEdge(8, 7) --> 8.7
		g.getEdge(8, 8) --> 8.8
		g.getEdge(8, 9) --> 1.2
		g.getEdge(9, 7) --> 9.7
		g.getEdge(9, 8) --> 2.1
		g.getEdge(9, 9) --> 9.9
		g.removeNode(null): -1
		g.addNode(null): -4
		g.addNode(10): 0
		g.getEdge(8, 10) --> 8.7
		g.getEdge(10, 9) --> 7.9
		g.addNode(null): -6
		g.addEdge(8,8,-8.8): -12
		g.addEdge(7,8,-7.8): -9
		g.addEdge(8,7,-8.7): -10
		g.addEdge(7,7,-7.7): -11
		g.addEdge(null,8,0.8): -1
		g.addEdge(8,null,0.8): -2
		g.addEdge(null,null,0.8): -3
		g.getEdge(null,10): -1.0
		g.getEdge(10,null): -2.0
		g.getEdge(null,null): -3.0
		g.existsNode(null): false
		g.existsEdge(null,null): false
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-10-06 11:46:19.441
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-10-06 11:46:19.442
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-10-06 11:46:20.454
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package p2Grafos;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import org.junit.Test;

/**
 * Titulo: Clase GraphTests
 * 
 * @author UO281847
 * @version 24/09/2021
 */
public class GraphTests {
	private Graph<Integer> g;
///*
// * Pruebas del método addNode:	
// */
//	/**
//	 * Test del método addNode sin errores
//	 */
//	@Test
//	public void testAddNodeFirst() {
//		Graph<Integer> g = new Graph<Integer>(3);
//		int node = 12;
//		assertEquals(0, g.addNode(node));
//		System.out.println(g.toString());	
//	}	
//	/**
//	 * Test del método addNode con nodo no valido
//	 */
//	@Test
//	public void testAddNodeNotValid() {
//		Graph<Integer> g = new Graph<Integer>(3);
//		int node = 1;
//		int node2 = 18;
//		assertEquals(0, g.addNode(node));
//		assertEquals(0, g.addNode(node2));
//		assertEquals(-5, g.addNode(null));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addNode cuando ya esta lleno
//	 */
//	@Test
//	public void testAddNodeFull() {
//		Graph<Integer> g = new Graph<Integer>(3);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 39;
//		int node4= 2;
//		assertEquals(0, g.addNode(node));
//		assertEquals(0, g.addNode(node2));
//		assertEquals(0, g.addNode(node3));
//		assertEquals(-2, g.addNode(node4));		
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addNode cuando ya existe
//	 */
//	@Test
//	public void testAddNodeAlreadyExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 39;
//		int node4 = 19;
//		int node5= 19;
//		assertEquals(0, g.addNode(node));
//		assertEquals(0, g.addNode(node2));
//		assertEquals(0, g.addNode(node3));
//		assertEquals(0, g.addNode(node4));
//		assertEquals(-1, g.addNode(node5));	
//		System.out.println(g.toString());	
//	}
//	
///*
// * Pruebas del método getNode:
// */
//	/**
//	 * Test del método getNode que devuelve la posición
//	 */
//	@Test
//	public void testGetNodeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		g.addNode(node);
//		assertEquals(0, g.getNode(node));
//	}
//	/**
//	 * Test del método getNode que devuelve la posición ya añadido
//	 */
//	@Test
//	public void testGetNodeVarious() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 23;
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(1, g.getNode(node2));
//	}
//	/**
//	 * Test del método getNode que devuelve -1
//	 */
//	@Test
//	public void testGetNodeDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 23;
//		g.addNode(node);
//		assertEquals(-1, g.getNode(node2));
//	}
//
///**
// * Pruebas del método existsNode:
// */
//	/**
//	 * Test del método existsNode que devuelve true
//	 */
//	@Test
//	public void testExistsNodeOne() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		g.addNode(node);
//		assertTrue(g.existsNode(node));
//	}
//	/**
//	 * Test del método existsNode que devuelve true
//	 */
//	@Test
//	public void testExistsNodeVarious() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 23;
//		g.addNode(node);
//		g.addNode(node2);
//		assertTrue(g.existsNode(node2));
//	}
//	/**
//	 * Test del método existsNode que devuelve true
//	 */
//	@Test
//	public void testExistsNodeFalse() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 23;
//		g.addNode(node);
//		assertFalse(g.existsNode(node2));
//	}
//
///*
// * Pruebas del método addEdge:
// */
//	/**
//	 * Test del método addEdge que no tiene errores
//	 */
//	@Test
//	public void testAddEdgeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;		
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(0, g.addEdge(node, node2, 12));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde no existe el nodo origen
//	 */
//	@Test
//	public void testAddEdgeSourceDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 23;
//		g.addNode(node);
//		g.addNode(node2);		
//		assertEquals(-1, g.addEdge(node3, node2, 12));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde no existe el nodo destino
//	 */
//	@Test
//	public void testAddEdgeTargetDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 23;
//		g.addNode(node);
//		g.addNode(node2);		
//		assertEquals(-2, g.addEdge(node, node3, 12));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde ya existe la arista
//	 */
//	@Test
//	public void testAddEdgeEdgeExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 12);
//		assertEquals(-4, g.addEdge(node, node2, 12));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde el peso no es valido
//	 */
//	@Test
//	public void testAddEdgeEdgeWightError() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(-8, g.addEdge(node, node2, -4));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde no existen los nodos 
//	 */
//	@Test
//	public void testAddEdgeSourceTargetError() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 12;
//		int node4 = 56;
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(-3, g.addEdge(node3, node4, 4));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde ya existe la arista y el peso no es valido
//	 */
//	@Test
//	public void testAddEdgeEdgeExistsEdgeWeightError() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-12, g.addEdge(node, node2, -4));
//		System.out.println(g.toString());	
//	}
//	
///*
// * Pruebas del método getEdge:
// */
//	/**
//	 * Test del método getEdge que no tiene errores
//	 */
//	@Test
//	public void testGetEdgeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(4, g.getEdge(node, node2),0.1);
//	}
//	/**
//	 * Test del método getEdge donde no existe el nodo origen
//	 */
//	@Test
//	public void testGetEdgeSourceDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 4;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-1, g.getEdge(node3, node2),0.1);
//	}
//	/**
//	 * Test del método getEdge donde no existe el nodo destino
//	 */
//	@Test
//	public void testGetEdgeTargetDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 4;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-2, g.getEdge(node, node3),0.1);
//	}
//	/**
//	 * Test del método getEdge donde existen los nodos y no la arista
//	 */
//	@Test
//	public void testGetEdgeEdgeDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(-4, g.getEdge(node, node2),0.1);
//	}
//	/**
//	 * Test del método getEdge donde no existen los nodos
//	 */
//	@Test
//	public void testGetEdgeBothDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 4;
//		int node4 = 6;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-3, g.getEdge(node3, node4),0.1);
//	}
//	
///*
// * Pruebas del método existsEdge:
// */
//	/**
//	 * Test del método existsEdge que no tiene errores
//	 */
//	@Test
//	public void testExistsEdgeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertTrue(g.existsEdge(node, node2));
//	}
//	/**
//	 * Test del método existsEdge donde no existe el nodo origen
//	 */
//	@Test
//	public void testExistsEdgeSourceDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3= 8;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertFalse(g.existsEdge(node3, node2));
//	}
//	/**
//	 * Test del método existsEdge donde no existe el nodo destino
//	 */
//	@Test
//	public void testExistsEdgeTargetDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3= 8;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertFalse(g.existsEdge(node, node3));
//	}
//	/**
//	 * Test del método existsEdge donde no existen los nodos
//	 */
//	@Test
//	public void testExistsEdgeBothDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		int node4 = 12;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertFalse(g.existsEdge(node3, node4));
//	}
//	
///*
// * Pruebas del método removeEdge:
// */
//	/**
//	 * Test del método removeEdge que no tiene errores 
//	 */
//	@Test
//	public void testRemoveEdgeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		int node4 = 12;
//		g.addNode(node);
//		g.addNode(node2); 
//		g.addNode(node3);
//		g.addNode(node4);
//		g.addEdge(node, node2, 4);
//		g.addEdge(node3, node4, 12);
//		assertEquals(0, g.removeEdge(node3, node4));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeEdge donde no existe el nodo origen
//	 */
//	@Test
//	public void testRemoveEdgeSourceDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		g.addNode(node);
//		g.addNode(node2); 
//		g.addEdge(node, node2, 4);
//		assertEquals(-1, g.removeEdge(node3, node2));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeEdge donde no existe el nodo destino
//	 */
//	@Test
//	public void testRemoveEdgeTargetDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		g.addNode(node);
//		g.addNode(node2); 
//		g.addEdge(node, node2, 4);
//		assertEquals(-2, g.removeEdge(node2, node3));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeEdge donde existen los nodos y no la arista
//	 */
//	@Test
//	public void testRemoveEdgeEdgeDontExistsNodesExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2); 
//		g.addEdge(node, node2, 4);
//		assertEquals(-4, g.removeEdge(node2, node));
//		System.out.println(g.toString());
//	}	
//	/**
//	 * Test del método removeEdge donde no existen los nodos
//	 */
//	@Test
//	public void testRemoveEdgeNodesDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		int node4 = 12;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-3, g.removeEdge(node3, node4));
//		System.out.println(g.toString());
//	}
///*
// * Pruebas del método removeNode:
// */
//	/**
//	 * Test del método removeNode que no tiene errores
//	 */
//	@Test
//	public void testRemoveNodeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;		
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(0, g.removeNode(node));
//		assertFalse(g.existsNode(node));
//		assertFalse(g.existsEdge(node, node2));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeNode que no tiene errores y borra toda la matriz
//	 */
//	@Test
//	public void testRemoveNodeVarious() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		int node4 = 12;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		g.addEdge(node, node, 12);
//		g.addEdge(node3, node, 7);
//		g.addEdge(node, node4, 15);
//		g.addEdge(node, node3, 9);
//		assertEquals(0, g.removeNode(node));
//		assertFalse(g.existsNode(node));
//		assertFalse(g.existsEdge(node, node2));
//		assertFalse(g.existsEdge(node, node));
//		assertFalse(g.existsEdge(node3, node));
//		assertFalse(g.existsEdge(node, node4));
//		assertFalse(g.existsEdge(node, node3));
//		System.out.println(g.toString());
//	}	
//	/**
//	 * Test del método removeNode donde el nodo no es valido
//	 */
//	@Test
//	public void testRemoveNodeNotValid() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;		
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-1, g.removeNode(null));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeNode donde el nodo no existe
//	 */
//	@Test
//	public void testRemoveNodeDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 12;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-1, g.removeNode(node3));
//		System.out.println(g.toString());
//	}
	/**
	 * Pruebas basicas de nodos
	 */
//	@Test
//	public void basicNodeTest() {
//		g=new Graph<Integer>(3); 
//	    assertFalse(g.existsNode(1)); //false
//	    assertFalse(g.existsNode(2)); //false
//	    assertEquals(0,g.addNode(1)); //0
//		assertEquals(0,g.addNode(2)); //0
//		assertTrue(g.existsNode(1)); //true
//		assertTrue(g.existsNode(2)); //true
//		assertEquals(-1,g.addNode(1)); //-1
//		assertEquals(-1,g.addNode(2)); //-1
//		assertEquals(0,g.addNode(3)); //0
//		assertEquals(-2,g.addNode(4)); //-2
//		assertFalse(g.existsNode(4)); //false
//		assertFalse(g.existsNode(5)); //false
//	}
	
//	@Test
//	public void basicEdgeTest() {
//		g=new Graph<Integer>(3); 
//		assertFalse(g.existsEdge(1,2)); //false
//		assertEquals(-3.0,g.getEdge(1,2),0.1); //-3.0
//		assertEquals(0,g.addNode(1)); //0
//		assertFalse(g.existsEdge(1,2)); //false
//		assertEquals(-2.0,g.getEdge(1,2),0.1); //-2.0
//		assertFalse(g.existsEdge(2,1)); //false
//		assertEquals(-1.0,g.getEdge(2,1),0.1); //-1.0
//		assertEquals(0,g.addNode(2)); //0
//		assertFalse(g.existsEdge(1,2)); //false
//		assertEquals(-4.0,g.getEdge(1,2),0.1); //-4.0
//		assertEquals(0,g.addEdge(1,2,12.12)); //0
//		assertEquals(-4,g.addEdge(1,2,12.1212)); //-4
//		assertEquals(0,g.addNode(3)); //0
//		assertFalse(g.existsEdge(1,3)); //false
//		assertFalse(g.existsEdge(3,2)); //false
//		assertEquals(-4.0,g.getEdge(1,3),0.1); //-4.0
//		assertEquals(-4.0,g.getEdge(3,2),0.1); //-4.0
//		assertEquals(0,g.addEdge(1,1,11.11)); //0
//		assertEquals(-4,g.addEdge(1,2,12.12)); //-4
//		assertEquals(0,g.addEdge(1,3,13.13)); //0
//		assertEquals(0,g.addEdge(2,1,21.21)); //0
//		assertEquals(0,g.addEdge(2,2,22.22)); //0
//		assertEquals(0,g.addEdge(2,3,23.23)); //0
//		assertEquals(0,g.addEdge(3,1,31.31)); //0
//		assertEquals(0,g.addEdge(3,2,32.32)); //0
//		assertEquals(0,g.addEdge(3,3,33.33)); //0
//		assertEquals(-4,g.addEdge(1,1,11.11)); //-4
//		assertEquals(-4,g.addEdge(1,2,12.12)); //-4
//		assertEquals(-4,g.addEdge(1,3,13.13)); //-4
//		assertEquals(-4,g.addEdge(2,1,21.21)); //-4
//		assertEquals(-4,g.addEdge(2,2,22.22)); //-4
//		assertEquals(-4,g.addEdge(2,3,23.23)); //-4
//		assertEquals(-4,g.addEdge(3,1,31.31)); //-4
//		assertEquals(-4,g.addEdge(3,2,32.32)); //-4
//		assertEquals(-4,g.addEdge(3,3,33.33)); //-4
//		g.getEdge(1,1,11.11); //11.11
//		g.getEdge(1,2,12.12); //12.12
//		g.getEdge(1,3,13.13); //13.129999999999999
//		g.getEdge(2,1,21.21); //21.21
//		g.getEdge(2,2,22.22); //22.22
//		g.getEdge(2,3,23.23); //23.23
//		g.getEdge(3,1,31.31); //31.310000000000002
//		g.getEdge(3,2,32.32); //32.32
//		g.getEdge(3,3,33.33); //33.33
//	}
	
	@Test
	public void basicEvolutionTest() {
		g=new Graph<Integer>(3); 
		assertFalse(g.existsNode(1)); //false
		assertFalse(g.existsNode(2)); //false
		assertEquals(0,g.addNode(1)); //0
		assertEquals(0,g.addNode(2)); //0
		assertTrue(g.existsNode(1)); //true
		assertTrue(g.existsNode(2)); //true
		assertEquals(-1,g.addNode(1)); //-1
		assertEquals(-1,g.addNode(2)); //-1
		assertEquals(0,g.addEdge(1,2, 1.2)); //0
		assertEquals(0,g.addEdge(2,1, 2.1));//0
		assertEquals(0,g.addEdge(1,1, 1.1)); //0
		assertEquals(1.2,g.getEdge(1,2),0.1); //1.2
		assertEquals(2.1,g.getEdge(2,1),0.1); //2.1
		assertEquals(1.1,g.getEdge(1,1),0.1); //1.1
		assertEquals(-2.0,g.getEdge(2,3),0.1); //-2.0
		assertTrue(g.existsEdge(1,2)); //true
		assertTrue(g.existsEdge(2,1)); //true
		assertTrue(g.existsEdge(1,1)); //true
		assertFalse(g.existsEdge(2,2)); //false
		assertEquals(-4,g.removeEdge(2,2)); //-4
		assertEquals(0,g.addEdge(2,2,2.2)); //0
		assertEquals(2.2,g.getEdge(2,2),0.1); //2.2
		assertTrue(g.existsEdge(2,2)); //true
		assertEquals(0,g.removeEdge(2,2)); //0
		assertEquals(-1,g.removeNode(3)); //-1
		assertEquals(0,g.addNode(3)); //0		
		assertEquals(-2,g.addNode(4)); //-2
		assertEquals(-4.0,g.getEdge(1, 3),0.1); //-4.0
		assertEquals(0,g.addEdge(1,3, 1.3)); //0	
		assertTrue(g.existsEdge(1, 3)); //true	
		assertEquals(1.3,g.getEdge(1, 3),0.1); //1.3
		assertEquals(-2.0,g.getEdge(1, 4),0.1); //-2.0
		assertEquals(-1.0,g.getEdge(5,1),0.1); //-1.0
		assertEquals(-3.0,g.getEdge(5,4),0.1); //-3.0
		assertEquals(0,g.removeNode(3)); //0
		assertEquals(-1,g.removeNode(3)); //0---------------->(-1)
		assertFalse(g.existsEdge(1, 3)); //true---------------->(false)	
		assertEquals(-2.0,g.getEdge(1, 3),0.1); //1.3------------------->(-2.0)
		assertEquals(0,g.removeNode(2)); //0
		assertEquals(-1,g.removeNode(2)); //0--------------------->(-1)
		assertTrue(g.existsEdge(1, 1)); //true
		assertEquals(0,g.removeNode(1)); //0
		assertFalse(g.existsNode(1)); //true---------------------->(false)
		assertFalse(g.existsNode(2)); //true---------------------->(false)
		assertFalse(g.existsNode(3)); //true---------------------->(false)
		assertFalse(g.existsNode(4)); //false
		assertEquals(0,g.addNode(4)); //0
		assertTrue(g.existsNode(4)); //true
		assertEquals(0,g.addEdge(4,4, 4.4)); //0
		assertTrue(g.existsEdge(4, 4)); //true
		g.getEdge(4, 4): //4.4
		g.removeNode(4): //0
		g.removeNode(4): //0
		g.existsEdge(4, 4): //true-------------------->(false)
		g.addNode(7): //0
		g.removeNode(2): //0
		g.removeNode(3): //0
		g.removeNode(4): //-1
		g.existsEdge(7, 7): //false
		g.addEdge(7,7, 7.7): //0
		g.addEdge(7,7, 17.17): //-4
		g.getEdge(7, 7): //7.7
		g.addNode(8): //0
		g.addNode(9): //0
		g.existsEdge(7, 8): //false
		g.existsEdge(8, 7): //false
		g.existsEdge(8, 8): //false
		g.existsEdge(8, 9): //true
		g.existsEdge(9, 8): //true
	    g.existsEdge(9, 9): //false
		g.addEdge(7,8, 7.8): //0
		g.addEdge(8,7, 8.7): //0
		g.addEdge(8,8, 8.8): //0
		g.addEdge(8,9, 8.9): //-4
		g.addEdge(9,8, 9.8): //-4
		g.addEdge(9,9, 9.9): //0
		g.addEdge(7,9, 7.9): //0
		g.addEdge(9,7, 9.7): 0
		g.getEdge(7, 7) --> -4.0
		g.getEdge(7, 8) --> 7.8
		g.getEdge(7, 9) --> 7.9
		g.getEdge(8, 7) --> 8.7
		g.getEdge(8, 8) --> 8.8
		g.getEdge(8, 9) --> 1.2
		g.getEdge(9, 7) --> 9.7
		g.getEdge(9, 8) --> 2.1
		g.getEdge(9, 9) --> 9.9
		g.removeNode(7): 0
		g.removeNode(7): 0
		g.getEdge(7, 7) --> -4.0
		g.getEdge(7, 8) --> 7.8
		g.getEdge(7, 9) --> 7.9
		g.getEdge(8, 7) --> 8.7
		g.getEdge(8, 8) --> 8.8
		g.getEdge(8, 9) --> 1.2
		g.getEdge(9, 7) --> 9.7
		g.getEdge(9, 8) --> 2.1
		g.getEdge(9, 9) --> 9.9
		g.removeNode(null): -1
		g.addNode(null): -4
		g.addNode(10): 0
		g.getEdge(8, 10) --> 8.7
		g.getEdge(10, 9) --> 7.9
		g.addNode(null): -6
		g.addEdge(8,8,-8.8): -12
		g.addEdge(7,8,-7.8): -9
		g.addEdge(8,7,-8.7): -10
		g.addEdge(7,7,-7.7): -11
		g.addEdge(null,8,0.8): -1
		g.addEdge(8,null,0.8): -2
		g.addEdge(null,null,0.8): -3
		g.getEdge(null,10): -1.0
		g.getEdge(10,null): -2.0
		g.getEdge(null,null): -3.0
		g.existsNode(null): false
		g.existsEdge(null,null): false
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-10-06 11:46:20.456
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-10-06 11:46:20.458
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-10-06 11:46:31.013
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package p2Grafos;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import org.junit.Test;

/**
 * Titulo: Clase GraphTests
 * 
 * @author UO281847
 * @version 24/09/2021
 */
public class GraphTests {
	private Graph<Integer> g;
///*
// * Pruebas del método addNode:	
// */
//	/**
//	 * Test del método addNode sin errores
//	 */
//	@Test
//	public void testAddNodeFirst() {
//		Graph<Integer> g = new Graph<Integer>(3);
//		int node = 12;
//		assertEquals(0, g.addNode(node));
//		System.out.println(g.toString());	
//	}	
//	/**
//	 * Test del método addNode con nodo no valido
//	 */
//	@Test
//	public void testAddNodeNotValid() {
//		Graph<Integer> g = new Graph<Integer>(3);
//		int node = 1;
//		int node2 = 18;
//		assertEquals(0, g.addNode(node));
//		assertEquals(0, g.addNode(node2));
//		assertEquals(-5, g.addNode(null));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addNode cuando ya esta lleno
//	 */
//	@Test
//	public void testAddNodeFull() {
//		Graph<Integer> g = new Graph<Integer>(3);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 39;
//		int node4= 2;
//		assertEquals(0, g.addNode(node));
//		assertEquals(0, g.addNode(node2));
//		assertEquals(0, g.addNode(node3));
//		assertEquals(-2, g.addNode(node4));		
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addNode cuando ya existe
//	 */
//	@Test
//	public void testAddNodeAlreadyExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 39;
//		int node4 = 19;
//		int node5= 19;
//		assertEquals(0, g.addNode(node));
//		assertEquals(0, g.addNode(node2));
//		assertEquals(0, g.addNode(node3));
//		assertEquals(0, g.addNode(node4));
//		assertEquals(-1, g.addNode(node5));	
//		System.out.println(g.toString());	
//	}
//	
///*
// * Pruebas del método getNode:
// */
//	/**
//	 * Test del método getNode que devuelve la posición
//	 */
//	@Test
//	public void testGetNodeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		g.addNode(node);
//		assertEquals(0, g.getNode(node));
//	}
//	/**
//	 * Test del método getNode que devuelve la posición ya añadido
//	 */
//	@Test
//	public void testGetNodeVarious() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 23;
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(1, g.getNode(node2));
//	}
//	/**
//	 * Test del método getNode que devuelve -1
//	 */
//	@Test
//	public void testGetNodeDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 23;
//		g.addNode(node);
//		assertEquals(-1, g.getNode(node2));
//	}
//
///**
// * Pruebas del método existsNode:
// */
//	/**
//	 * Test del método existsNode que devuelve true
//	 */
//	@Test
//	public void testExistsNodeOne() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		g.addNode(node);
//		assertTrue(g.existsNode(node));
//	}
//	/**
//	 * Test del método existsNode que devuelve true
//	 */
//	@Test
//	public void testExistsNodeVarious() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 23;
//		g.addNode(node);
//		g.addNode(node2);
//		assertTrue(g.existsNode(node2));
//	}
//	/**
//	 * Test del método existsNode que devuelve true
//	 */
//	@Test
//	public void testExistsNodeFalse() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 23;
//		g.addNode(node);
//		assertFalse(g.existsNode(node2));
//	}
//
///*
// * Pruebas del método addEdge:
// */
//	/**
//	 * Test del método addEdge que no tiene errores
//	 */
//	@Test
//	public void testAddEdgeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;		
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(0, g.addEdge(node, node2, 12));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde no existe el nodo origen
//	 */
//	@Test
//	public void testAddEdgeSourceDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 23;
//		g.addNode(node);
//		g.addNode(node2);		
//		assertEquals(-1, g.addEdge(node3, node2, 12));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde no existe el nodo destino
//	 */
//	@Test
//	public void testAddEdgeTargetDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 23;
//		g.addNode(node);
//		g.addNode(node2);		
//		assertEquals(-2, g.addEdge(node, node3, 12));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde ya existe la arista
//	 */
//	@Test
//	public void testAddEdgeEdgeExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 12);
//		assertEquals(-4, g.addEdge(node, node2, 12));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde el peso no es valido
//	 */
//	@Test
//	public void testAddEdgeEdgeWightError() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(-8, g.addEdge(node, node2, -4));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde no existen los nodos 
//	 */
//	@Test
//	public void testAddEdgeSourceTargetError() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 12;
//		int node4 = 56;
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(-3, g.addEdge(node3, node4, 4));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde ya existe la arista y el peso no es valido
//	 */
//	@Test
//	public void testAddEdgeEdgeExistsEdgeWeightError() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-12, g.addEdge(node, node2, -4));
//		System.out.println(g.toString());	
//	}
//	
///*
// * Pruebas del método getEdge:
// */
//	/**
//	 * Test del método getEdge que no tiene errores
//	 */
//	@Test
//	public void testGetEdgeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(4, g.getEdge(node, node2),0.1);
//	}
//	/**
//	 * Test del método getEdge donde no existe el nodo origen
//	 */
//	@Test
//	public void testGetEdgeSourceDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 4;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-1, g.getEdge(node3, node2),0.1);
//	}
//	/**
//	 * Test del método getEdge donde no existe el nodo destino
//	 */
//	@Test
//	public void testGetEdgeTargetDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 4;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-2, g.getEdge(node, node3),0.1);
//	}
//	/**
//	 * Test del método getEdge donde existen los nodos y no la arista
//	 */
//	@Test
//	public void testGetEdgeEdgeDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(-4, g.getEdge(node, node2),0.1);
//	}
//	/**
//	 * Test del método getEdge donde no existen los nodos
//	 */
//	@Test
//	public void testGetEdgeBothDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 4;
//		int node4 = 6;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-3, g.getEdge(node3, node4),0.1);
//	}
//	
///*
// * Pruebas del método existsEdge:
// */
//	/**
//	 * Test del método existsEdge que no tiene errores
//	 */
//	@Test
//	public void testExistsEdgeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertTrue(g.existsEdge(node, node2));
//	}
//	/**
//	 * Test del método existsEdge donde no existe el nodo origen
//	 */
//	@Test
//	public void testExistsEdgeSourceDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3= 8;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertFalse(g.existsEdge(node3, node2));
//	}
//	/**
//	 * Test del método existsEdge donde no existe el nodo destino
//	 */
//	@Test
//	public void testExistsEdgeTargetDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3= 8;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertFalse(g.existsEdge(node, node3));
//	}
//	/**
//	 * Test del método existsEdge donde no existen los nodos
//	 */
//	@Test
//	public void testExistsEdgeBothDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		int node4 = 12;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertFalse(g.existsEdge(node3, node4));
//	}
//	
///*
// * Pruebas del método removeEdge:
// */
//	/**
//	 * Test del método removeEdge que no tiene errores 
//	 */
//	@Test
//	public void testRemoveEdgeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		int node4 = 12;
//		g.addNode(node);
//		g.addNode(node2); 
//		g.addNode(node3);
//		g.addNode(node4);
//		g.addEdge(node, node2, 4);
//		g.addEdge(node3, node4, 12);
//		assertEquals(0, g.removeEdge(node3, node4));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeEdge donde no existe el nodo origen
//	 */
//	@Test
//	public void testRemoveEdgeSourceDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		g.addNode(node);
//		g.addNode(node2); 
//		g.addEdge(node, node2, 4);
//		assertEquals(-1, g.removeEdge(node3, node2));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeEdge donde no existe el nodo destino
//	 */
//	@Test
//	public void testRemoveEdgeTargetDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		g.addNode(node);
//		g.addNode(node2); 
//		g.addEdge(node, node2, 4);
//		assertEquals(-2, g.removeEdge(node2, node3));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeEdge donde existen los nodos y no la arista
//	 */
//	@Test
//	public void testRemoveEdgeEdgeDontExistsNodesExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2); 
//		g.addEdge(node, node2, 4);
//		assertEquals(-4, g.removeEdge(node2, node));
//		System.out.println(g.toString());
//	}	
//	/**
//	 * Test del método removeEdge donde no existen los nodos
//	 */
//	@Test
//	public void testRemoveEdgeNodesDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		int node4 = 12;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-3, g.removeEdge(node3, node4));
//		System.out.println(g.toString());
//	}
///*
// * Pruebas del método removeNode:
// */
//	/**
//	 * Test del método removeNode que no tiene errores
//	 */
//	@Test
//	public void testRemoveNodeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;		
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(0, g.removeNode(node));
//		assertFalse(g.existsNode(node));
//		assertFalse(g.existsEdge(node, node2));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeNode que no tiene errores y borra toda la matriz
//	 */
//	@Test
//	public void testRemoveNodeVarious() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		int node4 = 12;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		g.addEdge(node, node, 12);
//		g.addEdge(node3, node, 7);
//		g.addEdge(node, node4, 15);
//		g.addEdge(node, node3, 9);
//		assertEquals(0, g.removeNode(node));
//		assertFalse(g.existsNode(node));
//		assertFalse(g.existsEdge(node, node2));
//		assertFalse(g.existsEdge(node, node));
//		assertFalse(g.existsEdge(node3, node));
//		assertFalse(g.existsEdge(node, node4));
//		assertFalse(g.existsEdge(node, node3));
//		System.out.println(g.toString());
//	}	
//	/**
//	 * Test del método removeNode donde el nodo no es valido
//	 */
//	@Test
//	public void testRemoveNodeNotValid() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;		
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-1, g.removeNode(null));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeNode donde el nodo no existe
//	 */
//	@Test
//	public void testRemoveNodeDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 12;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-1, g.removeNode(node3));
//		System.out.println(g.toString());
//	}
	/**
	 * Pruebas basicas de nodos
	 */
//	@Test
//	public void basicNodeTest() {
//		g=new Graph<Integer>(3); 
//	    assertFalse(g.existsNode(1)); //false
//	    assertFalse(g.existsNode(2)); //false
//	    assertEquals(0,g.addNode(1)); //0
//		assertEquals(0,g.addNode(2)); //0
//		assertTrue(g.existsNode(1)); //true
//		assertTrue(g.existsNode(2)); //true
//		assertEquals(-1,g.addNode(1)); //-1
//		assertEquals(-1,g.addNode(2)); //-1
//		assertEquals(0,g.addNode(3)); //0
//		assertEquals(-2,g.addNode(4)); //-2
//		assertFalse(g.existsNode(4)); //false
//		assertFalse(g.existsNode(5)); //false
//	}
	
//	@Test
//	public void basicEdgeTest() {
//		g=new Graph<Integer>(3); 
//		assertFalse(g.existsEdge(1,2)); //false
//		assertEquals(-3.0,g.getEdge(1,2),0.1); //-3.0
//		assertEquals(0,g.addNode(1)); //0
//		assertFalse(g.existsEdge(1,2)); //false
//		assertEquals(-2.0,g.getEdge(1,2),0.1); //-2.0
//		assertFalse(g.existsEdge(2,1)); //false
//		assertEquals(-1.0,g.getEdge(2,1),0.1); //-1.0
//		assertEquals(0,g.addNode(2)); //0
//		assertFalse(g.existsEdge(1,2)); //false
//		assertEquals(-4.0,g.getEdge(1,2),0.1); //-4.0
//		assertEquals(0,g.addEdge(1,2,12.12)); //0
//		assertEquals(-4,g.addEdge(1,2,12.1212)); //-4
//		assertEquals(0,g.addNode(3)); //0
//		assertFalse(g.existsEdge(1,3)); //false
//		assertFalse(g.existsEdge(3,2)); //false
//		assertEquals(-4.0,g.getEdge(1,3),0.1); //-4.0
//		assertEquals(-4.0,g.getEdge(3,2),0.1); //-4.0
//		assertEquals(0,g.addEdge(1,1,11.11)); //0
//		assertEquals(-4,g.addEdge(1,2,12.12)); //-4
//		assertEquals(0,g.addEdge(1,3,13.13)); //0
//		assertEquals(0,g.addEdge(2,1,21.21)); //0
//		assertEquals(0,g.addEdge(2,2,22.22)); //0
//		assertEquals(0,g.addEdge(2,3,23.23)); //0
//		assertEquals(0,g.addEdge(3,1,31.31)); //0
//		assertEquals(0,g.addEdge(3,2,32.32)); //0
//		assertEquals(0,g.addEdge(3,3,33.33)); //0
//		assertEquals(-4,g.addEdge(1,1,11.11)); //-4
//		assertEquals(-4,g.addEdge(1,2,12.12)); //-4
//		assertEquals(-4,g.addEdge(1,3,13.13)); //-4
//		assertEquals(-4,g.addEdge(2,1,21.21)); //-4
//		assertEquals(-4,g.addEdge(2,2,22.22)); //-4
//		assertEquals(-4,g.addEdge(2,3,23.23)); //-4
//		assertEquals(-4,g.addEdge(3,1,31.31)); //-4
//		assertEquals(-4,g.addEdge(3,2,32.32)); //-4
//		assertEquals(-4,g.addEdge(3,3,33.33)); //-4
//		g.getEdge(1,1,11.11); //11.11
//		g.getEdge(1,2,12.12); //12.12
//		g.getEdge(1,3,13.13); //13.129999999999999
//		g.getEdge(2,1,21.21); //21.21
//		g.getEdge(2,2,22.22); //22.22
//		g.getEdge(2,3,23.23); //23.23
//		g.getEdge(3,1,31.31); //31.310000000000002
//		g.getEdge(3,2,32.32); //32.32
//		g.getEdge(3,3,33.33); //33.33
//	}
	
	@Test
	public void basicEvolutionTest() {
		g=new Graph<Integer>(3); 
		assertFalse(g.existsNode(1)); //false
		assertFalse(g.existsNode(2)); //false
		assertEquals(0,g.addNode(1)); //0
		assertEquals(0,g.addNode(2)); //0
		assertTrue(g.existsNode(1)); //true
		assertTrue(g.existsNode(2)); //true
		assertEquals(-1,g.addNode(1)); //-1
		assertEquals(-1,g.addNode(2)); //-1
		assertEquals(0,g.addEdge(1,2, 1.2)); //0
		assertEquals(0,g.addEdge(2,1, 2.1));//0
		assertEquals(0,g.addEdge(1,1, 1.1)); //0
		assertEquals(1.2,g.getEdge(1,2),0.1); //1.2
		assertEquals(2.1,g.getEdge(2,1),0.1); //2.1
		assertEquals(1.1,g.getEdge(1,1),0.1); //1.1
		assertEquals(-2.0,g.getEdge(2,3),0.1); //-2.0
		assertTrue(g.existsEdge(1,2)); //true
		assertTrue(g.existsEdge(2,1)); //true
		assertTrue(g.existsEdge(1,1)); //true
		assertFalse(g.existsEdge(2,2)); //false
		assertEquals(-4,g.removeEdge(2,2)); //-4
		assertEquals(0,g.addEdge(2,2,2.2)); //0
		assertEquals(2.2,g.getEdge(2,2),0.1); //2.2
		assertTrue(g.existsEdge(2,2)); //true
		assertEquals(0,g.removeEdge(2,2)); //0
		assertEquals(-1,g.removeNode(3)); //-1
		assertEquals(0,g.addNode(3)); //0		
		assertEquals(-2,g.addNode(4)); //-2
		assertEquals(-4.0,g.getEdge(1, 3),0.1); //-4.0
		assertEquals(0,g.addEdge(1,3, 1.3)); //0	
		assertTrue(g.existsEdge(1, 3)); //true	
		assertEquals(1.3,g.getEdge(1, 3),0.1); //1.3
		assertEquals(-2.0,g.getEdge(1, 4),0.1); //-2.0
		assertEquals(-1.0,g.getEdge(5,1),0.1); //-1.0
		assertEquals(-3.0,g.getEdge(5,4),0.1); //-3.0
		assertEquals(0,g.removeNode(3)); //0
		assertEquals(-1,g.removeNode(3)); //0---------------->(-1)
		assertFalse(g.existsEdge(1, 3)); //true---------------->(false)	
		assertEquals(-2.0,g.getEdge(1, 3),0.1); //1.3------------------->(-2.0)
		assertEquals(0,g.removeNode(2)); //0
		assertEquals(-1,g.removeNode(2)); //0--------------------->(-1)
		assertTrue(g.existsEdge(1, 1)); //true
		assertEquals(0,g.removeNode(1)); //0
		assertFalse(g.existsNode(1)); //true---------------------->(false)
		assertFalse(g.existsNode(2)); //true---------------------->(false)
		assertFalse(g.existsNode(3)); //true---------------------->(false)
		assertFalse(g.existsNode(4)); //false
		assertEquals(0,g.addNode(4)); //0
		assertTrue(g.existsNode(4)); //true
		assertEquals(0,g.addEdge(4,4, 4.4)); //0
		assertTrue(g.existsEdge(4, 4)); //true
		g.getEdge(4, 4): //4.4
		g.removeNode(4): //0
		g.removeNode(4): //0
		g.existsEdge(4, 4): //true-------------------->(false)
		g.addNode(7): //0
		g.removeNode(2): //0
		g.removeNode(3): //0
		g.removeNode(4): //-1
		g.existsEdge(7, 7): //false
		g.addEdge(7,7, 7.7): //0
		g.addEdge(7,7, 17.17): //-4
		g.getEdge(7, 7): //7.7
		g.addNode(8): //0
		g.addNode(9): //0
		g.existsEdge(7, 8): //false
		g.existsEdge(8, 7): //false
		g.existsEdge(8, 8): //false
		g.existsEdge(8, 9): //true
		g.existsEdge(9, 8): //true
	    g.existsEdge(9, 9): //false
		g.addEdge(7,8, 7.8): //0
		g.addEdge(8,7, 8.7): //0
		g.addEdge(8,8, 8.8): //0
		g.addEdge(8,9, 8.9): //-4
		g.addEdge(9,8, 9.8): //-4
		g.addEdge(9,9, 9.9): //0
		g.addEdge(7,9, 7.9): //0
		g.addEdge(9,7, 9.7): //0
		g.getEdge(7, 7); -4.0
		g.getEdge(7, 8) --> 7.8
		g.getEdge(7, 9) --> 7.9
		g.getEdge(8, 7) --> 8.7
		g.getEdge(8, 8) --> 8.8
		g.getEdge(8, 9) --> 1.2
		g.getEdge(9, 7) --> 9.7
		g.getEdge(9, 8) --> 2.1
		g.getEdge(9, 9) --> 9.9
		g.removeNode(7): 0
		g.removeNode(7): 0
		g.getEdge(7, 7) --> -4.0
		g.getEdge(7, 8) --> 7.8
		g.getEdge(7, 9) --> 7.9
		g.getEdge(8, 7) --> 8.7
		g.getEdge(8, 8) --> 8.8
		g.getEdge(8, 9) --> 1.2
		g.getEdge(9, 7) --> 9.7
		g.getEdge(9, 8) --> 2.1
		g.getEdge(9, 9) --> 9.9
		g.removeNode(null): -1
		g.addNode(null): -4
		g.addNode(10): 0
		g.getEdge(8, 10) --> 8.7
		g.getEdge(10, 9) --> 7.9
		g.addNode(null): -6
		g.addEdge(8,8,-8.8): -12
		g.addEdge(7,8,-7.8): -9
		g.addEdge(8,7,-8.7): -10
		g.addEdge(7,7,-7.7): -11
		g.addEdge(null,8,0.8): -1
		g.addEdge(8,null,0.8): -2
		g.addEdge(null,null,0.8): -3
		g.getEdge(null,10): -1.0
		g.getEdge(10,null): -2.0
		g.getEdge(null,null): -3.0
		g.existsNode(null): false
		g.existsEdge(null,null): false
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-10-06 11:46:31.015
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-10-06 11:46:31.016
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-10-06 11:46:31.094
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package p2Grafos;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import org.junit.Test;

/**
 * Titulo: Clase GraphTests
 * 
 * @author UO281847
 * @version 24/09/2021
 */
public class GraphTests {
	private Graph<Integer> g;
///*
// * Pruebas del método addNode:	
// */
//	/**
//	 * Test del método addNode sin errores
//	 */
//	@Test
//	public void testAddNodeFirst() {
//		Graph<Integer> g = new Graph<Integer>(3);
//		int node = 12;
//		assertEquals(0, g.addNode(node));
//		System.out.println(g.toString());	
//	}	
//	/**
//	 * Test del método addNode con nodo no valido
//	 */
//	@Test
//	public void testAddNodeNotValid() {
//		Graph<Integer> g = new Graph<Integer>(3);
//		int node = 1;
//		int node2 = 18;
//		assertEquals(0, g.addNode(node));
//		assertEquals(0, g.addNode(node2));
//		assertEquals(-5, g.addNode(null));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addNode cuando ya esta lleno
//	 */
//	@Test
//	public void testAddNodeFull() {
//		Graph<Integer> g = new Graph<Integer>(3);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 39;
//		int node4= 2;
//		assertEquals(0, g.addNode(node));
//		assertEquals(0, g.addNode(node2));
//		assertEquals(0, g.addNode(node3));
//		assertEquals(-2, g.addNode(node4));		
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addNode cuando ya existe
//	 */
//	@Test
//	public void testAddNodeAlreadyExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 39;
//		int node4 = 19;
//		int node5= 19;
//		assertEquals(0, g.addNode(node));
//		assertEquals(0, g.addNode(node2));
//		assertEquals(0, g.addNode(node3));
//		assertEquals(0, g.addNode(node4));
//		assertEquals(-1, g.addNode(node5));	
//		System.out.println(g.toString());	
//	}
//	
///*
// * Pruebas del método getNode:
// */
//	/**
//	 * Test del método getNode que devuelve la posición
//	 */
//	@Test
//	public void testGetNodeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		g.addNode(node);
//		assertEquals(0, g.getNode(node));
//	}
//	/**
//	 * Test del método getNode que devuelve la posición ya añadido
//	 */
//	@Test
//	public void testGetNodeVarious() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 23;
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(1, g.getNode(node2));
//	}
//	/**
//	 * Test del método getNode que devuelve -1
//	 */
//	@Test
//	public void testGetNodeDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 23;
//		g.addNode(node);
//		assertEquals(-1, g.getNode(node2));
//	}
//
///**
// * Pruebas del método existsNode:
// */
//	/**
//	 * Test del método existsNode que devuelve true
//	 */
//	@Test
//	public void testExistsNodeOne() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		g.addNode(node);
//		assertTrue(g.existsNode(node));
//	}
//	/**
//	 * Test del método existsNode que devuelve true
//	 */
//	@Test
//	public void testExistsNodeVarious() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 23;
//		g.addNode(node);
//		g.addNode(node2);
//		assertTrue(g.existsNode(node2));
//	}
//	/**
//	 * Test del método existsNode que devuelve true
//	 */
//	@Test
//	public void testExistsNodeFalse() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 23;
//		g.addNode(node);
//		assertFalse(g.existsNode(node2));
//	}
//
///*
// * Pruebas del método addEdge:
// */
//	/**
//	 * Test del método addEdge que no tiene errores
//	 */
//	@Test
//	public void testAddEdgeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;		
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(0, g.addEdge(node, node2, 12));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde no existe el nodo origen
//	 */
//	@Test
//	public void testAddEdgeSourceDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 23;
//		g.addNode(node);
//		g.addNode(node2);		
//		assertEquals(-1, g.addEdge(node3, node2, 12));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde no existe el nodo destino
//	 */
//	@Test
//	public void testAddEdgeTargetDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 23;
//		g.addNode(node);
//		g.addNode(node2);		
//		assertEquals(-2, g.addEdge(node, node3, 12));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde ya existe la arista
//	 */
//	@Test
//	public void testAddEdgeEdgeExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 12);
//		assertEquals(-4, g.addEdge(node, node2, 12));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde el peso no es valido
//	 */
//	@Test
//	public void testAddEdgeEdgeWightError() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(-8, g.addEdge(node, node2, -4));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde no existen los nodos 
//	 */
//	@Test
//	public void testAddEdgeSourceTargetError() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 12;
//		int node4 = 56;
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(-3, g.addEdge(node3, node4, 4));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde ya existe la arista y el peso no es valido
//	 */
//	@Test
//	public void testAddEdgeEdgeExistsEdgeWeightError() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-12, g.addEdge(node, node2, -4));
//		System.out.println(g.toString());	
//	}
//	
///*
// * Pruebas del método getEdge:
// */
//	/**
//	 * Test del método getEdge que no tiene errores
//	 */
//	@Test
//	public void testGetEdgeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(4, g.getEdge(node, node2),0.1);
//	}
//	/**
//	 * Test del método getEdge donde no existe el nodo origen
//	 */
//	@Test
//	public void testGetEdgeSourceDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 4;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-1, g.getEdge(node3, node2),0.1);
//	}
//	/**
//	 * Test del método getEdge donde no existe el nodo destino
//	 */
//	@Test
//	public void testGetEdgeTargetDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 4;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-2, g.getEdge(node, node3),0.1);
//	}
//	/**
//	 * Test del método getEdge donde existen los nodos y no la arista
//	 */
//	@Test
//	public void testGetEdgeEdgeDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(-4, g.getEdge(node, node2),0.1);
//	}
//	/**
//	 * Test del método getEdge donde no existen los nodos
//	 */
//	@Test
//	public void testGetEdgeBothDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 4;
//		int node4 = 6;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-3, g.getEdge(node3, node4),0.1);
//	}
//	
///*
// * Pruebas del método existsEdge:
// */
//	/**
//	 * Test del método existsEdge que no tiene errores
//	 */
//	@Test
//	public void testExistsEdgeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertTrue(g.existsEdge(node, node2));
//	}
//	/**
//	 * Test del método existsEdge donde no existe el nodo origen
//	 */
//	@Test
//	public void testExistsEdgeSourceDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3= 8;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertFalse(g.existsEdge(node3, node2));
//	}
//	/**
//	 * Test del método existsEdge donde no existe el nodo destino
//	 */
//	@Test
//	public void testExistsEdgeTargetDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3= 8;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertFalse(g.existsEdge(node, node3));
//	}
//	/**
//	 * Test del método existsEdge donde no existen los nodos
//	 */
//	@Test
//	public void testExistsEdgeBothDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		int node4 = 12;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertFalse(g.existsEdge(node3, node4));
//	}
//	
///*
// * Pruebas del método removeEdge:
// */
//	/**
//	 * Test del método removeEdge que no tiene errores 
//	 */
//	@Test
//	public void testRemoveEdgeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		int node4 = 12;
//		g.addNode(node);
//		g.addNode(node2); 
//		g.addNode(node3);
//		g.addNode(node4);
//		g.addEdge(node, node2, 4);
//		g.addEdge(node3, node4, 12);
//		assertEquals(0, g.removeEdge(node3, node4));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeEdge donde no existe el nodo origen
//	 */
//	@Test
//	public void testRemoveEdgeSourceDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		g.addNode(node);
//		g.addNode(node2); 
//		g.addEdge(node, node2, 4);
//		assertEquals(-1, g.removeEdge(node3, node2));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeEdge donde no existe el nodo destino
//	 */
//	@Test
//	public void testRemoveEdgeTargetDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		g.addNode(node);
//		g.addNode(node2); 
//		g.addEdge(node, node2, 4);
//		assertEquals(-2, g.removeEdge(node2, node3));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeEdge donde existen los nodos y no la arista
//	 */
//	@Test
//	public void testRemoveEdgeEdgeDontExistsNodesExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2); 
//		g.addEdge(node, node2, 4);
//		assertEquals(-4, g.removeEdge(node2, node));
//		System.out.println(g.toString());
//	}	
//	/**
//	 * Test del método removeEdge donde no existen los nodos
//	 */
//	@Test
//	public void testRemoveEdgeNodesDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		int node4 = 12;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-3, g.removeEdge(node3, node4));
//		System.out.println(g.toString());
//	}
///*
// * Pruebas del método removeNode:
// */
//	/**
//	 * Test del método removeNode que no tiene errores
//	 */
//	@Test
//	public void testRemoveNodeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;		
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(0, g.removeNode(node));
//		assertFalse(g.existsNode(node));
//		assertFalse(g.existsEdge(node, node2));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeNode que no tiene errores y borra toda la matriz
//	 */
//	@Test
//	public void testRemoveNodeVarious() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		int node4 = 12;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		g.addEdge(node, node, 12);
//		g.addEdge(node3, node, 7);
//		g.addEdge(node, node4, 15);
//		g.addEdge(node, node3, 9);
//		assertEquals(0, g.removeNode(node));
//		assertFalse(g.existsNode(node));
//		assertFalse(g.existsEdge(node, node2));
//		assertFalse(g.existsEdge(node, node));
//		assertFalse(g.existsEdge(node3, node));
//		assertFalse(g.existsEdge(node, node4));
//		assertFalse(g.existsEdge(node, node3));
//		System.out.println(g.toString());
//	}	
//	/**
//	 * Test del método removeNode donde el nodo no es valido
//	 */
//	@Test
//	public void testRemoveNodeNotValid() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;		
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-1, g.removeNode(null));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeNode donde el nodo no existe
//	 */
//	@Test
//	public void testRemoveNodeDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 12;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-1, g.removeNode(node3));
//		System.out.println(g.toString());
//	}
	/**
	 * Pruebas basicas de nodos
	 */
//	@Test
//	public void basicNodeTest() {
//		g=new Graph<Integer>(3); 
//	    assertFalse(g.existsNode(1)); //false
//	    assertFalse(g.existsNode(2)); //false
//	    assertEquals(0,g.addNode(1)); //0
//		assertEquals(0,g.addNode(2)); //0
//		assertTrue(g.existsNode(1)); //true
//		assertTrue(g.existsNode(2)); //true
//		assertEquals(-1,g.addNode(1)); //-1
//		assertEquals(-1,g.addNode(2)); //-1
//		assertEquals(0,g.addNode(3)); //0
//		assertEquals(-2,g.addNode(4)); //-2
//		assertFalse(g.existsNode(4)); //false
//		assertFalse(g.existsNode(5)); //false
//	}
	
//	@Test
//	public void basicEdgeTest() {
//		g=new Graph<Integer>(3); 
//		assertFalse(g.existsEdge(1,2)); //false
//		assertEquals(-3.0,g.getEdge(1,2),0.1); //-3.0
//		assertEquals(0,g.addNode(1)); //0
//		assertFalse(g.existsEdge(1,2)); //false
//		assertEquals(-2.0,g.getEdge(1,2),0.1); //-2.0
//		assertFalse(g.existsEdge(2,1)); //false
//		assertEquals(-1.0,g.getEdge(2,1),0.1); //-1.0
//		assertEquals(0,g.addNode(2)); //0
//		assertFalse(g.existsEdge(1,2)); //false
//		assertEquals(-4.0,g.getEdge(1,2),0.1); //-4.0
//		assertEquals(0,g.addEdge(1,2,12.12)); //0
//		assertEquals(-4,g.addEdge(1,2,12.1212)); //-4
//		assertEquals(0,g.addNode(3)); //0
//		assertFalse(g.existsEdge(1,3)); //false
//		assertFalse(g.existsEdge(3,2)); //false
//		assertEquals(-4.0,g.getEdge(1,3),0.1); //-4.0
//		assertEquals(-4.0,g.getEdge(3,2),0.1); //-4.0
//		assertEquals(0,g.addEdge(1,1,11.11)); //0
//		assertEquals(-4,g.addEdge(1,2,12.12)); //-4
//		assertEquals(0,g.addEdge(1,3,13.13)); //0
//		assertEquals(0,g.addEdge(2,1,21.21)); //0
//		assertEquals(0,g.addEdge(2,2,22.22)); //0
//		assertEquals(0,g.addEdge(2,3,23.23)); //0
//		assertEquals(0,g.addEdge(3,1,31.31)); //0
//		assertEquals(0,g.addEdge(3,2,32.32)); //0
//		assertEquals(0,g.addEdge(3,3,33.33)); //0
//		assertEquals(-4,g.addEdge(1,1,11.11)); //-4
//		assertEquals(-4,g.addEdge(1,2,12.12)); //-4
//		assertEquals(-4,g.addEdge(1,3,13.13)); //-4
//		assertEquals(-4,g.addEdge(2,1,21.21)); //-4
//		assertEquals(-4,g.addEdge(2,2,22.22)); //-4
//		assertEquals(-4,g.addEdge(2,3,23.23)); //-4
//		assertEquals(-4,g.addEdge(3,1,31.31)); //-4
//		assertEquals(-4,g.addEdge(3,2,32.32)); //-4
//		assertEquals(-4,g.addEdge(3,3,33.33)); //-4
//		g.getEdge(1,1,11.11); //11.11
//		g.getEdge(1,2,12.12); //12.12
//		g.getEdge(1,3,13.13); //13.129999999999999
//		g.getEdge(2,1,21.21); //21.21
//		g.getEdge(2,2,22.22); //22.22
//		g.getEdge(2,3,23.23); //23.23
//		g.getEdge(3,1,31.31); //31.310000000000002
//		g.getEdge(3,2,32.32); //32.32
//		g.getEdge(3,3,33.33); //33.33
//	}
	
	@Test
	public void basicEvolutionTest() {
		g=new Graph<Integer>(3); 
		assertFalse(g.existsNode(1)); //false
		assertFalse(g.existsNode(2)); //false
		assertEquals(0,g.addNode(1)); //0
		assertEquals(0,g.addNode(2)); //0
		assertTrue(g.existsNode(1)); //true
		assertTrue(g.existsNode(2)); //true
		assertEquals(-1,g.addNode(1)); //-1
		assertEquals(-1,g.addNode(2)); //-1
		assertEquals(0,g.addEdge(1,2, 1.2)); //0
		assertEquals(0,g.addEdge(2,1, 2.1));//0
		assertEquals(0,g.addEdge(1,1, 1.1)); //0
		assertEquals(1.2,g.getEdge(1,2),0.1); //1.2
		assertEquals(2.1,g.getEdge(2,1),0.1); //2.1
		assertEquals(1.1,g.getEdge(1,1),0.1); //1.1
		assertEquals(-2.0,g.getEdge(2,3),0.1); //-2.0
		assertTrue(g.existsEdge(1,2)); //true
		assertTrue(g.existsEdge(2,1)); //true
		assertTrue(g.existsEdge(1,1)); //true
		assertFalse(g.existsEdge(2,2)); //false
		assertEquals(-4,g.removeEdge(2,2)); //-4
		assertEquals(0,g.addEdge(2,2,2.2)); //0
		assertEquals(2.2,g.getEdge(2,2),0.1); //2.2
		assertTrue(g.existsEdge(2,2)); //true
		assertEquals(0,g.removeEdge(2,2)); //0
		assertEquals(-1,g.removeNode(3)); //-1
		assertEquals(0,g.addNode(3)); //0		
		assertEquals(-2,g.addNode(4)); //-2
		assertEquals(-4.0,g.getEdge(1, 3),0.1); //-4.0
		assertEquals(0,g.addEdge(1,3, 1.3)); //0	
		assertTrue(g.existsEdge(1, 3)); //true	
		assertEquals(1.3,g.getEdge(1, 3),0.1); //1.3
		assertEquals(-2.0,g.getEdge(1, 4),0.1); //-2.0
		assertEquals(-1.0,g.getEdge(5,1),0.1); //-1.0
		assertEquals(-3.0,g.getEdge(5,4),0.1); //-3.0
		assertEquals(0,g.removeNode(3)); //0
		assertEquals(-1,g.removeNode(3)); //0---------------->(-1)
		assertFalse(g.existsEdge(1, 3)); //true---------------->(false)	
		assertEquals(-2.0,g.getEdge(1, 3),0.1); //1.3------------------->(-2.0)
		assertEquals(0,g.removeNode(2)); //0
		assertEquals(-1,g.removeNode(2)); //0--------------------->(-1)
		assertTrue(g.existsEdge(1, 1)); //true
		assertEquals(0,g.removeNode(1)); //0
		assertFalse(g.existsNode(1)); //true---------------------->(false)
		assertFalse(g.existsNode(2)); //true---------------------->(false)
		assertFalse(g.existsNode(3)); //true---------------------->(false)
		assertFalse(g.existsNode(4)); //false
		assertEquals(0,g.addNode(4)); //0
		assertTrue(g.existsNode(4)); //true
		assertEquals(0,g.addEdge(4,4, 4.4)); //0
		assertTrue(g.existsEdge(4, 4)); //true
		g.getEdge(4, 4): //4.4
		g.removeNode(4): //0
		g.removeNode(4): //0
		g.existsEdge(4, 4): //true-------------------->(false)
		g.addNode(7): //0
		g.removeNode(2): //0
		g.removeNode(3): //0
		g.removeNode(4): //-1
		g.existsEdge(7, 7): //false
		g.addEdge(7,7, 7.7): //0
		g.addEdge(7,7, 17.17): //-4
		g.getEdge(7, 7): //7.7
		g.addNode(8): //0
		g.addNode(9): //0
		g.existsEdge(7, 8): //false
		g.existsEdge(8, 7): //false
		g.existsEdge(8, 8): //false
		g.existsEdge(8, 9): //true
		g.existsEdge(9, 8): //true
	    g.existsEdge(9, 9): //false
		g.addEdge(7,8, 7.8): //0
		g.addEdge(8,7, 8.7): //0
		g.addEdge(8,8, 8.8): //0
		g.addEdge(8,9, 8.9): //-4
		g.addEdge(9,8, 9.8): //-4
		g.addEdge(9,9, 9.9): //0
		g.addEdge(7,9, 7.9): //0
		g.addEdge(9,7, 9.7): //0
		g.getEdge(7, 7); -4.0
		g.getEdge(7, 8) --> 7.8
		g.getEdge(7, 9) --> 7.9
		g.getEdge(8, 7) --> 8.7
		g.getEdge(8, 8) --> 8.8
		g.getEdge(8, 9) --> 1.2
		g.getEdge(9, 7) --> 9.7
		g.getEdge(9, 8) --> 2.1
		g.getEdge(9, 9) --> 9.9
		g.removeNode(7): 0
		g.removeNode(7): 0
		g.getEdge(7, 7) --> -4.0
		g.getEdge(7, 8) --> 7.8
		g.getEdge(7, 9) --> 7.9
		g.getEdge(8, 7) --> 8.7
		g.getEdge(8, 8) --> 8.8
		g.getEdge(8, 9) --> 1.2
		g.getEdge(9, 7) --> 9.7
		g.getEdge(9, 8) --> 2.1
		g.getEdge(9, 9) --> 9.9
		g.removeNode(null): -1
		g.addNode(null): -4
		g.addNode(10): 0
		g.getEdge(8, 10) --> 8.7
		g.getEdge(10, 9) --> 7.9
		g.addNode(null): -6
		g.addEdge(8,8,-8.8): -12
		g.addEdge(7,8,-7.8): -9
		g.addEdge(8,7,-8.7): -10
		g.addEdge(7,7,-7.7): -11
		g.addEdge(null,8,0.8): -1
		g.addEdge(8,null,0.8): -2
		g.addEdge(null,null,0.8): -3
		g.getEdge(null,10): -1.0
		g.getEdge(10,null): -2.0
		g.getEdge(null,null): -3.0
		g.existsNode(null): false
		g.existsEdge(null,null): false
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-10-06 11:46:31.096
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-10-06 11:46:31.097
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-10-06 11:46:32.528
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package p2Grafos;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import org.junit.Test;

/**
 * Titulo: Clase GraphTests
 * 
 * @author UO281847
 * @version 24/09/2021
 */
public class GraphTests {
	private Graph<Integer> g;
///*
// * Pruebas del método addNode:	
// */
//	/**
//	 * Test del método addNode sin errores
//	 */
//	@Test
//	public void testAddNodeFirst() {
//		Graph<Integer> g = new Graph<Integer>(3);
//		int node = 12;
//		assertEquals(0, g.addNode(node));
//		System.out.println(g.toString());	
//	}	
//	/**
//	 * Test del método addNode con nodo no valido
//	 */
//	@Test
//	public void testAddNodeNotValid() {
//		Graph<Integer> g = new Graph<Integer>(3);
//		int node = 1;
//		int node2 = 18;
//		assertEquals(0, g.addNode(node));
//		assertEquals(0, g.addNode(node2));
//		assertEquals(-5, g.addNode(null));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addNode cuando ya esta lleno
//	 */
//	@Test
//	public void testAddNodeFull() {
//		Graph<Integer> g = new Graph<Integer>(3);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 39;
//		int node4= 2;
//		assertEquals(0, g.addNode(node));
//		assertEquals(0, g.addNode(node2));
//		assertEquals(0, g.addNode(node3));
//		assertEquals(-2, g.addNode(node4));		
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addNode cuando ya existe
//	 */
//	@Test
//	public void testAddNodeAlreadyExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 39;
//		int node4 = 19;
//		int node5= 19;
//		assertEquals(0, g.addNode(node));
//		assertEquals(0, g.addNode(node2));
//		assertEquals(0, g.addNode(node3));
//		assertEquals(0, g.addNode(node4));
//		assertEquals(-1, g.addNode(node5));	
//		System.out.println(g.toString());	
//	}
//	
///*
// * Pruebas del método getNode:
// */
//	/**
//	 * Test del método getNode que devuelve la posición
//	 */
//	@Test
//	public void testGetNodeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		g.addNode(node);
//		assertEquals(0, g.getNode(node));
//	}
//	/**
//	 * Test del método getNode que devuelve la posición ya añadido
//	 */
//	@Test
//	public void testGetNodeVarious() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 23;
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(1, g.getNode(node2));
//	}
//	/**
//	 * Test del método getNode que devuelve -1
//	 */
//	@Test
//	public void testGetNodeDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 23;
//		g.addNode(node);
//		assertEquals(-1, g.getNode(node2));
//	}
//
///**
// * Pruebas del método existsNode:
// */
//	/**
//	 * Test del método existsNode que devuelve true
//	 */
//	@Test
//	public void testExistsNodeOne() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		g.addNode(node);
//		assertTrue(g.existsNode(node));
//	}
//	/**
//	 * Test del método existsNode que devuelve true
//	 */
//	@Test
//	public void testExistsNodeVarious() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 23;
//		g.addNode(node);
//		g.addNode(node2);
//		assertTrue(g.existsNode(node2));
//	}
//	/**
//	 * Test del método existsNode que devuelve true
//	 */
//	@Test
//	public void testExistsNodeFalse() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 23;
//		g.addNode(node);
//		assertFalse(g.existsNode(node2));
//	}
//
///*
// * Pruebas del método addEdge:
// */
//	/**
//	 * Test del método addEdge que no tiene errores
//	 */
//	@Test
//	public void testAddEdgeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;		
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(0, g.addEdge(node, node2, 12));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde no existe el nodo origen
//	 */
//	@Test
//	public void testAddEdgeSourceDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 23;
//		g.addNode(node);
//		g.addNode(node2);		
//		assertEquals(-1, g.addEdge(node3, node2, 12));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde no existe el nodo destino
//	 */
//	@Test
//	public void testAddEdgeTargetDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 23;
//		g.addNode(node);
//		g.addNode(node2);		
//		assertEquals(-2, g.addEdge(node, node3, 12));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde ya existe la arista
//	 */
//	@Test
//	public void testAddEdgeEdgeExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 12);
//		assertEquals(-4, g.addEdge(node, node2, 12));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde el peso no es valido
//	 */
//	@Test
//	public void testAddEdgeEdgeWightError() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(-8, g.addEdge(node, node2, -4));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde no existen los nodos 
//	 */
//	@Test
//	public void testAddEdgeSourceTargetError() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 12;
//		int node4 = 56;
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(-3, g.addEdge(node3, node4, 4));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde ya existe la arista y el peso no es valido
//	 */
//	@Test
//	public void testAddEdgeEdgeExistsEdgeWeightError() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-12, g.addEdge(node, node2, -4));
//		System.out.println(g.toString());	
//	}
//	
///*
// * Pruebas del método getEdge:
// */
//	/**
//	 * Test del método getEdge que no tiene errores
//	 */
//	@Test
//	public void testGetEdgeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(4, g.getEdge(node, node2),0.1);
//	}
//	/**
//	 * Test del método getEdge donde no existe el nodo origen
//	 */
//	@Test
//	public void testGetEdgeSourceDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 4;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-1, g.getEdge(node3, node2),0.1);
//	}
//	/**
//	 * Test del método getEdge donde no existe el nodo destino
//	 */
//	@Test
//	public void testGetEdgeTargetDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 4;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-2, g.getEdge(node, node3),0.1);
//	}
//	/**
//	 * Test del método getEdge donde existen los nodos y no la arista
//	 */
//	@Test
//	public void testGetEdgeEdgeDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(-4, g.getEdge(node, node2),0.1);
//	}
//	/**
//	 * Test del método getEdge donde no existen los nodos
//	 */
//	@Test
//	public void testGetEdgeBothDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 4;
//		int node4 = 6;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-3, g.getEdge(node3, node4),0.1);
//	}
//	
///*
// * Pruebas del método existsEdge:
// */
//	/**
//	 * Test del método existsEdge que no tiene errores
//	 */
//	@Test
//	public void testExistsEdgeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertTrue(g.existsEdge(node, node2));
//	}
//	/**
//	 * Test del método existsEdge donde no existe el nodo origen
//	 */
//	@Test
//	public void testExistsEdgeSourceDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3= 8;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertFalse(g.existsEdge(node3, node2));
//	}
//	/**
//	 * Test del método existsEdge donde no existe el nodo destino
//	 */
//	@Test
//	public void testExistsEdgeTargetDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3= 8;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertFalse(g.existsEdge(node, node3));
//	}
//	/**
//	 * Test del método existsEdge donde no existen los nodos
//	 */
//	@Test
//	public void testExistsEdgeBothDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		int node4 = 12;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertFalse(g.existsEdge(node3, node4));
//	}
//	
///*
// * Pruebas del método removeEdge:
// */
//	/**
//	 * Test del método removeEdge que no tiene errores 
//	 */
//	@Test
//	public void testRemoveEdgeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		int node4 = 12;
//		g.addNode(node);
//		g.addNode(node2); 
//		g.addNode(node3);
//		g.addNode(node4);
//		g.addEdge(node, node2, 4);
//		g.addEdge(node3, node4, 12);
//		assertEquals(0, g.removeEdge(node3, node4));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeEdge donde no existe el nodo origen
//	 */
//	@Test
//	public void testRemoveEdgeSourceDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		g.addNode(node);
//		g.addNode(node2); 
//		g.addEdge(node, node2, 4);
//		assertEquals(-1, g.removeEdge(node3, node2));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeEdge donde no existe el nodo destino
//	 */
//	@Test
//	public void testRemoveEdgeTargetDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		g.addNode(node);
//		g.addNode(node2); 
//		g.addEdge(node, node2, 4);
//		assertEquals(-2, g.removeEdge(node2, node3));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeEdge donde existen los nodos y no la arista
//	 */
//	@Test
//	public void testRemoveEdgeEdgeDontExistsNodesExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2); 
//		g.addEdge(node, node2, 4);
//		assertEquals(-4, g.removeEdge(node2, node));
//		System.out.println(g.toString());
//	}	
//	/**
//	 * Test del método removeEdge donde no existen los nodos
//	 */
//	@Test
//	public void testRemoveEdgeNodesDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		int node4 = 12;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-3, g.removeEdge(node3, node4));
//		System.out.println(g.toString());
//	}
///*
// * Pruebas del método removeNode:
// */
//	/**
//	 * Test del método removeNode que no tiene errores
//	 */
//	@Test
//	public void testRemoveNodeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;		
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(0, g.removeNode(node));
//		assertFalse(g.existsNode(node));
//		assertFalse(g.existsEdge(node, node2));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeNode que no tiene errores y borra toda la matriz
//	 */
//	@Test
//	public void testRemoveNodeVarious() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		int node4 = 12;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		g.addEdge(node, node, 12);
//		g.addEdge(node3, node, 7);
//		g.addEdge(node, node4, 15);
//		g.addEdge(node, node3, 9);
//		assertEquals(0, g.removeNode(node));
//		assertFalse(g.existsNode(node));
//		assertFalse(g.existsEdge(node, node2));
//		assertFalse(g.existsEdge(node, node));
//		assertFalse(g.existsEdge(node3, node));
//		assertFalse(g.existsEdge(node, node4));
//		assertFalse(g.existsEdge(node, node3));
//		System.out.println(g.toString());
//	}	
//	/**
//	 * Test del método removeNode donde el nodo no es valido
//	 */
//	@Test
//	public void testRemoveNodeNotValid() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;		
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-1, g.removeNode(null));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeNode donde el nodo no existe
//	 */
//	@Test
//	public void testRemoveNodeDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 12;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-1, g.removeNode(node3));
//		System.out.println(g.toString());
//	}
	/**
	 * Pruebas basicas de nodos
	 */
//	@Test
//	public void basicNodeTest() {
//		g=new Graph<Integer>(3); 
//	    assertFalse(g.existsNode(1)); //false
//	    assertFalse(g.existsNode(2)); //false
//	    assertEquals(0,g.addNode(1)); //0
//		assertEquals(0,g.addNode(2)); //0
//		assertTrue(g.existsNode(1)); //true
//		assertTrue(g.existsNode(2)); //true
//		assertEquals(-1,g.addNode(1)); //-1
//		assertEquals(-1,g.addNode(2)); //-1
//		assertEquals(0,g.addNode(3)); //0
//		assertEquals(-2,g.addNode(4)); //-2
//		assertFalse(g.existsNode(4)); //false
//		assertFalse(g.existsNode(5)); //false
//	}
	
//	@Test
//	public void basicEdgeTest() {
//		g=new Graph<Integer>(3); 
//		assertFalse(g.existsEdge(1,2)); //false
//		assertEquals(-3.0,g.getEdge(1,2),0.1); //-3.0
//		assertEquals(0,g.addNode(1)); //0
//		assertFalse(g.existsEdge(1,2)); //false
//		assertEquals(-2.0,g.getEdge(1,2),0.1); //-2.0
//		assertFalse(g.existsEdge(2,1)); //false
//		assertEquals(-1.0,g.getEdge(2,1),0.1); //-1.0
//		assertEquals(0,g.addNode(2)); //0
//		assertFalse(g.existsEdge(1,2)); //false
//		assertEquals(-4.0,g.getEdge(1,2),0.1); //-4.0
//		assertEquals(0,g.addEdge(1,2,12.12)); //0
//		assertEquals(-4,g.addEdge(1,2,12.1212)); //-4
//		assertEquals(0,g.addNode(3)); //0
//		assertFalse(g.existsEdge(1,3)); //false
//		assertFalse(g.existsEdge(3,2)); //false
//		assertEquals(-4.0,g.getEdge(1,3),0.1); //-4.0
//		assertEquals(-4.0,g.getEdge(3,2),0.1); //-4.0
//		assertEquals(0,g.addEdge(1,1,11.11)); //0
//		assertEquals(-4,g.addEdge(1,2,12.12)); //-4
//		assertEquals(0,g.addEdge(1,3,13.13)); //0
//		assertEquals(0,g.addEdge(2,1,21.21)); //0
//		assertEquals(0,g.addEdge(2,2,22.22)); //0
//		assertEquals(0,g.addEdge(2,3,23.23)); //0
//		assertEquals(0,g.addEdge(3,1,31.31)); //0
//		assertEquals(0,g.addEdge(3,2,32.32)); //0
//		assertEquals(0,g.addEdge(3,3,33.33)); //0
//		assertEquals(-4,g.addEdge(1,1,11.11)); //-4
//		assertEquals(-4,g.addEdge(1,2,12.12)); //-4
//		assertEquals(-4,g.addEdge(1,3,13.13)); //-4
//		assertEquals(-4,g.addEdge(2,1,21.21)); //-4
//		assertEquals(-4,g.addEdge(2,2,22.22)); //-4
//		assertEquals(-4,g.addEdge(2,3,23.23)); //-4
//		assertEquals(-4,g.addEdge(3,1,31.31)); //-4
//		assertEquals(-4,g.addEdge(3,2,32.32)); //-4
//		assertEquals(-4,g.addEdge(3,3,33.33)); //-4
//		g.getEdge(1,1,11.11); //11.11
//		g.getEdge(1,2,12.12); //12.12
//		g.getEdge(1,3,13.13); //13.129999999999999
//		g.getEdge(2,1,21.21); //21.21
//		g.getEdge(2,2,22.22); //22.22
//		g.getEdge(2,3,23.23); //23.23
//		g.getEdge(3,1,31.31); //31.310000000000002
//		g.getEdge(3,2,32.32); //32.32
//		g.getEdge(3,3,33.33); //33.33
//	}
	
	@Test
	public void basicEvolutionTest() {
		g=new Graph<Integer>(3); 
		assertFalse(g.existsNode(1)); //false
		assertFalse(g.existsNode(2)); //false
		assertEquals(0,g.addNode(1)); //0
		assertEquals(0,g.addNode(2)); //0
		assertTrue(g.existsNode(1)); //true
		assertTrue(g.existsNode(2)); //true
		assertEquals(-1,g.addNode(1)); //-1
		assertEquals(-1,g.addNode(2)); //-1
		assertEquals(0,g.addEdge(1,2, 1.2)); //0
		assertEquals(0,g.addEdge(2,1, 2.1));//0
		assertEquals(0,g.addEdge(1,1, 1.1)); //0
		assertEquals(1.2,g.getEdge(1,2),0.1); //1.2
		assertEquals(2.1,g.getEdge(2,1),0.1); //2.1
		assertEquals(1.1,g.getEdge(1,1),0.1); //1.1
		assertEquals(-2.0,g.getEdge(2,3),0.1); //-2.0
		assertTrue(g.existsEdge(1,2)); //true
		assertTrue(g.existsEdge(2,1)); //true
		assertTrue(g.existsEdge(1,1)); //true
		assertFalse(g.existsEdge(2,2)); //false
		assertEquals(-4,g.removeEdge(2,2)); //-4
		assertEquals(0,g.addEdge(2,2,2.2)); //0
		assertEquals(2.2,g.getEdge(2,2),0.1); //2.2
		assertTrue(g.existsEdge(2,2)); //true
		assertEquals(0,g.removeEdge(2,2)); //0
		assertEquals(-1,g.removeNode(3)); //-1
		assertEquals(0,g.addNode(3)); //0		
		assertEquals(-2,g.addNode(4)); //-2
		assertEquals(-4.0,g.getEdge(1, 3),0.1); //-4.0
		assertEquals(0,g.addEdge(1,3, 1.3)); //0	
		assertTrue(g.existsEdge(1, 3)); //true	
		assertEquals(1.3,g.getEdge(1, 3),0.1); //1.3
		assertEquals(-2.0,g.getEdge(1, 4),0.1); //-2.0
		assertEquals(-1.0,g.getEdge(5,1),0.1); //-1.0
		assertEquals(-3.0,g.getEdge(5,4),0.1); //-3.0
		assertEquals(0,g.removeNode(3)); //0
		assertEquals(-1,g.removeNode(3)); //0---------------->(-1)
		assertFalse(g.existsEdge(1, 3)); //true---------------->(false)	
		assertEquals(-2.0,g.getEdge(1, 3),0.1); //1.3------------------->(-2.0)
		assertEquals(0,g.removeNode(2)); //0
		assertEquals(-1,g.removeNode(2)); //0--------------------->(-1)
		assertTrue(g.existsEdge(1, 1)); //true
		assertEquals(0,g.removeNode(1)); //0
		assertFalse(g.existsNode(1)); //true---------------------->(false)
		assertFalse(g.existsNode(2)); //true---------------------->(false)
		assertFalse(g.existsNode(3)); //true---------------------->(false)
		assertFalse(g.existsNode(4)); //false
		assertEquals(0,g.addNode(4)); //0
		assertTrue(g.existsNode(4)); //true
		assertEquals(0,g.addEdge(4,4, 4.4)); //0
		assertTrue(g.existsEdge(4, 4)); //true
		g.getEdge(4, 4): //4.4
		g.removeNode(4): //0
		g.removeNode(4): //0
		g.existsEdge(4, 4): //true-------------------->(false)
		g.addNode(7): //0
		g.removeNode(2): //0
		g.removeNode(3): //0
		g.removeNode(4): //-1
		g.existsEdge(7, 7): //false
		g.addEdge(7,7, 7.7): //0
		g.addEdge(7,7, 17.17): //-4
		g.getEdge(7, 7): //7.7
		g.addNode(8): //0
		g.addNode(9): //0
		g.existsEdge(7, 8): //false
		g.existsEdge(8, 7): //false
		g.existsEdge(8, 8): //false
		g.existsEdge(8, 9): //true
		g.existsEdge(9, 8): //true
	    g.existsEdge(9, 9): //false
		g.addEdge(7,8, 7.8): //0
		g.addEdge(8,7, 8.7): //0
		g.addEdge(8,8, 8.8): //0
		g.addEdge(8,9, 8.9): //-4
		g.addEdge(9,8, 9.8): //-4
		g.addEdge(9,9, 9.9): //0
		g.addEdge(7,9, 7.9): //0
		g.addEdge(9,7, 9.7): //0
		g.getEdge(7, 7); //-4.0
		g.getEdge(7, 8) --> 7.8
		g.getEdge(7, 9) --> 7.9
		g.getEdge(8, 7) --> 8.7
		g.getEdge(8, 8) --> 8.8
		g.getEdge(8, 9) --> 1.2
		g.getEdge(9, 7) --> 9.7
		g.getEdge(9, 8) --> 2.1
		g.getEdge(9, 9) --> 9.9
		g.removeNode(7): 0
		g.removeNode(7): 0
		g.getEdge(7, 7) --> -4.0
		g.getEdge(7, 8) --> 7.8
		g.getEdge(7, 9) --> 7.9
		g.getEdge(8, 7) --> 8.7
		g.getEdge(8, 8) --> 8.8
		g.getEdge(8, 9) --> 1.2
		g.getEdge(9, 7) --> 9.7
		g.getEdge(9, 8) --> 2.1
		g.getEdge(9, 9) --> 9.9
		g.removeNode(null): -1
		g.addNode(null): -4
		g.addNode(10): 0
		g.getEdge(8, 10) --> 8.7
		g.getEdge(10, 9) --> 7.9
		g.addNode(null): -6
		g.addEdge(8,8,-8.8): -12
		g.addEdge(7,8,-7.8): -9
		g.addEdge(8,7,-8.7): -10
		g.addEdge(7,7,-7.7): -11
		g.addEdge(null,8,0.8): -1
		g.addEdge(8,null,0.8): -2
		g.addEdge(null,null,0.8): -3
		g.getEdge(null,10): -1.0
		g.getEdge(10,null): -2.0
		g.getEdge(null,null): -3.0
		g.existsNode(null): false
		g.existsEdge(null,null): false
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-10-06 11:46:32.530
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-10-06 11:46:32.531
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-10-06 11:46:32.929
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package p2Grafos;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import org.junit.Test;

/**
 * Titulo: Clase GraphTests
 * 
 * @author UO281847
 * @version 24/09/2021
 */
public class GraphTests {
	private Graph<Integer> g;
///*
// * Pruebas del método addNode:	
// */
//	/**
//	 * Test del método addNode sin errores
//	 */
//	@Test
//	public void testAddNodeFirst() {
//		Graph<Integer> g = new Graph<Integer>(3);
//		int node = 12;
//		assertEquals(0, g.addNode(node));
//		System.out.println(g.toString());	
//	}	
//	/**
//	 * Test del método addNode con nodo no valido
//	 */
//	@Test
//	public void testAddNodeNotValid() {
//		Graph<Integer> g = new Graph<Integer>(3);
//		int node = 1;
//		int node2 = 18;
//		assertEquals(0, g.addNode(node));
//		assertEquals(0, g.addNode(node2));
//		assertEquals(-5, g.addNode(null));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addNode cuando ya esta lleno
//	 */
//	@Test
//	public void testAddNodeFull() {
//		Graph<Integer> g = new Graph<Integer>(3);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 39;
//		int node4= 2;
//		assertEquals(0, g.addNode(node));
//		assertEquals(0, g.addNode(node2));
//		assertEquals(0, g.addNode(node3));
//		assertEquals(-2, g.addNode(node4));		
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addNode cuando ya existe
//	 */
//	@Test
//	public void testAddNodeAlreadyExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 39;
//		int node4 = 19;
//		int node5= 19;
//		assertEquals(0, g.addNode(node));
//		assertEquals(0, g.addNode(node2));
//		assertEquals(0, g.addNode(node3));
//		assertEquals(0, g.addNode(node4));
//		assertEquals(-1, g.addNode(node5));	
//		System.out.println(g.toString());	
//	}
//	
///*
// * Pruebas del método getNode:
// */
//	/**
//	 * Test del método getNode que devuelve la posición
//	 */
//	@Test
//	public void testGetNodeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		g.addNode(node);
//		assertEquals(0, g.getNode(node));
//	}
//	/**
//	 * Test del método getNode que devuelve la posición ya añadido
//	 */
//	@Test
//	public void testGetNodeVarious() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 23;
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(1, g.getNode(node2));
//	}
//	/**
//	 * Test del método getNode que devuelve -1
//	 */
//	@Test
//	public void testGetNodeDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 23;
//		g.addNode(node);
//		assertEquals(-1, g.getNode(node2));
//	}
//
///**
// * Pruebas del método existsNode:
// */
//	/**
//	 * Test del método existsNode que devuelve true
//	 */
//	@Test
//	public void testExistsNodeOne() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		g.addNode(node);
//		assertTrue(g.existsNode(node));
//	}
//	/**
//	 * Test del método existsNode que devuelve true
//	 */
//	@Test
//	public void testExistsNodeVarious() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 23;
//		g.addNode(node);
//		g.addNode(node2);
//		assertTrue(g.existsNode(node2));
//	}
//	/**
//	 * Test del método existsNode que devuelve true
//	 */
//	@Test
//	public void testExistsNodeFalse() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 23;
//		g.addNode(node);
//		assertFalse(g.existsNode(node2));
//	}
//
///*
// * Pruebas del método addEdge:
// */
//	/**
//	 * Test del método addEdge que no tiene errores
//	 */
//	@Test
//	public void testAddEdgeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;		
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(0, g.addEdge(node, node2, 12));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde no existe el nodo origen
//	 */
//	@Test
//	public void testAddEdgeSourceDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 23;
//		g.addNode(node);
//		g.addNode(node2);		
//		assertEquals(-1, g.addEdge(node3, node2, 12));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde no existe el nodo destino
//	 */
//	@Test
//	public void testAddEdgeTargetDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 23;
//		g.addNode(node);
//		g.addNode(node2);		
//		assertEquals(-2, g.addEdge(node, node3, 12));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde ya existe la arista
//	 */
//	@Test
//	public void testAddEdgeEdgeExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 12);
//		assertEquals(-4, g.addEdge(node, node2, 12));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde el peso no es valido
//	 */
//	@Test
//	public void testAddEdgeEdgeWightError() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(-8, g.addEdge(node, node2, -4));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde no existen los nodos 
//	 */
//	@Test
//	public void testAddEdgeSourceTargetError() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 12;
//		int node4 = 56;
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(-3, g.addEdge(node3, node4, 4));
//		System.out.println(g.toString());	
//	}
//	/**
//	 * Test del método addEdge donde ya existe la arista y el peso no es valido
//	 */
//	@Test
//	public void testAddEdgeEdgeExistsEdgeWeightError() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-12, g.addEdge(node, node2, -4));
//		System.out.println(g.toString());	
//	}
//	
///*
// * Pruebas del método getEdge:
// */
//	/**
//	 * Test del método getEdge que no tiene errores
//	 */
//	@Test
//	public void testGetEdgeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(4, g.getEdge(node, node2),0.1);
//	}
//	/**
//	 * Test del método getEdge donde no existe el nodo origen
//	 */
//	@Test
//	public void testGetEdgeSourceDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 4;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-1, g.getEdge(node3, node2),0.1);
//	}
//	/**
//	 * Test del método getEdge donde no existe el nodo destino
//	 */
//	@Test
//	public void testGetEdgeTargetDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 4;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-2, g.getEdge(node, node3),0.1);
//	}
//	/**
//	 * Test del método getEdge donde existen los nodos y no la arista
//	 */
//	@Test
//	public void testGetEdgeEdgeDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		assertEquals(-4, g.getEdge(node, node2),0.1);
//	}
//	/**
//	 * Test del método getEdge donde no existen los nodos
//	 */
//	@Test
//	public void testGetEdgeBothDontExist() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 4;
//		int node4 = 6;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-3, g.getEdge(node3, node4),0.1);
//	}
//	
///*
// * Pruebas del método existsEdge:
// */
//	/**
//	 * Test del método existsEdge que no tiene errores
//	 */
//	@Test
//	public void testExistsEdgeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertTrue(g.existsEdge(node, node2));
//	}
//	/**
//	 * Test del método existsEdge donde no existe el nodo origen
//	 */
//	@Test
//	public void testExistsEdgeSourceDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3= 8;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertFalse(g.existsEdge(node3, node2));
//	}
//	/**
//	 * Test del método existsEdge donde no existe el nodo destino
//	 */
//	@Test
//	public void testExistsEdgeTargetDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3= 8;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertFalse(g.existsEdge(node, node3));
//	}
//	/**
//	 * Test del método existsEdge donde no existen los nodos
//	 */
//	@Test
//	public void testExistsEdgeBothDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		int node4 = 12;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertFalse(g.existsEdge(node3, node4));
//	}
//	
///*
// * Pruebas del método removeEdge:
// */
//	/**
//	 * Test del método removeEdge que no tiene errores 
//	 */
//	@Test
//	public void testRemoveEdgeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		int node4 = 12;
//		g.addNode(node);
//		g.addNode(node2); 
//		g.addNode(node3);
//		g.addNode(node4);
//		g.addEdge(node, node2, 4);
//		g.addEdge(node3, node4, 12);
//		assertEquals(0, g.removeEdge(node3, node4));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeEdge donde no existe el nodo origen
//	 */
//	@Test
//	public void testRemoveEdgeSourceDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		g.addNode(node);
//		g.addNode(node2); 
//		g.addEdge(node, node2, 4);
//		assertEquals(-1, g.removeEdge(node3, node2));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeEdge donde no existe el nodo destino
//	 */
//	@Test
//	public void testRemoveEdgeTargetDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		g.addNode(node);
//		g.addNode(node2); 
//		g.addEdge(node, node2, 4);
//		assertEquals(-2, g.removeEdge(node2, node3));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeEdge donde existen los nodos y no la arista
//	 */
//	@Test
//	public void testRemoveEdgeEdgeDontExistsNodesExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		g.addNode(node);
//		g.addNode(node2); 
//		g.addEdge(node, node2, 4);
//		assertEquals(-4, g.removeEdge(node2, node));
//		System.out.println(g.toString());
//	}	
//	/**
//	 * Test del método removeEdge donde no existen los nodos
//	 */
//	@Test
//	public void testRemoveEdgeNodesDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		int node4 = 12;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-3, g.removeEdge(node3, node4));
//		System.out.println(g.toString());
//	}
///*
// * Pruebas del método removeNode:
// */
//	/**
//	 * Test del método removeNode que no tiene errores
//	 */
//	@Test
//	public void testRemoveNodeNormal() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;		
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(0, g.removeNode(node));
//		assertFalse(g.existsNode(node));
//		assertFalse(g.existsEdge(node, node2));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeNode que no tiene errores y borra toda la matriz
//	 */
//	@Test
//	public void testRemoveNodeVarious() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 8;
//		int node4 = 12;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		g.addEdge(node, node, 12);
//		g.addEdge(node3, node, 7);
//		g.addEdge(node, node4, 15);
//		g.addEdge(node, node3, 9);
//		assertEquals(0, g.removeNode(node));
//		assertFalse(g.existsNode(node));
//		assertFalse(g.existsEdge(node, node2));
//		assertFalse(g.existsEdge(node, node));
//		assertFalse(g.existsEdge(node3, node));
//		assertFalse(g.existsEdge(node, node4));
//		assertFalse(g.existsEdge(node, node3));
//		System.out.println(g.toString());
//	}	
//	/**
//	 * Test del método removeNode donde el nodo no es valido
//	 */
//	@Test
//	public void testRemoveNodeNotValid() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;		
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-1, g.removeNode(null));
//		System.out.println(g.toString());
//	}
//	/**
//	 * Test del método removeNode donde el nodo no existe
//	 */
//	@Test
//	public void testRemoveNodeDontExists() {
//		Graph<Integer> g = new Graph<Integer>(5);
//		int node = 1;
//		int node2 = 18;
//		int node3 = 12;
//		g.addNode(node);
//		g.addNode(node2);
//		g.addEdge(node, node2, 4);
//		assertEquals(-1, g.removeNode(node3));
//		System.out.println(g.toString());
//	}
	/**
	 * Pruebas basicas de nodos
	 */
//	@Test
//	public void basicNodeTest() {
//		g=new Graph<Integer>(3); 
//	    assertFalse(g.existsNode(1)); //false
//	    assertFalse(g.existsNode(2)); //false
//	    assertEquals(0,g.addNode(1)); //0
//		assertEquals(0,g.addNode(2)); //0
//		assertTrue(g.existsNode(1)); //true
//		assertTrue(g.existsNode(2)); //true
//		assertEquals(-1,g.addNode(1)); //-1
//		assertEquals(-1,g.addNode(2)); //-1
//		assertEquals(0,g.addNode(3)); //0
//		assertEquals(-2,g.addNode(4)); //-2
//		assertFalse(g.existsNode(4)); //false
//		assertFalse(g.existsNode(5)); //false
//	}
	
//	@Test
//	public void basicEdgeTest() {
//		g=new Graph<Integer>(3); 
//		assertFalse(g.existsEdge(1,2)); //false
//		assertEquals(-3.0,g.getEdge(1,2),0.1); //-3.0
//		assertEquals(0,g.addNode(1)); //0
//		assertFalse(g.existsEdge(1,2)); //false
//		assertEquals(-2.0,g.getEdge(1,2),0.1); //-2.0
//		assertFalse(g.existsEdge(2,1)); //false
//		assertEquals(-1.0,g.getEdge(2,1),0.1); //-1.0
//		assertEquals(0,g.addNode(2)); //0
//		assertFalse(g.existsEdge(1,2)); //false
//		assertEquals(-4.0,g.getEdge(1,2),0.1); //-4.0
//		assertEquals(0,g.addEdge(1,2,12.12)); //0
//		assertEquals(-4,g.addEdge(1,2,12.1212)); //-4
//		assertEquals(0,g.addNode(3)); //0
//		assertFalse(g.existsEdge(1,3)); //false
//		assertFalse(g.existsEdge(3,2)); //false
//		assertEquals(-4.0,g.getEdge(1,3),0.1); //-4.0
//		assertEquals(-4.0,g.getEdge(3,2),0.1); //-4.0
//		assertEquals(0,g.addEdge(1,1,11.11)); //0
//		assertEquals(-4,g.addEdge(1,2,12.12)); //-4
//		assertEquals(0,g.addEdge(1,3,13.13)); //0
//		assertEquals(0,g.addEdge(2,1,21.21)); //0
//		assertEquals(0,g.addEdge(2,2,22.22)); //0
//		assertEquals(0,g.addEdge(2,3,23.23)); //0
//		assertEquals(0,g.addEdge(3,1,31.31)); //0
//		assertEquals(0,g.addEdge(3,2,32.32)); //0
//		assertEquals(0,g.addEdge(3,3,33.33)); //0
//		assertEquals(-4,g.addEdge(1,1,11.11)); //-4
//		assertEquals(-4,g.addEdge(1,2,12.12)); //-4
//		assertEquals(-4,g.addEdge(1,3,13.13)); //-4
//		assertEquals(-4,g.addEdge(2,1,21.21)); //-4
//		assertEquals(-4,g.addEdge(2,2,22.22)); //-4
//		assertEquals(-4,g.addEdge(2,3,23.23)); //-4
//		assertEquals(-4,g.addEdge(3,1,31.31)); //-4
//		assertEquals(-4,g.addEdge(3,2,32.32)); //-4
//		assertEquals(-4,g.addEdge(3,3,33.33)); //-4
//		g.getEdge(1,1,11.11); //11.11
//		g.getEdge(1,2,12.12); //12.12
//		g.getEdge(1,3,13.13); //13.129999999999999
//		g.getEdge(2,1,21.21); //21.21
//		g.getEdge(2,2,22.22); //22.22
//		g.getEdge(2,3,23.23); //23.23
//		g.getEdge(3,1,31.31); //31.310000000000002
//		g.getEdge(3,2,32.32); //32.32
//		g.getEdge(3,3,33.33); //33.33
//	}
	
	@Test
	public void basicEvolutionTest() {
		g=new Graph<Integer>(3); 
		assertFalse(g.existsNode(1)); //false
		assertFalse(g.existsNode(2)); //false
		assertEquals(0,g.addNode(1)); //0
		assertEquals(0,g.addNode(2)); //0
		assertTrue(g.existsNode(1)); //true
		assertTrue(g.existsNode(2)); //true
		assertEquals(-1,g.addNode(1)); //-1
		assertEquals(-1,g.addNode(2)); //-1
		assertEquals(0,g.addEdge(1,2, 1.2)); //0
		assertEquals(0,g.addEdge(2,1, 2.1));//0
		assertEquals(0,g.addEdge(1,1, 1.1)); //0
		assertEquals(1.2,g.getEdge(1,2),0.1); //1.2
		assertEquals(2.1,g.getEdge(2,1),0.1); //2.1
		assertEquals(1.1,g.getEdge(1,1),0.1); //1.1
		assertEquals(-2.0,g.getEdge(2,3),0.1); //-2.0
		assertTrue(g.existsEdge(1,2)); //true
		assertTrue(g.existsEdge(2,1)); //true
		assertTrue(g.existsEdge(1,1)); //true
		assertFalse(g.existsEdge(2,2)); //false
		assertEquals(-4,g.removeEdge(2,2)); //-4
		assertEquals(0,g.addEdge(2,2,2.2)); //0
		assertEquals(2.2,g.getEdge(2,2),0.1); //2.2
		assertTrue(g.existsEdge(2,2)); //true
		assertEquals(0,g.removeEdge(2,2)); //0
		assertEquals(-1,g.removeNode(3)); //-1
		assertEquals(0,g.addNode(3)); //0		
		assertEquals(-2,g.addNode(4)); //-2
		assertEquals(-4.0,g.getEdge(1, 3),0.1); //-4.0
		assertEquals(0,g.addEdge(1,3, 1.3)); //0	
		assertTrue(g.existsEdge(1, 3)); //true	
		assertEquals(1.3,g.getEdge(1, 3),0.1); //1.3
		assertEquals(-2.0,g.getEdge(1, 4),0.1); //-2.0
		assertEquals(-1.0,g.getEdge(5,1),0.1); //-1.0
		assertEquals(-3.0,g.getEdge(5,4),0.1); //-3.0
		assertEquals(0,g.removeNode(3)); //0
		assertEquals(-1,g.removeNode(3)); //0---------------->(-1)
		assertFalse(g.existsEdge(1, 3)); //true---------------->(false)	
		assertEquals(-2.0,g.getEdge(1, 3),0.1); //1.3------------------->(-2.0)
		assertEquals(0,g.removeNode(2)); //0
		assertEquals(-1,g.removeNode(2)); //0--------------------->(-1)
		assertTrue(g.existsEdge(1, 1)); //true
		assertEquals(0,g.removeNode(1)); //0
		assertFalse(g.existsNode(1)); //true---------------------->(false)
		assertFalse(g.existsNode(2)); //true---------------------->(false)
		assertFalse(g.existsNode(3)); //true---------------------->(false)
		assertFalse(g.existsNode(4)); //false
		assertEquals(0,g.addNode(4)); //0
		assertTrue(g.existsNode(4)); //true
		assertEquals(0,g.addEdge(4,4, 4.4)); //0
		assertTrue(g.existsEdge(4, 4)); //true
		g.getEdge(4, 4): //4.4
		g.removeNode(4): //0
		g.removeNode(4): //0
		g.existsEdge(4, 4): //true-------------------->(false)
		g.addNode(7): //0
		g.removeNode(2): //0
		g.removeNode(3): //0
		g.removeNode(4): //-1
		g.existsEdge(7, 7): //false
		g.addEdge(7,7, 7.7): //0
		g.addEdge(7,7, 17.17): //-4
		g.getEdge(7, 7): //7.7
		g.addNode(8): //0
		g.addNode(9): //0
		g.existsEdge(7, 8): //false
		g.existsEdge(8, 7): //false
		g.existsEdge(8, 8): //false
		g.existsEdge(8, 9): //true
		g.existsEdge(9, 8): //true
	    g.existsEdge(9, 9): //false
		g.addEdge(7,8, 7.8): //0
		g.addEdge(8,7, 8.7): //0
		g.addEdge(8,8, 8.8): //0
		g.addEdge(8,9, 8.9): //-4
		g.addEdge(9,8, 9.8): //-4
		g.addEdge(9,9, 9.9): //0
		g.addEdge(7,9, 7.9): //0
		g.addEdge(9,7, 9.7): //0
		g.getEdge(7, 7); //-4.0
		g.getEdge(7, 8) --> 7.8
		g.getEdge(7, 9) --> 7.9
		g.getEdge(8, 7) --> 8.7
		g.getEdge(8, 8) --> 8.8
		g.getEdge(8, 9) --> 1.2
		g.getEdge(9, 7) --> 9.7
		g.getEdge(9, 8) --> 2.1
		g.getEdge(9, 9) --> 9.9
		g.removeNode(7): 0
		g.removeNode(7): 0
		g.getEdge(7, 7) --> -4.0
		g.getEdge(7, 8) --> 7.8
		g.getEdge(7, 9) --> 7.9
		g.getEdge(8, 7) --> 8.7
		g.getEdge(8, 8) --> 8.8
		g.getEdge(8, 9) --> 1.2
		g.getEdge(9, 7) --> 9.7
		g.getEdge(9, 8) --> 2.1
		g.getEdge(9, 9) --> 9.9
		g.removeNode(null): -1
		g.addNode(null): -4
		g.addNode(10): 0
		g.getEdge(8, 10) --> 8.7
		g.getEdge(10, 9) --> 7.9
		g.addNode(null): -6
		g.addEdge(8,8,-8.8): -12
		g.addEdge(7,8,-7.8): -9
		g.addEdge(8,7,-8.7): -10
		g.addEdge(7,7,-7.7): -11
		g.addEdge(null,8,0.8): -1
		g.addEdge(8,null,0.8): -2
		g.addEdge(null,null,0.8): -3
		g.getEdge(null,10): -1.0
		g.getEdge(10,null): -2.0
		g.getEdge(null,null): -3.0
		g.existsNode(null): false
		g.existsEdge(null,null): false
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-10-06 11:46:32.930
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-10-06 11:46:32.932
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SESSION 2021-10-06 22:12:11.770 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=15.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_ES
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-10-06 22:12:16.580
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-10-06 22:12:16.580
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@66456506,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@69944a90,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-10-06 22:12:19.818
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\omart'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-10-06 22:47:54.098 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=15.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_ES
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-10-06 22:47:57.429
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-10-06 22:47:57.429
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6f430ea8,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@119f072c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-10-06 22:48:00.393
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\omart'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-10-06 23:41:36.983 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=15.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_ES
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-10-06 23:41:40.391
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-10-06 23:41:40.391
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5fd4e67f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@59b1edab,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-10-06 23:41:42.820
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\omart'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-10-07 11:03:23.974 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=15.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_ES
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-10-07 11:03:27.969
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-10-07 11:03:27.969
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6f430ea8,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@119f072c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-10-07 11:03:30.762
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\omart'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-10-07 12:46:34.453 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=15.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_ES
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-10-07 12:46:44.014
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-10-07 12:46:44.014
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@119f072c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@66456506,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-10-07 12:46:46.772
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\omart'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-10-07 13:08:34.371 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=15.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_ES
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-10-07 13:08:44.530
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-10-07 13:08:44.530
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@58e5fbe5,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@335896bd,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-10-07 13:08:47.050
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\omart'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-10-07 22:33:25.320 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=15.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_ES
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-10-07 22:33:41.368
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-10-07 22:33:41.368
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@335896bd,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6b33892a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-10-07 22:33:44.087
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\omart'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-10-08 11:53:19.476 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=15.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_ES
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-10-08 11:53:28.405
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-10-08 11:53:28.405
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@147375b3,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6f430ea8,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-10-08 11:53:30.975
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\omart'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-10-09 20:21:30.910 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=15.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_ES
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-10-09 20:21:36.296
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-10-09 20:21:36.296
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@69944a90,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1ed52f44,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-10-09 20:21:38.950
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\omart'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.ui 4 4 2021-10-09 20:22:19.835
!MESSAGE Unable to create part
!STACK 1
org.eclipse.ui.PartInitException: Cannot determine URI for '/ED-2021-22-TeixeiraGonzalezOmar-UO281847/src/p2Grafos/Graph.java'.
	at org.eclipse.ui.texteditor.AbstractTextEditor.internalInit(AbstractTextEditor.java:3204)
	at org.eclipse.ui.texteditor.AbstractTextEditor.init(AbstractTextEditor.java:3215)
	at org.eclipse.ui.internal.EditorReference.initialize(EditorReference.java:353)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.create(CompatibilityPart.java:344)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:995)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:960)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalInject(InjectorImpl.java:140)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalMake(InjectorImpl.java:403)
	at org.eclipse.e4.core.internal.di.InjectorImpl.make(InjectorImpl.java:330)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.make(ContextInjectionFactory.java:202)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.createFromBundle(ReflectionContributionFactory.java:91)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.doCreate(ReflectionContributionFactory.java:60)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.create(ReflectionContributionFactory.java:42)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributedPartRenderer.createWidget(ContributedPartRenderer.java:132)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:994)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:658)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:762)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:727)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:711)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.lambda$0(PartServiceImpl.java:104)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.lambda$0(UIEventHandler.java:38)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:236)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4770)
	at org.eclipse.e4.ui.workbench.swt.DisplayUISynchronize.syncExec(DisplayUISynchronize.java:34)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.handleEvent(UIEventHandler.java:38)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:228)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:133)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.e4.ui.model.application.ui.impl.ElementContainerImpl.setSelectedElementGen(ElementContainerImpl.java:170)
	at org.eclipse.e4.ui.model.application.ui.impl.ElementContainerImpl.setSelectedElement(ElementContainerImpl.java:188)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.hidePart(PartServiceImpl.java:1380)
	at org.eclipse.ui.internal.WorkbenchPage.hidePart(WorkbenchPage.java:1547)
	at org.eclipse.ui.internal.WorkbenchPage.hidePart(WorkbenchPage.java:1499)
	at org.eclipse.ui.internal.WorkbenchPage.closeEditors(WorkbenchPage.java:1469)
	at org.eclipse.ui.internal.WorkbenchPage.closeEditor(WorkbenchPage.java:1593)
	at org.eclipse.ui.texteditor.AbstractTextEditor.lambda$3(AbstractTextEditor.java:4278)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4029)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.jface.operation.ModalContext$ModalContextThread.block(ModalContext.java:166)
	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:368)
	at org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.run(RefactoringWizardDialog2.java:324)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizard.internalPerformFinish(RefactoringWizard.java:636)
	at org.eclipse.ltk.ui.refactoring.UserInputWizardPage.performFinish(UserInputWizardPage.java:148)
	at org.eclipse.ltk.ui.refactoring.resource.DeleteResourcesWizard$DeleteResourcesRefactoringConfigurationPage.performFinish(DeleteResourcesWizard.java:284)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizard.performFinish(RefactoringWizard.java:710)
	at org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.okPressed(RefactoringWizardDialog2.java:450)
	at org.eclipse.jface.dialogs.Dialog.buttonPressed(Dialog.java:468)
	at org.eclipse.jface.dialogs.Dialog.lambda$0(Dialog.java:619)
	at org.eclipse.swt.events.SelectionListener$1.widgetSelected(SelectionListener.java:84)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:252)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4237)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1060)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4054)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3626)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:823)
	at org.eclipse.jface.window.Window.open(Window.java:799)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation.lambda$0(RefactoringWizardOpenOperation.java:190)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation.run(RefactoringWizardOpenOperation.java:209)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation.run(RefactoringWizardOpenOperation.java:126)
	at org.eclipse.ltk.internal.ui.refactoring.actions.DeleteResourcesHandler.execute(DeleteResourcesHandler.java:44)
	at org.eclipse.ui.internal.handlers.HandlerProxy.execute(HandlerProxy.java:283)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:317)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:251)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:487)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.ui.internal.handlers.LegacyHandlerService.executeCommandInContext(LegacyHandlerService.java:440)
	at org.eclipse.ui.internal.ide.actions.LTKLauncher.runCommand(LTKLauncher.java:140)
	at org.eclipse.ui.internal.ide.actions.LTKLauncher.openDeleteWizard(LTKLauncher.java:57)
	at org.eclipse.ui.actions.DeleteResourceAction.run(DeleteResourceAction.java:452)
	at org.eclipse.jdt.internal.ui.refactoring.reorg.DeleteAction.run(DeleteAction.java:196)
	at org.eclipse.jdt.ui.actions.SelectionDispatchAction.dispatchRun(SelectionDispatchAction.java:274)
	at org.eclipse.jdt.ui.actions.SelectionDispatchAction.run(SelectionDispatchAction.java:252)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:580)
	at org.eclipse.jface.action.ActionContributionItem.lambda$4(ActionContributionItem.java:414)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4237)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1060)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4054)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3626)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1150)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1041)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
Caused by: org.eclipse.core.runtime.CoreException: Cannot determine URI for '/ED-2021-22-TeixeiraGonzalezOmar-UO281847/src/p2Grafos/Graph.java'.
	at org.eclipse.core.internal.filebuffers.ResourceFileBuffer.create(ResourceFileBuffer.java:239)
	at org.eclipse.core.internal.filebuffers.TextFileBufferManager.connect(TextFileBufferManager.java:115)
	at org.eclipse.ui.editors.text.TextFileDocumentProvider.createFileInfo(TextFileDocumentProvider.java:563)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider.createFileInfo(CompilationUnitDocumentProvider.java:1018)
	at org.eclipse.ui.editors.text.TextFileDocumentProvider.connect(TextFileDocumentProvider.java:481)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider.connect(CompilationUnitDocumentProvider.java:1284)
	at org.eclipse.ui.texteditor.AbstractTextEditor.doSetInput(AbstractTextEditor.java:4183)
	at org.eclipse.ui.texteditor.StatusTextEditor.doSetInput(StatusTextEditor.java:262)
	at org.eclipse.ui.texteditor.AbstractDecoratedTextEditor.doSetInput(AbstractDecoratedTextEditor.java:1479)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.internalDoSetInput(JavaEditor.java:2554)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.doSetInput(JavaEditor.java:2527)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.doSetInput(CompilationUnitEditor.java:1410)
	at org.eclipse.ui.texteditor.AbstractTextEditor.lambda$1(AbstractTextEditor.java:3173)
	at org.eclipse.jface.operation.ModalContext.runInCurrentThread(ModalContext.java:434)
	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:352)
	at org.eclipse.ui.internal.WorkbenchWindow.lambda$7(WorkbenchWindow.java:2345)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.ui.internal.WorkbenchWindow.run(WorkbenchWindow.java:2343)
	at org.eclipse.ui.texteditor.AbstractTextEditor.internalInit(AbstractTextEditor.java:3190)
	... 128 more
!SUBENTRY 1 org.eclipse.core.filebuffers 4 0 2021-10-09 20:22:19.836
!MESSAGE Cannot determine URI for '/ED-2021-22-TeixeiraGonzalezOmar-UO281847/src/p2Grafos/Graph.java'.
!STACK 1
org.eclipse.core.runtime.CoreException: Cannot determine URI for '/ED-2021-22-TeixeiraGonzalezOmar-UO281847/src/p2Grafos/Graph.java'.
	at org.eclipse.core.internal.filebuffers.ResourceFileBuffer.create(ResourceFileBuffer.java:239)
	at org.eclipse.core.internal.filebuffers.TextFileBufferManager.connect(TextFileBufferManager.java:115)
	at org.eclipse.ui.editors.text.TextFileDocumentProvider.createFileInfo(TextFileDocumentProvider.java:563)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider.createFileInfo(CompilationUnitDocumentProvider.java:1018)
	at org.eclipse.ui.editors.text.TextFileDocumentProvider.connect(TextFileDocumentProvider.java:481)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider.connect(CompilationUnitDocumentProvider.java:1284)
	at org.eclipse.ui.texteditor.AbstractTextEditor.doSetInput(AbstractTextEditor.java:4183)
	at org.eclipse.ui.texteditor.StatusTextEditor.doSetInput(StatusTextEditor.java:262)
	at org.eclipse.ui.texteditor.AbstractDecoratedTextEditor.doSetInput(AbstractDecoratedTextEditor.java:1479)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.internalDoSetInput(JavaEditor.java:2554)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.doSetInput(JavaEditor.java:2527)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.doSetInput(CompilationUnitEditor.java:1410)
	at org.eclipse.ui.texteditor.AbstractTextEditor.lambda$1(AbstractTextEditor.java:3173)
	at org.eclipse.jface.operation.ModalContext.runInCurrentThread(ModalContext.java:434)
	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:352)
	at org.eclipse.ui.internal.WorkbenchWindow.lambda$7(WorkbenchWindow.java:2345)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.ui.internal.WorkbenchWindow.run(WorkbenchWindow.java:2343)
	at org.eclipse.ui.texteditor.AbstractTextEditor.internalInit(AbstractTextEditor.java:3190)
	at org.eclipse.ui.texteditor.AbstractTextEditor.init(AbstractTextEditor.java:3215)
	at org.eclipse.ui.internal.EditorReference.initialize(EditorReference.java:353)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.create(CompatibilityPart.java:344)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:995)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:960)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalInject(InjectorImpl.java:140)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalMake(InjectorImpl.java:403)
	at org.eclipse.e4.core.internal.di.InjectorImpl.make(InjectorImpl.java:330)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.make(ContextInjectionFactory.java:202)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.createFromBundle(ReflectionContributionFactory.java:91)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.doCreate(ReflectionContributionFactory.java:60)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.create(ReflectionContributionFactory.java:42)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributedPartRenderer.createWidget(ContributedPartRenderer.java:132)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:994)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:658)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:762)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:727)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:711)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.lambda$0(PartServiceImpl.java:104)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.lambda$0(UIEventHandler.java:38)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:236)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4770)
	at org.eclipse.e4.ui.workbench.swt.DisplayUISynchronize.syncExec(DisplayUISynchronize.java:34)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.handleEvent(UIEventHandler.java:38)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:228)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:133)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.e4.ui.model.application.ui.impl.ElementContainerImpl.setSelectedElementGen(ElementContainerImpl.java:170)
	at org.eclipse.e4.ui.model.application.ui.impl.ElementContainerImpl.setSelectedElement(ElementContainerImpl.java:188)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.hidePart(PartServiceImpl.java:1380)
	at org.eclipse.ui.internal.WorkbenchPage.hidePart(WorkbenchPage.java:1547)
	at org.eclipse.ui.internal.WorkbenchPage.hidePart(WorkbenchPage.java:1499)
	at org.eclipse.ui.internal.WorkbenchPage.closeEditors(WorkbenchPage.java:1469)
	at org.eclipse.ui.internal.WorkbenchPage.closeEditor(WorkbenchPage.java:1593)
	at org.eclipse.ui.texteditor.AbstractTextEditor.lambda$3(AbstractTextEditor.java:4278)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4029)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.jface.operation.ModalContext$ModalContextThread.block(ModalContext.java:166)
	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:368)
	at org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.run(RefactoringWizardDialog2.java:324)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizard.internalPerformFinish(RefactoringWizard.java:636)
	at org.eclipse.ltk.ui.refactoring.UserInputWizardPage.performFinish(UserInputWizardPage.java:148)
	at org.eclipse.ltk.ui.refactoring.resource.DeleteResourcesWizard$DeleteResourcesRefactoringConfigurationPage.performFinish(DeleteResourcesWizard.java:284)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizard.performFinish(RefactoringWizard.java:710)
	at org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.okPressed(RefactoringWizardDialog2.java:450)
	at org.eclipse.jface.dialogs.Dialog.buttonPressed(Dialog.java:468)
	at org.eclipse.jface.dialogs.Dialog.lambda$0(Dialog.java:619)
	at org.eclipse.swt.events.SelectionListener$1.widgetSelected(SelectionListener.java:84)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:252)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4237)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1060)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4054)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3626)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:823)
	at org.eclipse.jface.window.Window.open(Window.java:799)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation.lambda$0(RefactoringWizardOpenOperation.java:190)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation.run(RefactoringWizardOpenOperation.java:209)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation.run(RefactoringWizardOpenOperation.java:126)
	at org.eclipse.ltk.internal.ui.refactoring.actions.DeleteResourcesHandler.execute(DeleteResourcesHandler.java:44)
	at org.eclipse.ui.internal.handlers.HandlerProxy.execute(HandlerProxy.java:283)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:317)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:251)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:487)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.ui.internal.handlers.LegacyHandlerService.executeCommandInContext(LegacyHandlerService.java:440)
	at org.eclipse.ui.internal.ide.actions.LTKLauncher.runCommand(LTKLauncher.java:140)
	at org.eclipse.ui.internal.ide.actions.LTKLauncher.openDeleteWizard(LTKLauncher.java:57)
	at org.eclipse.ui.actions.DeleteResourceAction.run(DeleteResourceAction.java:452)
	at org.eclipse.jdt.internal.ui.refactoring.reorg.DeleteAction.run(DeleteAction.java:196)
	at org.eclipse.jdt.ui.actions.SelectionDispatchAction.dispatchRun(SelectionDispatchAction.java:274)
	at org.eclipse.jdt.ui.actions.SelectionDispatchAction.run(SelectionDispatchAction.java:252)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:580)
	at org.eclipse.jface.action.ActionContributionItem.lambda$4(ActionContributionItem.java:414)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4237)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1060)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4054)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3626)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1150)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1041)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SUBENTRY 2 org.eclipse.core.filebuffers 4 0 2021-10-09 20:22:19.836
!MESSAGE Cannot determine URI for '/ED-2021-22-TeixeiraGonzalezOmar-UO281847/src/p2Grafos/Graph.java'.

!ENTRY org.eclipse.ui.workbench.texteditor 4 0 2021-10-09 20:26:41.199
!MESSAGE 
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.ui.texteditor.ITextEditor.isDirty()" because "this.fTextEditor" is null
	at org.eclipse.ui.texteditor.AbstractTextEditor$TextEditorSavable.isDirty(AbstractTextEditor.java:7166)
	at org.eclipse.ui.internal.Workbench.getFilteredSaveables(Workbench.java:3447)
	at org.eclipse.ui.internal.Workbench.saveAll(Workbench.java:3420)
	at org.eclipse.ui.ide.IDE$1.run(IDE.java:1494)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.ide.IDE.saveAllEditors(IDE.java:1482)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.doSave(SaveScopeResourcesHandler.java:228)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.handleStatus(SaveScopeResourcesHandler.java:182)
	at org.eclipse.debug.internal.ui.sourcelookup.Prompter.lambda$0(Prompter.java:73)
	at org.eclipse.ui.internal.PendingSyncExec.run(PendingSyncExec.java:68)
	at org.eclipse.ui.internal.UILockListener.doPendingWork(UILockListener.java:171)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4029)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1150)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1041)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.ui.workbench.texteditor 4 0 2021-10-09 20:27:18.333
!MESSAGE 
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.ui.texteditor.ITextEditor.isDirty()" because "this.fTextEditor" is null
	at org.eclipse.ui.texteditor.AbstractTextEditor$TextEditorSavable.isDirty(AbstractTextEditor.java:7166)
	at org.eclipse.ui.internal.Workbench.getFilteredSaveables(Workbench.java:3447)
	at org.eclipse.ui.internal.Workbench.saveAll(Workbench.java:3420)
	at org.eclipse.ui.ide.IDE$1.run(IDE.java:1494)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.ide.IDE.saveAllEditors(IDE.java:1482)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.doSave(SaveScopeResourcesHandler.java:228)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.handleStatus(SaveScopeResourcesHandler.java:182)
	at org.eclipse.debug.internal.ui.sourcelookup.Prompter.lambda$0(Prompter.java:73)
	at org.eclipse.ui.internal.PendingSyncExec.run(PendingSyncExec.java:68)
	at org.eclipse.ui.internal.UILockListener.doPendingWork(UILockListener.java:171)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4029)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1150)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1041)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.ui.workbench.texteditor 4 0 2021-10-09 20:31:25.538
!MESSAGE 
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.ui.texteditor.ITextEditor.isDirty()" because "this.fTextEditor" is null
	at org.eclipse.ui.texteditor.AbstractTextEditor$TextEditorSavable.isDirty(AbstractTextEditor.java:7166)
	at org.eclipse.ui.internal.Workbench.getFilteredSaveables(Workbench.java:3447)
	at org.eclipse.ui.internal.Workbench.saveAll(Workbench.java:3420)
	at org.eclipse.ui.ide.IDE$1.run(IDE.java:1494)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.ide.IDE.saveAllEditors(IDE.java:1482)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.doSave(SaveScopeResourcesHandler.java:228)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.handleStatus(SaveScopeResourcesHandler.java:182)
	at org.eclipse.debug.internal.ui.sourcelookup.Prompter.lambda$0(Prompter.java:73)
	at org.eclipse.ui.internal.PendingSyncExec.run(PendingSyncExec.java:68)
	at org.eclipse.ui.internal.UILockListener.doPendingWork(UILockListener.java:171)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4029)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1150)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1041)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.ui.workbench.texteditor 4 0 2021-10-09 20:35:49.861
!MESSAGE 
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.ui.texteditor.ITextEditor.isDirty()" because "this.fTextEditor" is null
	at org.eclipse.ui.texteditor.AbstractTextEditor$TextEditorSavable.isDirty(AbstractTextEditor.java:7166)
	at org.eclipse.ui.internal.Workbench.getFilteredSaveables(Workbench.java:3447)
	at org.eclipse.ui.internal.Workbench.saveAll(Workbench.java:3420)
	at org.eclipse.ui.ide.IDE$1.run(IDE.java:1494)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.ide.IDE.saveAllEditors(IDE.java:1482)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.doSave(SaveScopeResourcesHandler.java:228)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.handleStatus(SaveScopeResourcesHandler.java:182)
	at org.eclipse.debug.internal.ui.sourcelookup.Prompter.lambda$0(Prompter.java:73)
	at org.eclipse.ui.internal.PendingSyncExec.run(PendingSyncExec.java:68)
	at org.eclipse.ui.internal.UILockListener.doPendingWork(UILockListener.java:171)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4029)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1150)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1041)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.ui.workbench.texteditor 4 0 2021-10-09 20:36:39.009
!MESSAGE 
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.ui.texteditor.ITextEditor.isDirty()" because "this.fTextEditor" is null
	at org.eclipse.ui.texteditor.AbstractTextEditor$TextEditorSavable.isDirty(AbstractTextEditor.java:7166)
	at org.eclipse.ui.internal.Workbench.getFilteredSaveables(Workbench.java:3447)
	at org.eclipse.ui.internal.Workbench.saveAll(Workbench.java:3420)
	at org.eclipse.ui.ide.IDE$1.run(IDE.java:1494)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.ide.IDE.saveAllEditors(IDE.java:1482)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.doSave(SaveScopeResourcesHandler.java:228)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.handleStatus(SaveScopeResourcesHandler.java:182)
	at org.eclipse.debug.internal.ui.sourcelookup.Prompter.lambda$0(Prompter.java:73)
	at org.eclipse.ui.internal.PendingSyncExec.run(PendingSyncExec.java:68)
	at org.eclipse.ui.internal.UILockListener.doPendingWork(UILockListener.java:171)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4029)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1150)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1041)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.ui.workbench.texteditor 4 0 2021-10-09 20:36:52.513
!MESSAGE 
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.ui.texteditor.ITextEditor.isDirty()" because "this.fTextEditor" is null
	at org.eclipse.ui.texteditor.AbstractTextEditor$TextEditorSavable.isDirty(AbstractTextEditor.java:7166)
	at org.eclipse.ui.internal.Workbench.getFilteredSaveables(Workbench.java:3447)
	at org.eclipse.ui.internal.Workbench.saveAll(Workbench.java:3420)
	at org.eclipse.ui.ide.IDE$1.run(IDE.java:1494)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.ide.IDE.saveAllEditors(IDE.java:1482)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.doSave(SaveScopeResourcesHandler.java:228)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.handleStatus(SaveScopeResourcesHandler.java:182)
	at org.eclipse.debug.internal.ui.sourcelookup.Prompter.lambda$0(Prompter.java:73)
	at org.eclipse.ui.internal.PendingSyncExec.run(PendingSyncExec.java:68)
	at org.eclipse.ui.internal.UILockListener.doPendingWork(UILockListener.java:171)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4029)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1150)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1041)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.ui.workbench.texteditor 4 0 2021-10-09 20:40:48.704
!MESSAGE 
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.ui.texteditor.ITextEditor.isDirty()" because "this.fTextEditor" is null
	at org.eclipse.ui.texteditor.AbstractTextEditor$TextEditorSavable.isDirty(AbstractTextEditor.java:7166)
	at org.eclipse.ui.internal.Workbench.getFilteredSaveables(Workbench.java:3447)
	at org.eclipse.ui.internal.Workbench.saveAll(Workbench.java:3420)
	at org.eclipse.ui.ide.IDE$1.run(IDE.java:1494)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.ide.IDE.saveAllEditors(IDE.java:1482)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.doSave(SaveScopeResourcesHandler.java:228)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.handleStatus(SaveScopeResourcesHandler.java:182)
	at org.eclipse.debug.internal.ui.sourcelookup.Prompter.lambda$0(Prompter.java:73)
	at org.eclipse.ui.internal.PendingSyncExec.run(PendingSyncExec.java:68)
	at org.eclipse.ui.internal.UILockListener.doPendingWork(UILockListener.java:171)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4029)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1150)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1041)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.ui.workbench.texteditor 4 0 2021-10-09 20:40:58.820
!MESSAGE 
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.ui.texteditor.ITextEditor.isDirty()" because "this.fTextEditor" is null
	at org.eclipse.ui.texteditor.AbstractTextEditor$TextEditorSavable.isDirty(AbstractTextEditor.java:7166)
	at org.eclipse.ui.internal.Workbench.getFilteredSaveables(Workbench.java:3447)
	at org.eclipse.ui.internal.Workbench.saveAll(Workbench.java:3420)
	at org.eclipse.ui.ide.IDE$1.run(IDE.java:1494)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.ide.IDE.saveAllEditors(IDE.java:1482)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.doSave(SaveScopeResourcesHandler.java:228)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.handleStatus(SaveScopeResourcesHandler.java:182)
	at org.eclipse.debug.internal.ui.sourcelookup.Prompter.lambda$0(Prompter.java:73)
	at org.eclipse.ui.internal.PendingSyncExec.run(PendingSyncExec.java:68)
	at org.eclipse.ui.internal.UILockListener.doPendingWork(UILockListener.java:171)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4029)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1150)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1041)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.ui.workbench.texteditor 4 0 2021-10-09 20:41:21.253
!MESSAGE 
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.ui.texteditor.ITextEditor.isDirty()" because "this.fTextEditor" is null
	at org.eclipse.ui.texteditor.AbstractTextEditor$TextEditorSavable.isDirty(AbstractTextEditor.java:7166)
	at org.eclipse.ui.internal.Workbench.getFilteredSaveables(Workbench.java:3447)
	at org.eclipse.ui.internal.Workbench.saveAll(Workbench.java:3420)
	at org.eclipse.ui.ide.IDE$1.run(IDE.java:1494)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.ide.IDE.saveAllEditors(IDE.java:1482)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.doSave(SaveScopeResourcesHandler.java:228)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.handleStatus(SaveScopeResourcesHandler.java:182)
	at org.eclipse.debug.internal.ui.sourcelookup.Prompter.lambda$0(Prompter.java:73)
	at org.eclipse.ui.internal.PendingSyncExec.run(PendingSyncExec.java:68)
	at org.eclipse.ui.internal.UILockListener.doPendingWork(UILockListener.java:171)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4029)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1150)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1041)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.ui.workbench.texteditor 4 0 2021-10-09 20:49:02.320
!MESSAGE 
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.ui.texteditor.ITextEditor.isDirty()" because "this.fTextEditor" is null
	at org.eclipse.ui.texteditor.AbstractTextEditor$TextEditorSavable.isDirty(AbstractTextEditor.java:7166)
	at org.eclipse.ui.internal.Workbench.getFilteredSaveables(Workbench.java:3447)
	at org.eclipse.ui.internal.Workbench.saveAll(Workbench.java:3420)
	at org.eclipse.ui.ide.IDE$1.run(IDE.java:1494)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.ide.IDE.saveAllEditors(IDE.java:1482)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.doSave(SaveScopeResourcesHandler.java:228)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.handleStatus(SaveScopeResourcesHandler.java:182)
	at org.eclipse.debug.internal.ui.sourcelookup.Prompter.lambda$0(Prompter.java:73)
	at org.eclipse.ui.internal.PendingSyncExec.run(PendingSyncExec.java:68)
	at org.eclipse.ui.internal.UILockListener.doPendingWork(UILockListener.java:171)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4029)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1150)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1041)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SESSION 2021-10-10 00:50:38.539 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=15.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_ES
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-10-10 00:50:44.687
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-10-10 00:50:44.687
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@69944a90,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1ed52f44,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-10-10 00:50:47.434
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\omart'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-10-10 02:17:22.488 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=15.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_ES
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-10-10 02:17:25.859
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-10-10 02:17:25.859
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@79424f25,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5fd4e67f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-10-10 02:17:28.206
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\omart'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-10-10 14:37:46.735 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=15.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_ES
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-10-10 14:37:50.797
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-10-10 14:37:50.798
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@69944a90,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1ed52f44,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-10-10 14:37:54.132
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\omart'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-10-10 17:35:41.150 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=15.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_ES
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-10-10 17:35:44.904
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-10-10 17:35:44.904
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@66456506,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@69944a90,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-10-10 17:35:47.857
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\omart'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-10-12 22:08:55.667 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=15.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_ES
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-10-12 22:09:12.800
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-10-12 22:09:12.800
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@504c415c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6c9e74f3,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-10-12 22:09:15.403
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\omart'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-10-13 10:49:06.839 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=15.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_ES
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-10-13 10:49:11.468
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-10-13 10:49:11.468
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@119f072c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@66456506,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-10-13 10:49:14.863
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\omart'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-10-13 10:53:47.440 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=15.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_ES
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-10-13 10:53:50.489
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-10-13 10:53:50.489
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@79424f25,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5fd4e67f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-10-13 10:53:52.996
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\omart'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-10-13 11:31:48.544 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=15.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_ES
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-10-13 11:31:54.791
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-10-13 11:31:54.791
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5305f936,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2b1a1a37,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-10-13 11:31:57.501
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\omart'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-10-13 12:44:32.701 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=15.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_ES
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-10-13 12:44:36.366
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-10-13 12:44:36.366
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5305f936,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2b1a1a37,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-10-13 12:44:39.082
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\omart'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-10-13 22:55:00.449 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=15.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_ES
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-10-13 22:55:04.616
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-10-13 22:55:04.616
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5305f936,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2b1a1a37,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-10-13 22:55:07.709
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\omart'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-10-14 11:29:18.298 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=15.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_ES
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-10-14 11:29:25.822
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-10-14 11:29:25.822
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6f430ea8,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@119f072c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-10-14 11:29:29.038
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\omart'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.junit 4 0 2021-10-14 12:16:45.775
!MESSAGE No tests found with test runner 'JUnit 5'.
!SESSION 2021-10-14 23:11:43.548 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=15.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_ES
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-10-14 23:11:48.282
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-10-14 23:11:48.282
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@69944a90,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1ed52f44,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-10-14 23:11:51.540
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\omart'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-10-14 23:56:51.246 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=15.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_ES
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-10-14 23:56:54.379
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-10-14 23:56:54.379
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3abadb65,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7131d668,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-10-14 23:56:57.036
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\omart'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-10-20 17:59:17.921 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=15.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_ES
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-10-20 17:59:23.990
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-10-20 17:59:23.990
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@813ab53,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5030997b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-10-20 17:59:25.952
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\omart'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-10-21 18:00:01.056 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=15.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_ES
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-10-21 18:00:05.653
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-10-21 18:00:05.653
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@813ab53,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5030997b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-10-21 18:00:07.189
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\omart'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-10-26 11:17:58.610 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=15.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_ES
Framework arguments:  -product org.eclipse.epp.package.java.product -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product -data D:\Clase\3. Ingeniería Informática de Software\Segundo curso\Estructuras de Datos\Proyecto 2\ws2 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-10-26 11:18:00.574
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-10-26 11:18:00.574
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4db568e1,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7bc8ffbc,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-10-26 11:18:02.211
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\omart'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-10-26 21:40:07.078 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=15.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_ES
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-10-26 21:40:10.583
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-10-26 21:40:10.583
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@11a67420,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@663cf5d7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-10-26 21:40:12.387
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\omart'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-10-27 10:02:32.941 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=15.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_ES
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-10-27 10:03:48.052
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-10-27 10:03:48.052
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@776d8097,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7a34505a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-10-27 10:03:51.323
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\omart'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-10-27 11:10:01.021 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=15.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_ES
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-10-27 11:10:04.678
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-10-27 11:10:04.678
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5bdb6ea8,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3e55eeb9,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-10-27 11:10:07.670
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\omart'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
